ca65 V2.19 - Git 62da869e4
Main file   : boot.s
Current file: boot.s

000000r 1               ; Boot ROM for 6502 computer. Provides shell which can access test programs.
000000r 1               
000000r 1               ;.include "hardware/speaker.s"
000000r 1               .include "hardware/acia.s"
000000r 2               ACIA_RX = $8400
000000r 2               ACIA_TX = $8400
000000r 2               ACIA_STATUS = $8401
000000r 2               ACIA_COMMAND = $8402
000000r 2               ACIA_CONTROL = $8403
000000r 2               
000000r 2               acia_setup:
000000r 2               	; Polled 65c51 I/O routines. Delay routine from
000000r 2               	; http://forum.6502.org/viewtopic.php?f=4&t=2543&start=30#p29795
000000r 2  A9 00        	lda #$00 ; write anything to status register for program reset
000002r 2  8D 01 84     	sta ACIA_STATUS
000005r 2  A9 0B        	lda #$0b                    ; %0000 1011 = Receiver odd parity check
000007r 2               		                          ;              Parity mode disabled
000007r 2               		                          ;              Receiver normal mode
000007r 2               		                          ;              RTSB Low, trans int disabled
000007r 2               		                          ;              IRQB disabled
000007r 2               		                          ;              Data terminal ready (DTRB low)
000007r 2  8D 02 84     	sta ACIA_COMMAND            ; set control register
00000Ar 2  A9 1F        	lda #$1f                    ; %0001 1111 = 19200 Baud
00000Cr 2               		                          ;              External receiver
00000Cr 2               		                          ;              8 bit words
00000Cr 2               		                          ;              1 stop bit
00000Cr 2  8D 03 84     	sta ACIA_CONTROL            ; set control register
00000Fr 2  60           	rts
000010r 2               
000010r 2               acia_print_char:
000010r 2  48             pha                         ; save A
000011r 2  AD 01 84       lda ACIA_STATUS             ; Read ACIA status register
000014r 2  68             pla                         ; ELSE, restore ACCUMULATOR from STACK
000015r 2  8D 00 84       sta ACIA_TX                 ; Write byte to ACIA transmit data register
000018r 2  20 rr rr       jsr acia_delay              ; Required delay - Comment out for working 6551/65C51!
00001Br 2  60             rts                         ; Done COUT subroutine, RETURN
00001Cr 2               
00001Cr 2               acia_recv_char:
00001Cr 2  AD 01 84       lda ACIA_STATUS             ; get ACIA status
00001Fr 2  29 08          and #$08                    ; mask rx buffer status flag
000021r 2  F0 F9          beq acia_recv_char          ; loop if rx buffer empty
000023r 2  AD 00 84       lda ACIA_RX                 ; get byte from ACIA data port
000026r 2  38             sec                         ; AT ADDED - flag byte received
000027r 2  60             rts
000028r 2               
000028r 2               acia_delay:
000028r 2  5A             phy                         ; Save Y Reg
000029r 2  DA             phx                         ; Save X Reg
00002Ar 2               delay_looper:                 ; AT ADDED
00002Ar 2  A0 06          ldy   #6                    ; Get delay value (clock rate in MHz 2 clock cycles)
00002Cr 2               @minidly:
00002Cr 2  A2 68          ldx   #$68                  ; Seed X reg
00002Er 2               @delay_1:
00002Er 2  CA             dex                         ; Decrement low index
00002Fr 2  D0 FD          bne @delay_1                ; Loop back until done
000031r 2  88             dey                         ; Decrease by one
000032r 2  D0 F8          bne @minidly                ; Loop until done
000034r 2  FA             plx                         ; Restore X Reg
000035r 2  7A             ply                         ; Restore Y Reg
000036r 2               @delay_done:
000036r 2  60             rts                         ; Delay done, return
000037r 2               
000037r 2               
000037r 1               .include "hardware/via.s"
000037r 2               VIA_PORTB = $9000
000037r 2               VIA_PORTA = $9001
000037r 2               VIA_DDRB = $9002
000037r 2               VIA_DDRA = $9003
000037r 2               VIA_T1C_L = $9004
000037r 2               VIA_T1C_H = $9005
000037r 2               VIA_T1L_L = $9006
000037r 2               VIA_T1L_H = $9007
000037r 2               VIA_T2C_L = $9008
000037r 2               VIA_T2C_H = $9009
000037r 2               VIA_SR = $900a
000037r 2               VIA_ACR = $900b
000037r 2               VIA_PCR = $900c
000037r 2               VIA_IFR = $900d
000037r 2               VIA_IER = $900e
000037r 2               VIA_PORTA_2 = $900f
000037r 2               
000037r 1               
000037r 1               .segment "BSS"
000000r 1  xx           shell_cmd_id: .res 1
000001r 1  xx           shell_cmd_tmp: .res 1
000002r 1  xx           shell_buffer_used: .res 1
000003r 1  xx xx xx xx  shell_buffer: .res 64
000007r 1  xx xx xx xx  
00000Br 1  xx xx xx xx  
000043r 1               .segment "CODE"
000037r 1               
000037r 1               reset:
000037r 1                 ; Computer setup
000037r 1  A2 FF          ldx #$ff
000039r 1  9A             txs
00003Ar 1  58             cli
00003Br 1  20 rr rr       jsr acia_setup
00003Er 1               
00003Er 1                 ; Print welcome message
00003Er 1  20 rr rr       jsr shell_newline
000041r 1  A2 00          ldx #0
000043r 1               @shell_welcome_char:
000043r 1  BD rr rr       lda shell_welcome, X
000046r 1  F0 07          beq @shell_welcome_done
000048r 1  20 rr rr       jsr acia_print_char
00004Br 1  E8             inx
00004Cr 1  4C rr rr       jmp @shell_welcome_char
00004Fr 1               @shell_welcome_done:
00004Fr 1  20 rr rr     jsr shell_newline
000052r 1               
000052r 1               shell_next_command:
000052r 1                 ; Clear buffer
000052r 1  A9 00          lda #0
000054r 1  8D rr rr       sta shell_buffer_used
000057r 1                 ; Show prompt
000057r 1  A2 00          ldx #0
000059r 1               @shell_prompt_char:
000059r 1  BD rr rr       lda shell_prompt, X
00005Cr 1  F0 07          beq @shell_prompt_done
00005Er 1  20 rr rr       jsr acia_print_char
000061r 1  E8             inx
000062r 1  4C rr rr       jmp @shell_prompt_char
000065r 1               @shell_prompt_done:
000065r 1               
000065r 1               shell_next_char:
000065r 1                 ; receive char
000065r 1  20 rr rr       jsr acia_recv_char
000068r 1  8D rr rr       sta shell_cmd_tmp   ; possible future use
00006Br 1  C9 0D          cmp #$0d            ; return key pressed?
00006Dr 1  F0 10          beq @run_command    ; run the command
00006Fr 1                 ; TODO check for ASCII printable, backspace etc
00006Fr 1                 ; regular ascii char - save to buffer
00006Fr 1  AE rr rr       ldx shell_buffer_used
000072r 1  9D rr rr       sta shell_buffer, X
000075r 1  E8             inx
000076r 1  8E rr rr       stx shell_buffer_used
000079r 1                 ; print char
000079r 1  20 rr rr       jsr acia_print_char
00007Cr 1  4C rr rr       jmp shell_next_char
00007Fr 1               @run_command:
00007Fr 1  20 rr rr       jsr shell_newline
000082r 1                 ; set command ID to 0
000082r 1  AE rr rr       ldx shell_buffer_used
000085r 1  E0 00          cpx #0
000087r 1  F0 16          beq @no_command
000089r 1  A9 00          lda #0
00008Br 1  8D rr rr       sta shell_cmd_id
00008Er 1               @test_command_next:
00008Er 1  AE rr rr       ldx shell_cmd_id              ; any more commands to compare?
000091r 1  EC rr rr       cpx built_in_count
000094r 1  B0 0C          bcs @command_not_found        ; no more commands to compare
000096r 1  20 rr rr       jsr shell_command_test
000099r 1  EE rr rr       inc shell_cmd_id
00009Cr 1  4C rr rr       jmp @test_command_next
00009Fr 1               @no_command:                    ; pressed enter with nothing at the prompt
00009Fr 1  4C rr rr       jmp shell_next_command
0000A2r 1               
0000A2r 1               @command_not_found:
0000A2r 1                 ; Print not found message
0000A2r 1  A2 00          ldx #0
0000A4r 1               @shell_not_found_char:
0000A4r 1  BD rr rr       lda shell_not_found, X
0000A7r 1  F0 07          beq @shell_not_found_done
0000A9r 1  20 rr rr       jsr acia_print_char
0000ACr 1  E8             inx
0000ADr 1  4C rr rr       jmp @shell_not_found_char
0000B0r 1               @shell_not_found_done:
0000B0r 1  20 rr rr       jsr shell_newline
0000B3r 1  4C rr rr       jmp shell_next_command
0000B6r 1               
0000B6r 1               ; if command number shell_cmd_id is the one in shell_buffer then run it, oherwise return
0000B6r 1               shell_command_test:
0000B6r 1  AE rr rr       ldx shell_cmd_id            ; id of this command
0000B9r 1  BD rr rr       lda built_in_cmd_offsets, X ; start character of this command name in built_in_cmd
0000BCr 1  AA             tax                         ; x is index for next character in built_in_cmd
0000BDr 1  A0 00          ldy #0                      ; y is index for next character in shell_buffer
0000BFr 1               @nextchar:
0000BFr 1  98             tya                         ; check for end of shell command
0000C0r 1  CD rr rr       cmp shell_buffer_used
0000C3r 1  B0 1B          bcs @shell_command_end
0000C5r 1  B9 rr rr       lda shell_buffer, Y         ; next char in shell_buffer
0000C8r 1  C9 20          cmp #32                     ; check for separator between shell command and arg
0000CAr 1  F0 14          beq @shell_command_end
0000CCr 1  8D rr rr       sta shell_cmd_tmp           ; store to fixed addr for next computation
0000CFr 1  BD rr rr       lda built_in_cmd, X         ; next char in built_in_cmd
0000D2r 1  C9 00          cmp #0                      ; check for null
0000D4r 1  F0 11          beq @command_not_match      ; command we are checking has ended, user command has not
0000D6r 1  CD rr rr       cmp shell_cmd_tmp           ; check for char is equal
0000D9r 1  D0 0C          bne @command_not_match
0000DBr 1  E8             inx
0000DCr 1  C8             iny
0000DDr 1  4C rr rr       jmp @nextchar
0000E0r 1               @shell_command_end:           ; user command ended
0000E0r 1  BD rr rr       lda built_in_cmd, X         ; next char of command we are checking against
0000E3r 1  C9 00          cmp #0                      ; if we read a null here it is a match
0000E5r 1  F0 01          beq @command_match          ; command we are checking also ended
0000E7r 1               @command_not_match:
0000E7r 1  60             rts
0000E8r 1               @command_match:               ; run the command
0000E8r 1  AD rr rr       lda shell_cmd_id            ; Get command ID, multiply by 2, jump to it.
0000EBr 1  0A             asl                         ; Multiply by 2 - mem address is 2 bytes
0000ECr 1  AA             tax
0000EDr 1  7C rr rr       jmp (built_in_main, X) ; jump to this main method
0000F0r 1               
0000F0r 1  43 6F 6D 6D  shell_not_found: .asciiz "Command not found"
0000F4r 1  61 6E 64 20  
0000F8r 1  6E 6F 74 20  
000102r 1  36 35 43 30  shell_welcome: .asciiz "65C02 Computer Ready"
000106r 1  32 20 43 6F  
00010Ar 1  6D 70 75 74  
000117r 1  23 20 00     shell_prompt: .asciiz "# "
00011Ar 1               
00011Ar 1               shell_newline:
00011Ar 1  A9 0D          lda #$0d
00011Cr 1  20 rr rr       jsr acia_print_char
00011Fr 1  A9 0A          lda #$0a
000121r 1  20 rr rr       jsr acia_print_char
000124r 1  60             rts
000125r 1               
000125r 1               sys_exit:  ; Jump here to hand control back to shell
000125r 1  A2 FF          ldx #$ff ; Discard stack
000127r 1  9A             txs
000128r 1  58             cli
000129r 1  4C rr rr       jmp shell_next_command
00012Cr 1               
00012Cr 1               ;
00012Cr 1               ; Built-in command table
00012Cr 1               ;
00012Cr 1  06           built_in_count: .byte 6
00012Dr 1               built_in_cmd_offsets:
00012Dr 1  00           .byte 0
00012Er 1  05           .byte 5
00012Fr 1  0B           .byte 11
000130r 1  0E           .byte 14
000131r 1  16           .byte 22
000132r 1  1A           .byte 26
000133r 1               
000133r 1               built_in_cmd:
000133r 1  65 63 68 6F  .asciiz "echo"
000137r 1  00           
000138r 1  68 65 6C 6C  .asciiz "hello"
00013Cr 1  6F 00        
00013Er 1  72 78 00     .asciiz "rx"
000141r 1  69 72 71 74  .asciiz "irqtest"
000145r 1  65 73 74 00  
000149r 1  72 75 6E 00  .asciiz "run"
00014Dr 1  64 75 6D 70  .asciiz "dump"
000151r 1  00           
000152r 1               
000152r 1               built_in_main:
000152r 1  rr rr        .word shell_echo_main
000154r 1  rr rr        .word shell_hello_main
000156r 1  rr rr        .word shell_rx_main
000158r 1  rr rr        .word shell_irqtest_main
00015Ar 1  rr rr        .word shell_run_main
00015Cr 1  rr rr        .word shell_dump_main
00015Er 1               
00015Er 1               ;
00015Er 1               ; Built-in command: echo
00015Er 1               ;
00015Er 1               shell_echo_main:
00015Er 1  A2 05          ldx #5
000160r 1               
000160r 1               @shell_echo_char:
000160r 1  BD rr rr       lda shell_buffer, X
000163r 1  20 rr rr       jsr acia_print_char
000166r 1  E8             inx
000167r 1  EC rr rr       cpx shell_buffer_used
00016Ar 1  B0 03          bcs @shell_echo_done
00016Cr 1  4C rr rr       jmp @shell_echo_char
00016Fr 1               @shell_echo_done:
00016Fr 1  20 rr rr       jsr shell_newline
000172r 1  A9 00          lda #0
000174r 1  4C rr rr       jmp sys_exit
000177r 1               
000177r 1               ;
000177r 1               ; Built-in command: hello
000177r 1               ;
000177r 1               shell_hello_main:
000177r 1  A2 00          ldx #0
000179r 1               @hello_char:
000179r 1  BD rr rr       lda hello_world, X
00017Cr 1  F0 07          beq @hello_done
00017Er 1  20 rr rr       jsr acia_print_char
000181r 1  E8             inx
000182r 1  4C rr rr       jmp @hello_char
000185r 1               @hello_done:
000185r 1  20 rr rr       jsr shell_newline
000188r 1  A9 00          lda #0
00018Ar 1  4C rr rr       jmp sys_exit
00018Dr 1               
00018Dr 1  48 65 6C 6C  hello_world: .asciiz "Hello, world"
000191r 1  6F 2C 20 77  
000195r 1  6F 72 6C 64  
00019Ar 1               
00019Ar 1               ;
00019Ar 1               ; Built-in command: rx
00019Ar 1               ; recives a file over XMODEM protocol, and loads it into memory
00019Ar 1               USER_PROGRAM_START = $0400   ; Address for start of user programs
00019Ar 1               USER_PROGRAM_WRITE_PTR = $00 ; ZP address for writing user program
00019Ar 1               
00019Ar 1               shell_rx_main:
00019Ar 1                 ; Set pointers
00019Ar 1  A9 00          lda #<USER_PROGRAM_START   ; Low byte first
00019Cr 1  85 00          sta USER_PROGRAM_WRITE_PTR
00019Er 1  A9 04          lda #>USER_PROGRAM_START   ; High byte next
0001A0r 1  85 01          sta USER_PROGRAM_WRITE_PTR + 1
0001A2r 1                 ; Delay so that we can set up file send
0001A2r 1  A9 01          lda #1                     ; wait ~1 second
0001A4r 1  20 rr rr       jsr shell_rx_sleep_seconds
0001A7r 1                 ; NAK, ACK once
0001A7r 1               @shell_block_nak:
0001A7r 1  A9 15          lda #$15                  ; NAK gets started
0001A9r 1  20 rr rr       jsr acia_print_char
0001ACr 1                 ;lda SPEAKER               ; Click each time we send a NAK or ACK
0001ACr 1  20 rr rr       jsr shell_rx_receive_with_timeout  ; Check in loop w/ timeout
0001AFr 1  90 F6          bcc @shell_block_nak     ; Not received yet
0001B1r 1  C9 01          cmp #$01                 ; If we do have char, should be SOH
0001B3r 1  D0 4D          bne @shell_rx_fail       ; Terminate transfer if we don't get SOH
0001B5r 1               @shell_rx_block:
0001B5r 1                 ; Receive one block
0001B5r 1  20 rr rr       jsr acia_recv_char       ; Block number
0001B8r 1  20 rr rr       jsr acia_recv_char       ; Inverse block number
0001BBr 1  A0 00          ldy #0                   ; Start at char 0
0001BDr 1               @shell_rx_char:
0001BDr 1  20 rr rr       jsr acia_recv_char
0001C0r 1  91 00          sta (USER_PROGRAM_WRITE_PTR), Y
0001C2r 1  C8             iny
0001C3r 1  C0 80          cpy #128
0001C5r 1  D0 F6          bne @shell_rx_char
0001C7r 1  20 rr rr       jsr acia_recv_char      ; Checksum - TODO verify this and jump to shell_block_nak to repeat if not matching
0001CAr 1  A9 06          lda #$06                ; ACK the packet
0001CCr 1  20 rr rr       jsr acia_print_char
0001CFr 1                 ;lda SPEAKER             ; Click each time we send a NAK or ACK
0001CFr 1  20 rr rr       jsr acia_recv_char
0001D2r 1  C9 04          cmp #$04                ; EOT char, no more blocks
0001D4r 1  F0 1A          beq @shell_rx_done
0001D6r 1  C9 01          cmp #$01                ; SOH char, next block on the way
0001D8r 1  D0 CD          bne @shell_block_nak    ; Anything else fail transfer
0001DAr 1  A5 00          lda USER_PROGRAM_WRITE_PTR  ; This next part moves write pointer along by 128 bytes
0001DCr 1  C9 00          cmp #$00
0001DEr 1  F0 09          beq @block_half_advance
0001E0r 1  A9 00          lda #$00                ; If low byte != 0, set to 0 and inc high byte
0001E2r 1  85 00          sta USER_PROGRAM_WRITE_PTR
0001E4r 1  E6 01          inc USER_PROGRAM_WRITE_PTR + 1
0001E6r 1  4C rr rr       jmp @shell_rx_block
0001E9r 1               @block_half_advance:      ; If low byte = 0, set it to 128
0001E9r 1  A9 80          lda #$80
0001EBr 1  85 00          sta USER_PROGRAM_WRITE_PTR
0001EDr 1  4C rr rr       jmp @shell_rx_block
0001F0r 1               @shell_rx_done:
0001F0r 1  A9 06          lda #$6                 ; ACK the EOT as well.
0001F2r 1  20 rr rr       jsr acia_print_char
0001F5r 1                 ;lda SPEAKER             ; Click each time we send a NAK or ACK
0001F5r 1  A9 01          lda #1                  ; wait a moment (printing does not work otherwise..)
0001F7r 1  20 rr rr       jsr shell_rx_sleep_seconds
0001FAr 1               ; jsr shell_rx_print_user_program
0001FAr 1  20 rr rr       jsr shell_newline
0001FDr 1  A9 00          lda #0
0001FFr 1  4C rr rr       jmp sys_exit
000202r 1               @shell_rx_fail:
000202r 1  A9 01          lda #1
000204r 1  4C rr rr       jmp sys_exit
000207r 1               
000207r 1               ; Like acia_recv_char, but terminates after a short time if nothing is received
000207r 1               shell_rx_receive_with_timeout:
000207r 1  A0 FF          ldy #$ff
000209r 1               @y_loop:
000209r 1  A2 FF          ldx #$ff
00020Br 1               @x_loop:
00020Br 1  AD 01 84       lda ACIA_STATUS              ; check ACIA status in inner loop
00020Er 1  29 08          and #$08                     ; mask rx buffer status flag
000210r 1  D0 0C          bne @rx_got_char
000212r 1  CA             dex
000213r 1  E0 00          cpx #0
000215r 1  D0 F4          bne @x_loop
000217r 1  88             dey
000218r 1  C0 00          cpy #0
00021Ar 1  D0 ED          bne @y_loop
00021Cr 1  18             clc                          ; no byte received in time
00021Dr 1  60             rts
00021Er 1               @rx_got_char:
00021Er 1  AD 00 84       lda ACIA_RX                  ; get byte from ACIA data port
000221r 1  38             sec                          ; set carry bit
000222r 1  60             rts
000223r 1               
000223r 1               shell_rx_sleep_seconds: ; sleep for 0-63 seconds (approx)
000223r 1  48             pha                   ; save registers
000224r 1  DA             phx
000225r 1  5A             phy
000226r 1  0A             asl                   ; multiply A by 4, outer loop is approx 250ms.
000227r 1  0A             asl
000228r 1               @a_loop:
000228r 1  C9 00          cmp #0                ; stop if A is 0 (outer loop)
00022Ar 1  F0 12          beq @end
00022Cr 1  A0 FF          ldy #$ff              ; start Y at 255 and decrement (middle loop)
00022Er 1               @y_loop:
00022Er 1  A2 FF          ldx #$ff
000230r 1               @x_loop:                ; start Y at 255 and decrement (inner loop)
000230r 1  CA             dex
000231r 1  E0 00          cpx #0
000233r 1  D0 FB          bne @x_loop           ; end inner loop
000235r 1  88             dey
000236r 1  C0 00          cpy #0
000238r 1  D0 F4          bne @y_loop           ; end middle loop
00023Ar 1  3A             dec                   ; decrement A and repeat
00023Br 1  4C rr rr       jmp @a_loop           ; end outer loop
00023Er 1               @end:
00023Er 1  7A             ply                   ; restore registers
00023Fr 1  FA             plx
000240r 1  68             pla
000241r 1  60             rts
000242r 1               
000242r 1               ; test routine tp show what is being received over serial.
000242r 1               ; receive bytes from ACIA, and echo them back in hex until Ctrl+C is pressed
000242r 1               shell_rx_print_chars:
000242r 1  A2 1A          ldx #26               ; Number of hex digits per line, fills 80 chars
000244r 1               @next_byte:
000244r 1  DA             phx
000245r 1  20 rr rr       jsr acia_recv_char    ; get char
000248r 1  C9 03          cmp #$03              ; Ctrl+C?
00024Ar 1  F0 14          beq @done
00024Cr 1  20 rr rr       jsr hex_print_byte    ; print as hex (2 digits)
00024Fr 1  A9 20          lda #$20              ; space between chars
000251r 1  20 rr rr       jsr acia_print_char
000254r 1  FA             plx
000255r 1  CA             dex
000256r 1  E0 00          cpx #0
000258r 1  D0 EA          bne @next_byte        ; loop until x is 0
00025Ar 1  20 rr rr       jsr shell_newline     ; line break
00025Dr 1  4C rr rr       jmp shell_rx_print_chars
000260r 1               @done:
000260r 1  FA             plx
000261r 1  20 rr rr       jsr shell_newline     ; line break
000264r 1  60             rts
000265r 1               
000265r 1               ; Jump into user program
000265r 1               shell_run_main:
000265r 1  4C 00 04       jmp USER_PROGRAM_START
000268r 1               
000268r 1               ; Dump memory
000268r 1               shell_dump_main:
000268r 1  20 rr rr       jsr shell_rx_print_user_program
00026Br 1  20 rr rr       jsr shell_newline
00026Er 1  A9 00          lda #0
000270r 1  4C rr rr       jmp sys_exit
000273r 1               
000273r 1               shell_rx_print_user_program: ; Print the first 255 bytes of uploaded user program
000273r 1  A0 00          ldy #0
000275r 1               @user_program_line:
000275r 1  20 rr rr       jsr shell_newline
000278r 1  A2 10          ldx #16               ; Number of hex digits per line
00027Ar 1               @user_program_char:
00027Ar 1  B9 00 04       lda USER_PROGRAM_START, Y
00027Dr 1  DA             phx
00027Er 1  20 rr rr       jsr hex_print_byte    ; Print the char (clobbers X)
000281r 1  FA             plx
000282r 1  A9 20          lda #$20              ; space between chars
000284r 1  20 rr rr       jsr acia_print_char
000287r 1  C8             iny
000288r 1  C0 00          cpy #0                ; Wrap-around at 255 bytes
00028Ar 1  F0 08          beq @user_program_done
00028Cr 1  CA             dex
00028Dr 1  E0 00          cpx #0
00028Fr 1  D0 E9          bne @user_program_char
000291r 1  4C rr rr       jmp @user_program_line
000294r 1               @user_program_done:
000294r 1  60             rts
000295r 1               
000295r 1               ; Set up a timer to trigger an IRQ
000295r 1               IRQ_CONTROLLER = $8C00
000295r 1               
000295r 1               ; Some values to help us debug
000295r 1               DEBUG_LAST_INTERRUPT_INDEX = $00
000295r 1               DEBUG_INTERRUPT_COUNT = $01
000295r 1               
000295r 1               shell_irqtest_main:
000295r 1  A9 FF          lda #$ff              ; set interrupt index to dummy value (so we can see if it's not being overridden)
000297r 1  85 00          sta DEBUG_LAST_INTERRUPT_INDEX
000299r 1  A9 00          lda #$00              ; reset interrupt counter
00029Br 1  85 01          sta $01
00029Dr 1                 ; setup for via
00029Dr 1  A9 00          lda #%00000000        ; set ACR. first two bits = 00 is one-shot for T1
00029Fr 1  8D 0B 90       sta VIA_ACR
0002A2r 1  A9 C0          lda #%11000000        ; enable VIA interrupt for T1
0002A4r 1  8D 0E 90       sta VIA_IER
0002A7r 1  78             sei                   ; enable IRQ at CPU - normally off in this code
0002A8r 1                 ; set up a timer at ~65535 clock pulses.
0002A8r 1  A9 FF          lda #$ff              ; set T1 low-order counter
0002AAr 1  8D 04 90       sta VIA_T1C_L
0002ADr 1  A9 FF          lda #$ff              ; set T1 high-order counter
0002AFr 1  8D 05 90       sta VIA_T1C_H
0002B2r 1  CB             wai                   ; wait for interrupt
0002B3r 1                 ; reset for via
0002B3r 1  58             cli                   ; disable IRQ at CPU - normally off in this code
0002B4r 1  A9 40          lda #%01000000        ; disable VIA interrupt for T1
0002B6r 1                 ; Print out which interrupt was used, should be 02 if irq1_isr ran
0002B6r 1  A5 00          lda DEBUG_LAST_INTERRUPT_INDEX
0002B8r 1  20 rr rr       jsr hex_print_byte
0002BBr 1  20 rr rr       jsr shell_newline
0002BEr 1                 ; print number of times interrupt ran, should be 01 if it only ran once
0002BEr 1  A5 01          lda DEBUG_INTERRUPT_COUNT
0002C0r 1  20 rr rr       jsr hex_print_byte
0002C3r 1  20 rr rr       jsr shell_newline
0002C6r 1  A9 00          lda #0
0002C8r 1  4C rr rr       jmp sys_exit
0002CBr 1               ;
0002CBr 1               ;fake_irq:
0002CBr 1               ;  ldx IRQ_CONTROLLER        ; read interrupt controller to find highest-priority interrupt to service
0002CBr 1               ;  jmp (isr_jump_table, X)   ; jump to matching service routine
0002CBr 1               
0002CBr 1               hex_print_byte:               ; print accumulator as two ascii digits (hex)
0002CBr 1  48             pha                         ; store byte for later
0002CCr 1  4A             lsr                         ; shift out lower nibble
0002CDr 1  4A             lsr
0002CEr 1  4A             lsr
0002CFr 1  4A             lsr
0002D0r 1  AA             tax
0002D1r 1  BD rr rr       lda hex_chars, X            ; convert 0-15 to ascii char for hex digit
0002D4r 1  20 rr rr       jsr acia_print_char         ; print upper nibble
0002D7r 1  68             pla                         ; retrieve byte again
0002D8r 1  29 0F          and #$0f                    ; mask out upper nibble
0002DAr 1  AA             tax
0002DBr 1  BD rr rr       lda hex_chars, X            ; convert 0-15 to ascii char for hex digit
0002DEr 1  20 rr rr       jsr acia_print_char         ; print lower nibble
0002E1r 1  60             rts
0002E2r 1  30 31 32 33  hex_chars: .byte '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
0002E6r 1  34 35 36 37  
0002EAr 1  38 39 61 62  
0002F2r 1               
0002F2r 1               irq1_isr:                        ; interrupt routine for VIA
0002F2r 1  86 00          stx DEBUG_LAST_INTERRUPT_INDEX ; store interrupt index for debugging
0002F4r 1  AE 04 90       ldx VIA_T1C_L                  ; clear IFR bit 6 on VIA (side-effect of reading T1 low-order counter)
0002F7r 1  4C rr rr       jmp irq_return
0002FAr 1               
0002FAr 1               nop_isr:                         ; interrupt routine for anything else
0002FAr 1  86 00          stx DEBUG_LAST_INTERRUPT_INDEX ; store interrupt index for debugging
0002FCr 1  4C rr rr       jmp irq_return
0002FFr 1               
0002FFr 1               isr_jump_table:                  ; 10 possible interrupt sources
0002FFr 1  rr rr        .word nop_isr
000301r 1  rr rr        .word irq1_isr
000303r 1  rr rr        .word nop_isr
000305r 1  rr rr        .word nop_isr
000307r 1  rr rr        .word nop_isr
000309r 1  rr rr        .word nop_isr
00030Br 1  rr rr        .word nop_isr
00030Dr 1  rr rr        .word nop_isr
00030Fr 1  rr rr        .word nop_isr
000311r 1  rr rr        .word nop_isr
000313r 1  rr rr        .word nop_isr               ; 11th option for when no source is triggering the interrupt
000315r 1               
000315r 1               irq:
000315r 1  DA             phx                       ; push x for later
000316r 1  E6 01          inc DEBUG_INTERRUPT_COUNT ; count how many times this runs..
000318r 1  AE 00 8C       ldx IRQ_CONTROLLER        ; read interrupt controller to find highest-priority interrupt to service
00031Br 1  7C rr rr       jmp (isr_jump_table, X)   ; jump to matching service routine
00031Er 1               
00031Er 1               irq_return:
00031Er 1  FA             plx                       ; restore x
00031Fr 1  40             rti
000320r 1               
000320r 1               nmi:
000320r 1  40             rti
000321r 1               
000321r 1               .segment "VECTORS"
000000r 1  rr rr        .word nmi
000002r 1  rr rr        .word reset
000004r 1  rr rr        .word irq
000004r 1               
