ca65 V2.19 - Git 62da869e4
Main file   : min_mon.s
Current file: min_mon.s

000000r 1               ; minimal monitor for EhBASIC and 6502 simulator V1.05
000000r 1               ; tabs converted to space, tabwidth=6
000000r 1               
000000r 1               ; To run EhBASIC on the simulator load and assemble [F7] this file, start the simulator
000000r 1               ; running [F6] then start the code with the RESET [CTRL][SHIFT]R. Just selecting RUN
000000r 1               ; will do nothing, you'll still have to do a reset to run the code.
000000r 1               
000000r 1                     .include "basic.s"
000000r 2               
000000r 2               ; Enhanced BASIC to assemble under 6502 simulator, $ver 2.22p5
000000r 2               
000000r 2               ; $E7E1 $E7CF $E7C6 $E7D3 $E7D1 $E7D5 $E7CF $E81E $E825
000000r 2               
000000r 2               ; 2.00      new revision numbers start here
000000r 2               ; 2.01      fixed LCASE$() and UCASE$()
000000r 2               ; 2.02      new get value routine done
000000r 2               ; 2.03      changed RND() to galoise method
000000r 2               ; 2.04      fixed SPC()
000000r 2               ; 2.05      new get value routine fixed
000000r 2               ; 2.06      changed USR() code
000000r 2               ; 2.07      fixed STR$()
000000r 2               ; 2.08      changed INPUT and READ to remove need for $00 start to input buffer
000000r 2               ; 2.09      fixed RND()
000000r 2               ; 2.10      integrated missed changes from an earlier version
000000r 2               ; 2.20      added ELSE to IF .. THEN and fixed IF .. GOTO <statement> to cause error
000000r 2               ; 2.21      fixed IF .. THEN RETURN to not cause error
000000r 2               ; 2.22      fixed RND() breaking the get byte routine
000000r 2               ; 2.22p     patched to disable use of decimal mode and fix Ibuff issues
000000r 2               ;              (bugsnquirks.txt notes 2, 4 and 5)
000000r 2               ;              tabs converted to spaces, tabwidth=6
000000r 2               ; 2.22p2    fixed can't continue error on 1st statement after direct mode
000000r 2               ;              changed INPUT to throw "break in line ##" on empty line input
000000r 2               ; 2.22p3    fixed RAM above code / Ibuff above EhBASIC patch breaks STR$()
000000r 2               ;              fix provided by github user mgcaret
000000r 2               ; 2.22p4    fixed string compare of equal strings in direct mode returns FALSE
000000r 2               ;              fixed FALSE stored to a variable after a string compare
000000r 2               ;                 is > 0 and < 1E-16
000000r 2               ;              added additional stack floor protection for background interrupts
000000r 2               ;              fixed conditional LOOP & NEXT cannot find their data strucure on stack
000000r 2               ; 2.22p5    fixes issues reported by users Ruud and dclxvi on the 6502.org forum
000000r 2               ;      5.0     http://forum.6502.org/viewtopic.php?f=5&t=5500
000000r 2               ;              sanity check for RAM top allows values below RAM base
000000r 2               ;      5.1-7   http://forum.6502.org/viewtopic.php?f=5&t=5606
000000r 2               ;              1-7 coresponds to the bug# in the thread
000000r 2               ;      5.1     TO expression with a subtract may evaluate with the sign bit flipped
000000r 2               ;      5.3     call to LAB_1B5B may return to an address -$100 (page not incremented)
000000r 2               ;      5.4     string concatenate followed by MINUS or NOT() crashes EhBASIC
000000r 2               ;      5.5     garbage collection may cause an overlap with temporary strings
000000r 2               ;      5.6     floating point multiply rounding bug
000000r 2               ;      5.7     VAL() may cause string variables to be trashed
000000r 2               
000000r 2               ; zero page use ..
000000r 2               
000000r 2               ; the following locations are bulk initialized from StrTab at LAB_GMEM
000000r 2               LAB_WARM          = $00       ; BASIC warm start entry point
000000r 2               Wrmjpl            = LAB_WARM+1; BASIC warm start vector jump low byte
000000r 2               Wrmjph            = LAB_WARM+2; BASIC warm start vector jump high byte
000000r 2               
000000r 2               Usrjmp            = $0A       ; USR function JMP address
000000r 2               Usrjpl            = Usrjmp+1  ; USR function JMP vector low byte
000000r 2               Usrjph            = Usrjmp+2  ; USR function JMP vector high byte
000000r 2               Nullct            = $0D       ; nulls output after each line
000000r 2               TPos              = $0E       ; BASIC terminal position byte
000000r 2               TWidth            = $0F       ; BASIC terminal width byte
000000r 2               Iclim             = $10       ; input column limit
000000r 2               Itempl            = $11       ; temporary integer low byte
000000r 2               Itemph            = Itempl+1  ; temporary integer high byte
000000r 2               ; end bulk initialize from StrTab at LAB_GMEM
000000r 2               
000000r 2               nums_1            = Itempl    ; number to bin/hex string convert MSB
000000r 2               nums_2            = nums_1+1  ; number to bin/hex string convert
000000r 2               nums_3            = nums_1+2  ; number to bin/hex string convert LSB
000000r 2               
000000r 2               Srchc             = $5B       ; search character
000000r 2               Temp3             = Srchc     ; temp byte used in number routines
000000r 2               Scnquo            = $5C       ; scan-between-quotes flag
000000r 2               Asrch             = Scnquo    ; alt search character
000000r 2               
000000r 2               XOAw_l            = Srchc     ; eXclusive OR, OR and AND word low byte
000000r 2               XOAw_h            = Scnquo    ; eXclusive OR, OR and AND word high byte
000000r 2               
000000r 2               Ibptr             = $5D       ; input buffer pointer
000000r 2               Dimcnt            = Ibptr     ; # of dimensions
000000r 2               Tindx             = Ibptr     ; token index
000000r 2               
000000r 2               Defdim            = $5E       ; default DIM flag
000000r 2               Dtypef            = $5F       ; data type flag, $FF=string, $00=numeric
000000r 2               Oquote            = $60       ; open quote flag (b7) (Flag: DATA scan; LIST quote; memory)
000000r 2               Gclctd            = $60       ; garbage collected flag
000000r 2               Sufnxf            = $61       ; subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
000000r 2               Imode             = $62       ; input mode flag, $00=INPUT, $80=READ
000000r 2               
000000r 2               Cflag             = $63       ; comparison evaluation flag
000000r 2               
000000r 2               TabSiz            = $64       ; TAB step size (was input flag)
000000r 2               
000000r 2               next_s            = $65       ; next descriptor stack address
000000r 2               
000000r 2                                             ; these two bytes form a word pointer to the item
000000r 2                                             ; currently on top of the descriptor stack
000000r 2               last_sl           = $66       ; last descriptor stack address low byte
000000r 2               last_sh           = $67       ; last descriptor stack address high byte (always $00)
000000r 2               
000000r 2               des_sk            = $68       ; descriptor stack start address (temp strings)
000000r 2               
000000r 2               ;                 = $70       ; End of descriptor stack
000000r 2               
000000r 2               ut1_pl            = $71       ; utility pointer 1 low byte
000000r 2               ut1_ph            = ut1_pl+1  ; utility pointer 1 high byte
000000r 2               ut2_pl            = $73       ; utility pointer 2 low byte
000000r 2               ut2_ph            = ut2_pl+1  ; utility pointer 2 high byte
000000r 2               
000000r 2               Temp_2            = ut1_pl    ; temp byte for block move
000000r 2               
000000r 2               FACt_1            = $75       ; FAC temp mantissa1
000000r 2               FACt_2            = FACt_1+1  ; FAC temp mantissa2
000000r 2               FACt_3            = FACt_2+1  ; FAC temp mantissa3
000000r 2               
000000r 2               dims_l            = FACt_2    ; array dimension size low byte
000000r 2               dims_h            = FACt_3    ; array dimension size high byte
000000r 2               
000000r 2               TempB             = $78       ; temp page 0 byte
000000r 2               
000000r 2               Smeml             = $79       ; start of mem low byte       (Start-of-Basic)
000000r 2               Smemh             = Smeml+1   ; start of mem high byte      (Start-of-Basic)
000000r 2               Svarl             = $7B       ; start of vars low byte      (Start-of-Variables)
000000r 2               Svarh             = Svarl+1   ; start of vars high byte     (Start-of-Variables)
000000r 2               Sarryl            = $7D       ; var mem end low byte        (Start-of-Arrays)
000000r 2               Sarryh            = Sarryl+1  ; var mem end high byte       (Start-of-Arrays)
000000r 2               Earryl            = $7F       ; array mem end low byte      (End-of-Arrays)
000000r 2               Earryh            = Earryl+1  ; array mem end high byte     (End-of-Arrays)
000000r 2               Sstorl            = $81       ; string storage low byte     (String storage (moving down))
000000r 2               Sstorh            = Sstorl+1  ; string storage high byte    (String storage (moving down))
000000r 2               Sutill            = $83       ; string utility ptr low byte
000000r 2               Sutilh            = Sutill+1  ; string utility ptr high byte
000000r 2               Ememl             = $85       ; end of mem low byte         (Limit-of-memory)
000000r 2               Ememh             = Ememl+1   ; end of mem high byte        (Limit-of-memory)
000000r 2               Clinel            = $87       ; current line low byte       (Basic line number)
000000r 2               Clineh            = Clinel+1  ; current line high byte      (Basic line number)
000000r 2               Blinel            = $89       ; break line low byte         (Previous Basic line number)
000000r 2               Blineh            = Blinel+1  ; break line high byte        (Previous Basic line number)
000000r 2               
000000r 2               Cpntrl            = $8B       ; continue pointer low byte
000000r 2               Cpntrh            = Cpntrl+1  ; continue pointer high byte
000000r 2               
000000r 2               Dlinel            = $8D       ; current DATA line low byte
000000r 2               Dlineh            = Dlinel+1  ; current DATA line high byte
000000r 2               
000000r 2               Dptrl             = $8F       ; DATA pointer low byte
000000r 2               Dptrh             = Dptrl+1   ; DATA pointer high byte
000000r 2               
000000r 2               Rdptrl            = $91       ; read pointer low byte
000000r 2               Rdptrh            = Rdptrl+1  ; read pointer high byte
000000r 2               
000000r 2               Varnm1            = $93       ; current var name 1st byte
000000r 2               Varnm2            = Varnm1+1  ; current var name 2nd byte
000000r 2               
000000r 2               Cvaral            = $95       ; current var address low byte
000000r 2               Cvarah            = Cvaral+1  ; current var address high byte
000000r 2               
000000r 2               Frnxtl            = $97       ; var pointer for FOR/NEXT low byte
000000r 2               Frnxth            = Frnxtl+1  ; var pointer for FOR/NEXT high byte
000000r 2               
000000r 2               Tidx1             = Frnxtl    ; temp line index
000000r 2               
000000r 2               Lvarpl            = Frnxtl    ; let var pointer low byte
000000r 2               Lvarph            = Frnxth    ; let var pointer high byte
000000r 2               
000000r 2               prstk             = $99       ; precedence stacked flag
000000r 2               
000000r 2               comp_f            = $9B       ; compare function flag, bits 0,1 and 2 used
000000r 2                                             ; bit 2 set if >
000000r 2                                             ; bit 1 set if =
000000r 2                                             ; bit 0 set if <
000000r 2               
000000r 2               func_l            = $9C       ; function pointer low byte
000000r 2               func_h            = func_l+1  ; function pointer high byte
000000r 2               
000000r 2               garb_l            = func_l    ; garbage collection working pointer low byte
000000r 2               garb_h            = func_h    ; garbage collection working pointer high byte
000000r 2               
000000r 2               des_2l            = $9E       ; string descriptor_2 pointer low byte
000000r 2               des_2h            = des_2l+1  ; string descriptor_2 pointer high byte
000000r 2               
000000r 2               g_step            = $A0       ; garbage collect step size
000000r 2               
000000r 2               Fnxjmp            = $A1       ; jump vector for functions
000000r 2               Fnxjpl            = Fnxjmp+1  ; functions jump vector low byte
000000r 2               Fnxjph            = Fnxjmp+2  ; functions jump vector high byte
000000r 2               
000000r 2               g_indx            = Fnxjpl    ; garbage collect temp index
000000r 2               
000000r 2               FAC2_r            = $A3       ; FAC2 rounding byte
000000r 2               
000000r 2               Adatal            = $A4       ; array data pointer low byte
000000r 2               Adatah            = Adatal+1  ; array data pointer high  byte
000000r 2               
000000r 2               Nbendl            = Adatal    ; new block end pointer low byte
000000r 2               Nbendh            = Adatah    ; new block end pointer high  byte
000000r 2               
000000r 2               Obendl            = $A6       ; old block end pointer low byte
000000r 2               Obendh            = Obendl+1  ; old block end pointer high  byte
000000r 2               
000000r 2               numexp            = $A8       ; string to float number exponent count
000000r 2               expcnt            = $A9       ; string to float exponent count
000000r 2               
000000r 2               numbit            = numexp    ; bit count for array element calculations
000000r 2               
000000r 2               numdpf            = $AA       ; string to float decimal point flag
000000r 2               expneg            = $AB       ; string to float eval exponent -ve flag
000000r 2               
000000r 2               Astrtl            = numdpf    ; array start pointer low byte
000000r 2               Astrth            = expneg    ; array start pointer high  byte
000000r 2               
000000r 2               Histrl            = numdpf    ; highest string low byte
000000r 2               Histrh            = expneg    ; highest string high  byte
000000r 2               
000000r 2               Baslnl            = numdpf    ; BASIC search line pointer low byte
000000r 2               Baslnh            = expneg    ; BASIC search line pointer high  byte
000000r 2               
000000r 2               Fvar_l            = numdpf    ; find/found variable pointer low byte
000000r 2               Fvar_h            = expneg    ; find/found variable pointer high  byte
000000r 2               
000000r 2               Ostrtl            = numdpf    ; old block start pointer low byte
000000r 2               Ostrth            = expneg    ; old block start pointer high  byte
000000r 2               
000000r 2               Vrschl            = numdpf    ; variable search pointer low byte
000000r 2               Vrschh            = expneg    ; variable search pointer high  byte
000000r 2               
000000r 2               FAC1_e            = $AC       ; FAC1 exponent
000000r 2               FAC1_1            = FAC1_e+1  ; FAC1 mantissa1
000000r 2               FAC1_2            = FAC1_e+2  ; FAC1 mantissa2
000000r 2               FAC1_3            = FAC1_e+3  ; FAC1 mantissa3
000000r 2               FAC1_s            = FAC1_e+4  ; FAC1 sign (b7)
000000r 2               
000000r 2               str_ln            = FAC1_e    ; string length
000000r 2               str_pl            = FAC1_1    ; string pointer low byte
000000r 2               str_ph            = FAC1_2    ; string pointer high byte
000000r 2               
000000r 2               des_pl            = FAC1_2    ; string descriptor pointer low byte
000000r 2               des_ph            = FAC1_3    ; string descriptor pointer high byte
000000r 2               
000000r 2               mids_l            = FAC1_3    ; MID$ string temp length byte
000000r 2               
000000r 2               negnum            = $B1       ; string to float eval -ve flag
000000r 2               numcon            = $B1       ; series evaluation constant count
000000r 2               
000000r 2               FAC1_o            = $B2       ; FAC1 overflow byte
000000r 2               
000000r 2               FAC2_e            = $B3       ; FAC2 exponent
000000r 2               FAC2_1            = FAC2_e+1  ; FAC2 mantissa1
000000r 2               FAC2_2            = FAC2_e+2  ; FAC2 mantissa2
000000r 2               FAC2_3            = FAC2_e+3  ; FAC2 mantissa3
000000r 2               FAC2_s            = FAC2_e+4  ; FAC2 sign (b7)
000000r 2               
000000r 2               FAC_sc            = $B8       ; FAC sign comparison, Acc#1 vs #2
000000r 2               FAC1_r            = $B9       ; FAC1 rounding byte
000000r 2               
000000r 2               ssptr_l           = FAC_sc    ; string start pointer low byte
000000r 2               ssptr_h           = FAC1_r    ; string start pointer high byte
000000r 2               
000000r 2               sdescr            = FAC_sc    ; string descriptor pointer
000000r 2               
000000r 2               csidx             = $BA       ; line crunch save index
000000r 2               Asptl             = csidx     ; array size/pointer low byte
000000r 2               Aspth             = $BB       ; array size/pointer high byte
000000r 2               
000000r 2               Btmpl             = Asptl     ; BASIC pointer temp low byte
000000r 2               Btmph             = Aspth     ; BASIC pointer temp low byte
000000r 2               
000000r 2               Cptrl             = Asptl     ; BASIC pointer temp low byte
000000r 2               Cptrh             = Aspth     ; BASIC pointer temp low byte
000000r 2               
000000r 2               Sendl             = Asptl     ; BASIC pointer temp low byte
000000r 2               Sendh             = Aspth     ; BASIC pointer temp low byte
000000r 2               
000000r 2               ; the following locations are bulk initialized from LAB_2CEE at LAB_2D4E
000000r 2               LAB_IGBY          = $BC       ; get next BASIC byte subroutine
000000r 2               
000000r 2               LAB_GBYT          = $C2       ; get current BASIC byte subroutine
000000r 2               Bpntrl            = $C3       ; BASIC execute (get byte) pointer low byte
000000r 2               Bpntrh            = Bpntrl+1  ; BASIC execute (get byte) pointer high byte
000000r 2               
000000r 2               ;                 = $D7       ; end of get BASIC char subroutine
000000r 2               ; end bulk initialize from LAB_2CEE at LAB_2D4E
000000r 2               
000000r 2               Rbyte4            = $D8       ; extra PRNG byte
000000r 2               Rbyte1            = Rbyte4+1  ; most significant PRNG byte
000000r 2               Rbyte2            = Rbyte4+2  ; middle PRNG byte
000000r 2               Rbyte3            = Rbyte4+3  ; least significant PRNG byte
000000r 2               
000000r 2               NmiBase           = $DC       ; NMI handler enabled/setup/triggered flags
000000r 2                                             ; bit function
000000r 2                                             ; === ========
000000r 2                                             ; 7   interrupt enabled
000000r 2                                             ; 6   interrupt setup
000000r 2                                             ; 5   interrupt happened
000000r 2               ;                 = $DD       ; NMI handler addr low byte
000000r 2               ;                 = $DE       ; NMI handler addr high byte
000000r 2               IrqBase           = $DF       ; IRQ handler enabled/setup/triggered flags
000000r 2               ;                 = $E0       ; IRQ handler addr low byte
000000r 2               ;                 = $E1       ; IRQ handler addr high byte
000000r 2               
000000r 2               ; *** removed unused comments for $DE-$E1
000000r 2               
000000r 2               ;                 = $E2       ; unused
000000r 2               ;                 = $E3       ; unused
000000r 2               ;                 = $E4       ; unused
000000r 2               ;                 = $E5       ; unused
000000r 2               ;                 = $E6       ; unused
000000r 2               ;                 = $E7       ; unused
000000r 2               ;                 = $E8       ; unused
000000r 2               ;                 = $E9       ; unused
000000r 2               ;                 = $EA       ; unused
000000r 2               ;                 = $EB       ; unused
000000r 2               ;                 = $EC       ; unused
000000r 2               ;                 = $ED       ; unused
000000r 2               ;                 = $EE       ; unused
000000r 2               
000000r 2               Decss             = $EF       ; number to decimal string start
000000r 2               Decssp1           = Decss+1   ; number to decimal string start
000000r 2               
000000r 2               ;                 = $FF       ; decimal string end
000000r 2               
000000r 2               ; token values needed for BASIC
000000r 2               
000000r 2               ; primary command tokens (can start a statement)
000000r 2               
000000r 2               TK_END            = $80             ; END token
000000r 2               TK_FOR            = TK_END+1        ; FOR token
000000r 2               TK_NEXT           = TK_FOR+1        ; NEXT token
000000r 2               TK_DATA           = TK_NEXT+1       ; DATA token
000000r 2               TK_INPUT          = TK_DATA+1       ; INPUT token
000000r 2               TK_DIM            = TK_INPUT+1      ; DIM token
000000r 2               TK_READ           = TK_DIM+1        ; READ token
000000r 2               TK_LET            = TK_READ+1       ; LET token
000000r 2               TK_DEC            = TK_LET+1        ; DEC token
000000r 2               TK_GOTO           = TK_DEC+1        ; GOTO token
000000r 2               TK_RUN            = TK_GOTO+1       ; RUN token
000000r 2               TK_IF             = TK_RUN+1        ; IF token
000000r 2               TK_RESTORE        = TK_IF+1         ; RESTORE token
000000r 2               TK_GOSUB          = TK_RESTORE+1    ; GOSUB token
000000r 2               TK_RETIRQ         = TK_GOSUB+1      ; RETIRQ token
000000r 2               TK_RETNMI         = TK_RETIRQ+1     ; RETNMI token
000000r 2               TK_RETURN         = TK_RETNMI+1     ; RETURN token
000000r 2               TK_REM            = TK_RETURN+1     ; REM token
000000r 2               TK_STOP           = TK_REM+1        ; STOP token
000000r 2               TK_ON             = TK_STOP+1       ; ON token
000000r 2               TK_NULL           = TK_ON+1         ; NULL token
000000r 2               TK_INC            = TK_NULL+1       ; INC token
000000r 2               TK_WAIT           = TK_INC+1        ; WAIT token
000000r 2               TK_LOAD           = TK_WAIT+1       ; LOAD token
000000r 2               TK_SAVE           = TK_LOAD+1       ; SAVE token
000000r 2               TK_DEF            = TK_SAVE+1       ; DEF token
000000r 2               TK_POKE           = TK_DEF+1        ; POKE token
000000r 2               TK_DOKE           = TK_POKE+1       ; DOKE token
000000r 2               TK_CALL           = TK_DOKE+1       ; CALL token
000000r 2               TK_DO             = TK_CALL+1       ; DO token
000000r 2               TK_LOOP           = TK_DO+1         ; LOOP token
000000r 2               TK_PRINT          = TK_LOOP+1       ; PRINT token
000000r 2               TK_CONT           = TK_PRINT+1      ; CONT token
000000r 2               TK_LIST           = TK_CONT+1       ; LIST token
000000r 2               TK_CLEAR          = TK_LIST+1       ; CLEAR token
000000r 2               TK_NEW            = TK_CLEAR+1      ; NEW token
000000r 2               TK_WIDTH          = TK_NEW+1        ; WIDTH token
000000r 2               TK_GET            = TK_WIDTH+1      ; GET token
000000r 2               TK_SWAP           = TK_GET+1        ; SWAP token
000000r 2               TK_BITSET         = TK_SWAP+1       ; BITSET token
000000r 2               TK_BITCLR         = TK_BITSET+1     ; BITCLR token
000000r 2               TK_IRQ            = TK_BITCLR+1     ; IRQ token
000000r 2               TK_NMI            = TK_IRQ+1        ; NMI token
000000r 2               
000000r 2               ; secondary command tokens, can't start a statement
000000r 2               
000000r 2               TK_TAB            = TK_NMI+1        ; TAB token
000000r 2               TK_ELSE           = TK_TAB+1        ; ELSE token
000000r 2               TK_TO             = TK_ELSE+1       ; TO token
000000r 2               TK_FN             = TK_TO+1         ; FN token
000000r 2               TK_SPC            = TK_FN+1         ; SPC token
000000r 2               TK_THEN           = TK_SPC+1        ; THEN token
000000r 2               TK_NOT            = TK_THEN+1       ; NOT token
000000r 2               TK_STEP           = TK_NOT+1        ; STEP token
000000r 2               TK_UNTIL          = TK_STEP+1       ; UNTIL token
000000r 2               TK_WHILE          = TK_UNTIL+1      ; WHILE token
000000r 2               TK_OFF            = TK_WHILE+1      ; OFF token
000000r 2               
000000r 2               ; opperator tokens
000000r 2               
000000r 2               TK_PLUS           = TK_OFF+1        ; + token
000000r 2               TK_MINUS          = TK_PLUS+1       ; - token
000000r 2               TK_MUL            = TK_MINUS+1      ; * token
000000r 2               TK_DIV            = TK_MUL+1        ; / token
000000r 2               TK_POWER          = TK_DIV+1        ; ^ token
000000r 2               TK_AND            = TK_POWER+1      ; AND token
000000r 2               TK_EOR            = TK_AND+1        ; EOR token
000000r 2               TK_OR             = TK_EOR+1        ; OR token
000000r 2               TK_RSHIFT         = TK_OR+1         ; RSHIFT token
000000r 2               TK_LSHIFT         = TK_RSHIFT+1     ; LSHIFT token
000000r 2               TK_GT             = TK_LSHIFT+1     ; > token
000000r 2               TK_EQUAL          = TK_GT+1         ; = token
000000r 2               TK_LT             = TK_EQUAL+1      ; < token
000000r 2               
000000r 2               ; functions tokens
000000r 2               
000000r 2               TK_SGN            = TK_LT+1         ; SGN token
000000r 2               TK_INT            = TK_SGN+1        ; INT token
000000r 2               TK_ABS            = TK_INT+1        ; ABS token
000000r 2               TK_USR            = TK_ABS+1        ; USR token
000000r 2               TK_FRE            = TK_USR+1        ; FRE token
000000r 2               TK_POS            = TK_FRE+1        ; POS token
000000r 2               TK_SQR            = TK_POS+1        ; SQR token
000000r 2               TK_RND            = TK_SQR+1        ; RND token
000000r 2               TK_LOG            = TK_RND+1        ; LOG token
000000r 2               TK_EXP            = TK_LOG+1        ; EXP token
000000r 2               TK_COS            = TK_EXP+1        ; COS token
000000r 2               TK_SIN            = TK_COS+1        ; SIN token
000000r 2               TK_TAN            = TK_SIN+1        ; TAN token
000000r 2               TK_ATN            = TK_TAN+1        ; ATN token
000000r 2               TK_PEEK           = TK_ATN+1        ; PEEK token
000000r 2               TK_DEEK           = TK_PEEK+1       ; DEEK token
000000r 2               TK_SADD           = TK_DEEK+1       ; SADD token
000000r 2               TK_LEN            = TK_SADD+1       ; LEN token
000000r 2               TK_STRS           = TK_LEN+1        ; STR$ token
000000r 2               TK_VAL            = TK_STRS+1       ; VAL token
000000r 2               TK_ASC            = TK_VAL+1        ; ASC token
000000r 2               TK_UCASES         = TK_ASC+1        ; UCASE$ token
000000r 2               TK_LCASES         = TK_UCASES+1     ; LCASE$ token
000000r 2               TK_CHRS           = TK_LCASES+1     ; CHR$ token
000000r 2               TK_HEXS           = TK_CHRS+1       ; HEX$ token
000000r 2               TK_BINS           = TK_HEXS+1       ; BIN$ token
000000r 2               TK_BITTST         = TK_BINS+1       ; BITTST token
000000r 2               TK_MAX            = TK_BITTST+1     ; MAX token
000000r 2               TK_MIN            = TK_MAX+1        ; MIN token
000000r 2               TK_PI             = TK_MIN+1        ; PI token
000000r 2               TK_TWOPI          = TK_PI+1         ; TWOPI token
000000r 2               TK_VPTR           = TK_TWOPI+1      ; VARPTR token
000000r 2               TK_LEFTS          = TK_VPTR+1       ; LEFT$ token
000000r 2               TK_RIGHTS         = TK_LEFTS+1      ; RIGHT$ token
000000r 2               TK_MIDS           = TK_RIGHTS+1     ; MID$ token
000000r 2               
000000r 2               ; offsets from a base of X or Y
000000r 2               
000000r 2               PLUS_0            = $00       ; X or Y plus 0
000000r 2               PLUS_1            = $01       ; X or Y plus 1
000000r 2               PLUS_2            = $02       ; X or Y plus 2
000000r 2               PLUS_3            = $03       ; X or Y plus 3
000000r 2               
000000r 2               LAB_STAK          = $0100     ; stack bottom, no offset
000000r 2               
000000r 2               LAB_SKFE          = LAB_STAK+$FE
000000r 2                                             ; flushed stack address
000000r 2               LAB_SKFF          = LAB_STAK+$FF
000000r 2                                             ; flushed stack address
000000r 2               
000000r 2               ; the following locations are bulk initialized from PG2_TABS at LAB_COLD
000000r 2               ccflag            = $0200     ; BASIC CTRL-C flag, 00 = enabled, 01 = dis
000000r 2               ccbyte            = ccflag+1  ; BASIC CTRL-C byte
000000r 2               ccnull            = ccbyte+1  ; BASIC CTRL-C byte timeout
000000r 2               
000000r 2               VEC_CC            = ccnull+1  ; ctrl c check vector
000000r 2               ; end bulk initialize from PG2_TABS at LAB_COLD
000000r 2               
000000r 2               ; the following locations are bulk initialized by min_mon.asm from LAB_vec at LAB_stlp
000000r 2               VEC_IN            = VEC_CC+2  ; input vector
000000r 2               VEC_OUT           = VEC_IN+2  ; output vector
000000r 2               VEC_LD            = VEC_OUT+2 ; load vector
000000r 2               VEC_SV            = VEC_LD+2  ; save vector
000000r 2               ; end bulk initialize by min_mon.asm from LAB_vec at LAB_stlp
000000r 2               
000000r 2               ; Ibuffs can now be anywhere in RAM, ensure that the max length is < $80,
000000r 2               ; the input buffer must not cross a page boundary and must not overlap with
000000r 2               ; program RAM pages!
000000r 2               
000000r 2               ;Ibuffs            = IRQ_vec+$14
000000r 2               Ibuffs            = VEC_SV+$16
000000r 2                                             ; start of input buffer after IRQ/NMI code
000000r 2               Ibuffe            = Ibuffs+$47; end of input buffer
000000r 2               
000000r 2               Ram_base          = $0300     ; start of user RAM (set as needed, should be page aligned)
000000r 2               Ram_top           = $8000     ; end of user RAM+1 (set as needed, should be page aligned)
000000r 2               
000000r 2               Stack_floor       = 16        ; bytes left free on stack for background interrupts
000000r 2               
000000r 2               ; This start can be changed to suit your system
000000r 2               
000000r 2                     .segment "CODE"
000000r 2               
000000r 2               ; BASIC cold start entry point
000000r 2               
000000r 2               ; new page 2 initialisation, copy block to ccflag on
000000r 2               
000000r 2               LAB_COLD
000000r 2  A0 04              LDY   #PG2_TABE-PG2_TABS-1
000002r 2                                             ; byte count-1
000002r 2               LAB_2D13
000002r 2  B9 rr rr           LDA   PG2_TABS,Y        ; get byte
000005r 2  99 00 02           STA   ccflag,Y          ; store in page 2
000008r 2  88                 DEY                     ; decrement count
000009r 2  10 F7              BPL   LAB_2D13          ; loop if not done
00000Br 2               
00000Br 2  A2 FF              LDX   #$FF              ; set byte
00000Dr 2  86 88              STX   Clineh            ; set current line high byte (set immediate mode)
00000Fr 2  9A                 TXS                     ; reset stack pointer
000010r 2               
000010r 2  A9 4C              LDA   #$4C              ; code for JMP
000012r 2  85 A1              STA   Fnxjmp            ; save for jump vector for functions
000014r 2               
000014r 2               ; copy block from LAB_2CEE to $00BC - $00D7
000014r 2               
000014r 2  A2 1C              LDX   #StrTab-LAB_2CEE  ; set byte count
000016r 2               LAB_2D4E
000016r 2  BD rr rr           LDA   LAB_2CEE-1,X      ; get byte from table
000019r 2  95 BB              STA   LAB_IGBY-1,X      ; save byte in page zero
00001Br 2  CA                 DEX                     ; decrement count
00001Cr 2  D0 F8              BNE   LAB_2D4E          ; loop if not all done
00001Er 2               
00001Er 2               ; copy block from StrTab to $0000 - $0012
00001Er 2               
00001Er 2               LAB_GMEM
00001Er 2  A2 12              LDX   #EndTab-StrTab-1  ; set byte count-1
000020r 2               TabLoop
000020r 2  BD rr rr           LDA   StrTab,X          ; get byte from table
000023r 2  95 00              STA   PLUS_0,X          ; save byte in page zero
000025r 2  CA                 DEX                     ; decrement count
000026r 2  10 F8              BPL   TabLoop           ; loop if not all done
000028r 2               
000028r 2               ; set-up start values
000028r 2               
000028r 2  A9 00              LDA   #$00              ; clear A
00002Ar 2  85 DC              STA   NmiBase           ; clear NMI handler enabled flag
00002Cr 2  85 DF              STA   IrqBase           ; clear IRQ handler enabled flag
00002Er 2  85 B2              STA   FAC1_o            ; clear FAC1 overflow byte
000030r 2  85 67              STA   last_sh           ; clear descriptor stack top item pointer high byte
000032r 2               
000032r 2  A9 0E              LDA   #$0E              ; set default tab size
000034r 2  85 64              STA   TabSiz            ; save it
000036r 2  A9 03              LDA   #$03              ; set garbage collect step size for descriptor stack
000038r 2  85 A0              STA   g_step            ; save it
00003Ar 2  A2 68              LDX   #des_sk           ; descriptor stack start
00003Cr 2  86 65              STX   next_s            ; set descriptor stack pointer
00003Er 2  20 rr rr           JSR   LAB_CRLF          ; print CR/LF
000041r 2  A9 rr              LDA   #<LAB_MSZM        ; point to memory size message (low addr)
000043r 2  A0 rr              LDY   #>LAB_MSZM        ; point to memory size message (high addr)
000045r 2  20 rr rr           JSR   LAB_18C3          ; print null terminated string from memory
000048r 2  20 rr rr           JSR   LAB_INLN          ; print "? " and get BASIC input
00004Br 2  86 C3              STX   Bpntrl            ; set BASIC execute pointer low byte
00004Dr 2  84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
00004Fr 2  20 C2 00           JSR   LAB_GBYT          ; get last byte back
000052r 2               
000052r 2  D0 1F              BNE   LAB_2DAA          ; branch if not null (user typed something)
000054r 2               
000054r 2  A0 00              LDY   #$00              ; else clear Y
000056r 2                                             ; character was null so get memory size the hard way
000056r 2                                             ; we get here with Y=0 and Itempl/h = Ram_base
000056r 2               LAB_2D93
000056r 2  E6 11              INC   Itempl            ; increment temporary integer low byte
000058r 2  D0 08              BNE   LAB_2D99          ; branch if no overflow
00005Ar 2               
00005Ar 2  E6 12              INC   Itemph            ; increment temporary integer high byte
00005Cr 2  A5 12              LDA   Itemph            ; get high byte
00005Er 2  C9 80              CMP   #>Ram_top         ; compare with top of RAM+1
000060r 2  F0 1D              BEQ   LAB_2DB6          ; branch if match (end of user RAM)
000062r 2               
000062r 2               LAB_2D99
000062r 2  A9 55              LDA   #$55              ; set test byte
000064r 2  91 11              STA   (Itempl),Y        ; save via temporary integer
000066r 2  D1 11              CMP   (Itempl),Y        ; compare via temporary integer
000068r 2  D0 15              BNE   LAB_2DB6          ; branch if fail
00006Ar 2               
00006Ar 2  0A                 ASL                     ; shift test byte left (now $AA)
00006Br 2  91 11              STA   (Itempl),Y        ; save via temporary integer
00006Dr 2  D1 11              CMP   (Itempl),Y        ; compare via temporary integer
00006Fr 2  F0 E5              BEQ   LAB_2D93          ; if ok go do next byte
000071r 2               
000071r 2  D0 0C              BNE   LAB_2DB6          ; branch if fail
000073r 2               
000073r 2               LAB_2DAA
000073r 2  20 rr rr           JSR   LAB_2887          ; get FAC1 from string
000076r 2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
000078r 2  C9 98              CMP   #$98              ; compare with exponent = 2^24
00007Ar 2  B0 A2              BCS   LAB_GMEM          ; if too large go try again
00007Cr 2               
00007Cr 2  20 rr rr           JSR   LAB_F2FU          ; save integer part of FAC1 in temporary integer
00007Fr 2                                             ; (no range check)
00007Fr 2               
00007Fr 2               LAB_2DB6
00007Fr 2  A5 11              LDA   Itempl            ; get temporary integer low byte
000081r 2  A4 12              LDY   Itemph            ; get temporary integer high byte
000083r 2               ; *** begin patch  2.22p5.0 RAM top sanity check ***
000083r 2               ; *** replace
000083r 2               ;      CPY   #<Ram_base+1      ; compare with start of RAM+$100 high byte
000083r 2               ; +++ with
000083r 2  C0 04              CPY   #>Ram_base+1      ; compare with start of RAM+$100 high byte
000085r 2               ; *** end patch    2.22p5.0 ***
000085r 2  90 97              BCC   LAB_GMEM          ; if too small go try again
000087r 2               
000087r 2               
000087r 2               ; uncomment these lines if you want to check on the high limit of memory. Note if
000087r 2               ; Ram_top is set too low then this will fail. default is ignore it and assume the
000087r 2               ; users know what they're doing!
000087r 2               
000087r 2               ;     CPY   #>Ram_top         ; compare with top of RAM high byte
000087r 2               ;     BCC   MEM_OK            ; branch if < RAM top
000087r 2               
000087r 2               ;     BNE   LAB_GMEM          ; if too large go try again
000087r 2                                             ; else was = so compare low bytes
000087r 2               ;     CMP   #<Ram_top         ; compare with top of RAM low byte
000087r 2               ;     BEQ   MEM_OK            ; branch if = RAM top
000087r 2               
000087r 2               ;     BCS   LAB_GMEM          ; if too large go try again
000087r 2               
000087r 2               ;MEM_OK
000087r 2  85 85              STA   Ememl             ; set end of mem low byte
000089r 2  84 86              STY   Ememh             ; set end of mem high byte
00008Br 2  85 81              STA   Sstorl            ; set bottom of string space low byte
00008Dr 2  84 82              STY   Sstorh            ; set bottom of string space high byte
00008Fr 2               
00008Fr 2  A0 00              LDY   #<Ram_base        ; set start addr low byte
000091r 2  A2 03              LDX   #>Ram_base        ; set start addr high byte
000093r 2  84 79              STY   Smeml             ; save start of mem low byte
000095r 2  86 7A              STX   Smemh             ; save start of mem high byte
000097r 2               
000097r 2               ; this line is only needed if Ram_base is not $xx00
000097r 2                     .IF   Ram_base&$FF>0
000097r 2                     LDY   #$00              ; clear Y
000097r 2                     .ENDIF
000097r 2               
000097r 2  98                 TYA                     ; clear A
000098r 2  91 79              STA   (Smeml),Y         ; clear first byte
00009Ar 2  E6 79              INC   Smeml             ; increment start of mem low byte
00009Cr 2               
00009Cr 2               ; these two lines are only needed if Ram_base is $xxFF
00009Cr 2                     .IF   Ram_base&$FF=$FF
00009Cr 2                     BNE   LAB_2E05          ; branch if no rollover
00009Cr 2                     INC   Smemh             ; increment start of mem high byte
00009Cr 2               LAB_2E05
00009Cr 2                     .ENDIF
00009Cr 2               
00009Cr 2  20 rr rr           JSR   LAB_CRLF          ; print CR/LF
00009Fr 2  20 rr rr           JSR   LAB_1463          ; do "NEW" and "CLEAR"
0000A2r 2  A5 85              LDA   Ememl             ; get end of mem low byte
0000A4r 2  38                 SEC                     ; set carry for subtract
0000A5r 2  E5 79              SBC   Smeml             ; subtract start of mem low byte
0000A7r 2  AA                 TAX                     ; copy to X
0000A8r 2  A5 86              LDA   Ememh             ; get end of mem high byte
0000AAr 2  E5 7A              SBC   Smemh             ; subtract start of mem high byte
0000ACr 2  20 rr rr           JSR   LAB_295E          ; print XA as unsigned integer (bytes free)
0000AFr 2  A9 rr              LDA   #<LAB_SMSG        ; point to sign-on message (low addr)
0000B1r 2  A0 rr              LDY   #>LAB_SMSG        ; point to sign-on message (high addr)
0000B3r 2  20 rr rr           JSR   LAB_18C3          ; print null terminated string from memory
0000B6r 2  A9 rr              LDA   #<LAB_1274        ; warm start vector low byte
0000B8r 2  A0 rr              LDY   #>LAB_1274        ; warm start vector high byte
0000BAr 2  85 01              STA   Wrmjpl            ; save warm start vector low byte
0000BCr 2  84 02              STY   Wrmjph            ; save warm start vector high byte
0000BEr 2  6C 01 00           JMP   (Wrmjpl)          ; go do warm start
0000C1r 2               
0000C1r 2               ; open up space in memory
0000C1r 2               ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
0000C1r 2               
0000C1r 2               ; Nbendl,Nbendh - new block end address (A/Y)
0000C1r 2               ; Obendl,Obendh - old block end address
0000C1r 2               ; Ostrtl,Ostrth - old block start address
0000C1r 2               
0000C1r 2               ; returns with ..
0000C1r 2               
0000C1r 2               ; Nbendl,Nbendh - new block start address (high byte - $100)
0000C1r 2               ; Obendl,Obendh - old block start address (high byte - $100)
0000C1r 2               ; Ostrtl,Ostrth - old block start address (unchanged)
0000C1r 2               
0000C1r 2               LAB_11CF
0000C1r 2  20 rr rr           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
0000C4r 2                                             ; addr to check is in AY (low/high)
0000C4r 2  85 7F              STA   Earryl            ; save new array mem end low byte
0000C6r 2  84 80              STY   Earryh            ; save new array mem end high byte
0000C8r 2               
0000C8r 2               ; open up space in memory
0000C8r 2               ; move (Ostrtl)-(Obendl) to new block ending at (Nbendl)
0000C8r 2               ; don't set array end
0000C8r 2               
0000C8r 2               LAB_11D6
0000C8r 2  38                 SEC                     ; set carry for subtract
0000C9r 2  A5 A6              LDA   Obendl            ; get block end low byte
0000CBr 2  E5 AA              SBC   Ostrtl            ; subtract block start low byte
0000CDr 2  A8                 TAY                     ; copy MOD(block length/$100) byte to Y
0000CEr 2  A5 A7              LDA   Obendh            ; get block end high byte
0000D0r 2  E5 AB              SBC   Ostrth            ; subtract block start high byte
0000D2r 2  AA                 TAX                     ; copy block length high byte to X
0000D3r 2  E8                 INX                     ; +1 to allow for count=0 exit
0000D4r 2  98                 TYA                     ; copy block length low byte to A
0000D5r 2  F0 24              BEQ   LAB_120A          ; branch if length low byte=0
0000D7r 2               
0000D7r 2                                             ; block is (X-1)*256+Y bytes, do the Y bytes first
0000D7r 2               
0000D7r 2  38                 SEC                     ; set carry for add + 1, two's complement
0000D8r 2  49 FF              EOR   #$FF              ; invert low byte for subtract
0000DAr 2  65 A6              ADC   Obendl            ; add block end low byte
0000DCr 2               
0000DCr 2  85 A6              STA   Obendl            ; save corrected old block end low byte
0000DEr 2  B0 03              BCS   LAB_11F3          ; branch if no underflow
0000E0r 2               
0000E0r 2  C6 A7              DEC   Obendh            ; else decrement block end high byte
0000E2r 2  38                 SEC                     ; set carry for add + 1, two's complement
0000E3r 2               LAB_11F3
0000E3r 2  98                 TYA                     ; get MOD(block length/$100) byte
0000E4r 2  49 FF              EOR   #$FF              ; invert low byte for subtract
0000E6r 2  65 A4              ADC   Nbendl            ; add destination end low byte
0000E8r 2  85 A4              STA   Nbendl            ; save modified new block end low byte
0000EAr 2  B0 08              BCS   LAB_1203          ; branch if no underflow
0000ECr 2               
0000ECr 2  C6 A5              DEC   Nbendh            ; else decrement block end high byte
0000EEr 2  90 04              BCC   LAB_1203          ; branch always
0000F0r 2               
0000F0r 2               LAB_11FF
0000F0r 2  B1 A6              LDA   (Obendl),Y        ; get byte from source
0000F2r 2  91 A4              STA   (Nbendl),Y        ; copy byte to destination
0000F4r 2               LAB_1203
0000F4r 2  88                 DEY                     ; decrement index
0000F5r 2  D0 F9              BNE   LAB_11FF          ; loop until Y=0
0000F7r 2               
0000F7r 2                                             ; now do Y=0 indexed byte
0000F7r 2  B1 A6              LDA   (Obendl),Y        ; get byte from source
0000F9r 2  91 A4              STA   (Nbendl),Y        ; save byte to destination
0000FBr 2               LAB_120A
0000FBr 2  C6 A7              DEC   Obendh            ; decrement source pointer high byte
0000FDr 2  C6 A5              DEC   Nbendh            ; decrement destination pointer high byte
0000FFr 2  CA                 DEX                     ; decrement block count
000100r 2  D0 F2              BNE   LAB_1203          ; loop until count = $0
000102r 2               
000102r 2  60                 RTS
000103r 2               
000103r 2               ; check room on stack for A bytes
000103r 2               ; stack too deep? do OM error
000103r 2               
000103r 2               LAB_1212
000103r 2               ; *** patch - additional stack floor protection for background interrupts
000103r 2               ; *** add
000103r 2                     .IF   Stack_floor
000103r 2  18                 CLC                     ; prep ADC
000104r 2  69 10              ADC   #Stack_floor      ; stack pointer lower limit before interrupts
000106r 2                     .ENDIF
000106r 2               ; *** end patch
000106r 2  85 78              STA   TempB             ; save result in temp byte
000108r 2  BA                 TSX                     ; copy stack
000109r 2  E4 78              CPX   TempB             ; compare new "limit" with stack
00010Br 2  90 30              BCC   LAB_OMER          ; if stack < limit do "Out of memory" error then warm start
00010Dr 2               
00010Dr 2  60                 RTS
00010Er 2               
00010Er 2               ; check available memory, "Out of memory" error if no room
00010Er 2               ; addr to check is in AY (low/high)
00010Er 2               
00010Er 2               LAB_121F
00010Er 2  C4 82              CPY   Sstorh            ; compare bottom of string mem high byte
000110r 2  90 2A              BCC   LAB_124B          ; if less then exit (is ok)
000112r 2               
000112r 2  D0 04              BNE   LAB_1229          ; skip next test if greater (tested <)
000114r 2               
000114r 2                                             ; high byte was =, now do low byte
000114r 2  C5 81              CMP   Sstorl            ; compare with bottom of string mem low byte
000116r 2  90 24              BCC   LAB_124B          ; if less then exit (is ok)
000118r 2               
000118r 2                                             ; addr is > string storage ptr (oops!)
000118r 2               LAB_1229
000118r 2  48                 PHA                     ; push addr low byte
000119r 2  A2 08              LDX   #$08              ; set index to save Adatal to expneg inclusive
00011Br 2  98                 TYA                     ; copy addr high byte (to push on stack)
00011Cr 2               
00011Cr 2                                             ; save misc numeric work area
00011Cr 2               LAB_122D
00011Cr 2  48                 PHA                     ; push byte
00011Dr 2  B5 A3              LDA   Adatal-1,X        ; get byte from Adatal to expneg ( ,$00 not pushed)
00011Fr 2  CA                 DEX                     ; decrement index
000120r 2  10 FA              BPL   LAB_122D          ; loop until all done
000122r 2               
000122r 2  20 rr rr           JSR   LAB_GARB          ; garbage collection routine
000125r 2               
000125r 2                                             ; restore misc numeric work area
000125r 2  A2 00              LDX   #$00              ; clear the index to restore bytes
000127r 2               LAB_1238
000127r 2  68                 PLA                     ; pop byte
000128r 2  95 A4              STA   Adatal,X          ; save byte to Adatal to expneg
00012Ar 2  E8                 INX                     ; increment index
00012Br 2  E0 08              CPX   #$08              ; compare with end + 1
00012Dr 2  30 F8              BMI   LAB_1238          ; loop if more to do
00012Fr 2               
00012Fr 2  68                 PLA                     ; pop addr high byte
000130r 2  A8                 TAY                     ; copy back to Y
000131r 2  68                 PLA                     ; pop addr low byte
000132r 2  C4 82              CPY   Sstorh            ; compare bottom of string mem high byte
000134r 2  90 06              BCC   LAB_124B          ; if less then exit (is ok)
000136r 2               
000136r 2  D0 05              BNE   LAB_OMER          ; if greater do "Out of memory" error then warm start
000138r 2               
000138r 2                                             ; high byte was =, now do low byte
000138r 2  C5 81              CMP   Sstorl            ; compare with bottom of string mem low byte
00013Ar 2  B0 01              BCS   LAB_OMER          ; if >= do "Out of memory" error then warm start
00013Cr 2               
00013Cr 2                                             ; ok exit, carry clear
00013Cr 2               LAB_124B
00013Cr 2  60                 RTS
00013Dr 2               
00013Dr 2               ; do "Out of memory" error then warm start
00013Dr 2               
00013Dr 2               LAB_OMER
00013Dr 2  A2 0C              LDX   #$0C              ; error code $0C ("Out of memory" error)
00013Fr 2               
00013Fr 2               ; do error #X, then warm start
00013Fr 2               
00013Fr 2               LAB_XERR
00013Fr 2  20 rr rr           JSR   LAB_CRLF          ; print CR/LF
000142r 2               
000142r 2  BD rr rr           LDA   LAB_BAER,X        ; get error message pointer low byte
000145r 2  BC rr rr           LDY   LAB_BAER+1,X      ; get error message pointer high byte
000148r 2  20 rr rr           JSR   LAB_18C3          ; print null terminated string from memory
00014Br 2               
00014Br 2  20 rr rr           JSR   LAB_1491          ; flush stack and clear continue flag
00014Er 2  A9 rr              LDA   #<LAB_EMSG        ; point to " Error" low addr
000150r 2  A0 rr              LDY   #>LAB_EMSG        ; point to " Error" high addr
000152r 2               LAB_1269
000152r 2  20 rr rr           JSR   LAB_18C3          ; print null terminated string from memory
000155r 2  A4 88              LDY   Clineh            ; get current line high byte
000157r 2  C8                 INY                     ; increment it
000158r 2  F0 03              BEQ   LAB_1274          ; go do warm start (was immediate mode)
00015Ar 2               
00015Ar 2                                             ; else print line number
00015Ar 2  20 rr rr           JSR   LAB_2953          ; print " in line [LINE #]"
00015Dr 2               
00015Dr 2               ; BASIC warm start entry point
00015Dr 2               ; wait for Basic command
00015Dr 2               
00015Dr 2               LAB_1274
00015Dr 2                                             ; clear ON IRQ/NMI bytes
00015Dr 2  A9 00              LDA   #$00              ; clear A
00015Fr 2  85 DF              STA   IrqBase           ; clear enabled byte
000161r 2  85 DC              STA   NmiBase           ; clear enabled byte
000163r 2  A9 rr              LDA   #<LAB_RMSG        ; point to "Ready" message low byte
000165r 2  A0 rr              LDY   #>LAB_RMSG        ; point to "Ready" message high byte
000167r 2               
000167r 2  20 rr rr           JSR   LAB_18C3          ; go do print string
00016Ar 2               
00016Ar 2               ; wait for Basic command (no "Ready")
00016Ar 2               
00016Ar 2               LAB_127D
00016Ar 2  20 rr rr           JSR   LAB_1357          ; call for BASIC input
00016Dr 2               LAB_1280
00016Dr 2  86 C3              STX   Bpntrl            ; set BASIC execute pointer low byte
00016Fr 2  84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
000171r 2  20 C2 00           JSR   LAB_GBYT          ; scan memory
000174r 2  F0 F4              BEQ   LAB_127D          ; loop while null
000176r 2               
000176r 2               ; got to interpret input line now ..
000176r 2               
000176r 2  A2 FF              LDX   #$FF              ; current line to null value
000178r 2  86 88              STX   Clineh            ; set current line high byte
00017Ar 2  90 06              BCC   LAB_1295          ; branch if numeric character (handle new BASIC line)
00017Cr 2               
00017Cr 2                                             ; no line number .. immediate mode
00017Cr 2  20 rr rr           JSR   LAB_13A6          ; crunch keywords into Basic tokens
00017Fr 2  4C rr rr           JMP   LAB_15F6          ; go scan and interpret code
000182r 2               
000182r 2               ; handle new BASIC line
000182r 2               
000182r 2               LAB_1295
000182r 2  20 rr rr           JSR   LAB_GFPN          ; get fixed-point number into temp integer
000185r 2  20 rr rr           JSR   LAB_13A6          ; crunch keywords into Basic tokens
000188r 2  84 5D              STY   Ibptr             ; save index pointer to end of crunched line
00018Ar 2  20 rr rr           JSR   LAB_SSLN          ; search BASIC for temp integer line number
00018Dr 2  90 44              BCC   LAB_12E6          ; branch if not found
00018Fr 2               
00018Fr 2                                             ; aroooogah! line # already exists! delete it
00018Fr 2  A0 01              LDY   #$01              ; set index to next line pointer high byte
000191r 2  B1 AA              LDA   (Baslnl),Y        ; get next line pointer high byte
000193r 2  85 72              STA   ut1_ph            ; save it
000195r 2  A5 7B              LDA   Svarl             ; get start of vars low byte
000197r 2  85 71              STA   ut1_pl            ; save it
000199r 2  A5 AB              LDA   Baslnh            ; get found line pointer high byte
00019Br 2  85 74              STA   ut2_ph            ; save it
00019Dr 2  A5 AA              LDA   Baslnl            ; get found line pointer low byte
00019Fr 2  88                 DEY                     ; decrement index
0001A0r 2  F1 AA              SBC   (Baslnl),Y        ; subtract next line pointer low byte
0001A2r 2  18                 CLC                     ; clear carry for add
0001A3r 2  65 7B              ADC   Svarl             ; add start of vars low byte
0001A5r 2  85 7B              STA   Svarl             ; save new start of vars low byte
0001A7r 2  85 73              STA   ut2_pl            ; save destination pointer low byte
0001A9r 2  A5 7C              LDA   Svarh             ; get start of vars high byte
0001ABr 2  69 FF              ADC   #$FF              ; -1 + carry
0001ADr 2  85 7C              STA   Svarh             ; save start of vars high byte
0001AFr 2  E5 AB              SBC   Baslnh            ; subtract found line pointer high byte
0001B1r 2  AA                 TAX                     ; copy to block count
0001B2r 2  38                 SEC                     ; set carry for subtract
0001B3r 2  A5 AA              LDA   Baslnl            ; get found line pointer low byte
0001B5r 2  E5 7B              SBC   Svarl             ; subtract start of vars low byte
0001B7r 2  A8                 TAY                     ; copy to bytes in first block count
0001B8r 2  B0 03              BCS   LAB_12D0          ; branch if overflow
0001BAr 2               
0001BAr 2  E8                 INX                     ; increment block count (correct for =0 loop exit)
0001BBr 2  C6 74              DEC   ut2_ph            ; decrement destination high byte
0001BDr 2               LAB_12D0
0001BDr 2  18                 CLC                     ; clear carry for add
0001BEr 2  65 71              ADC   ut1_pl            ; add source pointer low byte
0001C0r 2  90 03              BCC   LAB_12D8          ; branch if no overflow
0001C2r 2               
0001C2r 2  C6 72              DEC   ut1_ph            ; else decrement source pointer high byte
0001C4r 2  18                 CLC                     ; clear carry
0001C5r 2               
0001C5r 2                                             ; close up memory to delete old line
0001C5r 2               LAB_12D8
0001C5r 2  B1 71              LDA   (ut1_pl),Y        ; get byte from source
0001C7r 2  91 73              STA   (ut2_pl),Y        ; copy to destination
0001C9r 2  C8                 INY                     ; increment index
0001CAr 2  D0 F9              BNE   LAB_12D8          ; while <> 0 do this block
0001CCr 2               
0001CCr 2  E6 72              INC   ut1_ph            ; increment source pointer high byte
0001CEr 2  E6 74              INC   ut2_ph            ; increment destination pointer high byte
0001D0r 2  CA                 DEX                     ; decrement block count
0001D1r 2  D0 F2              BNE   LAB_12D8          ; loop until all done
0001D3r 2               
0001D3r 2                                             ; got new line in buffer and no existing same #
0001D3r 2               LAB_12E6
0001D3r 2  AD 21 02           LDA   Ibuffs            ; get byte from start of input buffer
0001D6r 2  F0 3F              BEQ   LAB_1319          ; if null line just go flush stack/vars and exit
0001D8r 2               
0001D8r 2                                             ; got new line and it isn't empty line
0001D8r 2  A5 85              LDA   Ememl             ; get end of mem low byte
0001DAr 2  A4 86              LDY   Ememh             ; get end of mem high byte
0001DCr 2  85 81              STA   Sstorl            ; set bottom of string space low byte
0001DEr 2  84 82              STY   Sstorh            ; set bottom of string space high byte
0001E0r 2  A5 7B              LDA   Svarl             ; get start of vars low byte  (end of BASIC)
0001E2r 2  85 A6              STA   Obendl            ; save old block end low byte
0001E4r 2  A4 7C              LDY   Svarh             ; get start of vars high byte (end of BASIC)
0001E6r 2  84 A7              STY   Obendh            ; save old block end high byte
0001E8r 2  65 5D              ADC   Ibptr             ; add input buffer pointer    (also buffer length)
0001EAr 2  90 01              BCC   LAB_1301          ; branch if no overflow from add
0001ECr 2               
0001ECr 2  C8                 INY                     ; else increment high byte
0001EDr 2               LAB_1301
0001EDr 2  85 A4              STA   Nbendl            ; save new block end low byte (move to, low byte)
0001EFr 2  84 A5              STY   Nbendh            ; save new block end high byte
0001F1r 2  20 rr rr           JSR   LAB_11CF          ; open up space in memory
0001F4r 2                                             ; old start pointer Ostrtl,Ostrth set by the find line call
0001F4r 2  A5 7F              LDA   Earryl            ; get array mem end low byte
0001F6r 2  A4 80              LDY   Earryh            ; get array mem end high byte
0001F8r 2  85 7B              STA   Svarl             ; save start of vars low byte
0001FAr 2  84 7C              STY   Svarh             ; save start of vars high byte
0001FCr 2  A4 5D              LDY   Ibptr             ; get input buffer pointer    (also buffer length)
0001FEr 2  88                 DEY                     ; adjust for loop type
0001FFr 2               LAB_1311
0001FFr 2  B9 1D 02           LDA   Ibuffs-4,Y        ; get byte from crunched line
000202r 2  91 AA              STA   (Baslnl),Y        ; save it to program memory
000204r 2  88                 DEY                     ; decrement count
000205r 2  C0 03              CPY   #$03              ; compare with first byte-1
000207r 2  D0 F6              BNE   LAB_1311          ; continue while count <> 3
000209r 2               
000209r 2  A5 12              LDA   Itemph            ; get line # high byte
00020Br 2  91 AA              STA   (Baslnl),Y        ; save it to program memory
00020Dr 2  88                 DEY                     ; decrement count
00020Er 2  A5 11              LDA   Itempl            ; get line # low byte
000210r 2  91 AA              STA   (Baslnl),Y        ; save it to program memory
000212r 2  88                 DEY                     ; decrement count
000213r 2  A9 FF              LDA   #$FF              ; set byte to allow chain rebuild. if you didn't set this
000215r 2                                             ; byte then a zero already here would stop the chain rebuild
000215r 2                                             ; as it would think it was the [EOT] marker.
000215r 2  91 AA              STA   (Baslnl),Y        ; save it to program memory
000217r 2               
000217r 2               LAB_1319
000217r 2  20 rr rr           JSR   LAB_1477          ; reset execution to start, clear vars and flush stack
00021Ar 2  A6 79              LDX   Smeml             ; get start of mem low byte
00021Cr 2  A5 7A              LDA   Smemh             ; get start of mem high byte
00021Er 2  A0 01              LDY   #$01              ; index to high byte of next line pointer
000220r 2               LAB_1325
000220r 2  86 71              STX   ut1_pl            ; set line start pointer low byte
000222r 2  85 72              STA   ut1_ph            ; set line start pointer high byte
000224r 2  B1 71              LDA   (ut1_pl),Y        ; get it
000226r 2  F0 18              BEQ   LAB_133E          ; exit if end of program
000228r 2               
000228r 2               ; rebuild chaining of Basic lines
000228r 2               
000228r 2  A0 04              LDY   #$04              ; point to first code byte of line
00022Ar 2                                             ; there is always 1 byte + [EOL] as null entries are deleted
00022Ar 2               LAB_1330
00022Ar 2  C8                 INY                     ; next code byte
00022Br 2  B1 71              LDA   (ut1_pl),Y        ; get byte
00022Dr 2  D0 FB              BNE   LAB_1330          ; loop if not [EOL]
00022Fr 2               
00022Fr 2  38                 SEC                     ; set carry for add + 1
000230r 2  98                 TYA                     ; copy end index
000231r 2  65 71              ADC   ut1_pl            ; add to line start pointer low byte
000233r 2  AA                 TAX                     ; copy to X
000234r 2  A0 00              LDY   #$00              ; clear index, point to this line's next line pointer
000236r 2  91 71              STA   (ut1_pl),Y        ; set next line pointer low byte
000238r 2  98                 TYA                     ; clear A
000239r 2  65 72              ADC   ut1_ph            ; add line start pointer high byte + carry
00023Br 2  C8                 INY                     ; increment index to high byte
00023Cr 2  91 71              STA   (ut1_pl),Y        ; save next line pointer low byte
00023Er 2  90 E0              BCC   LAB_1325          ; go do next line, branch always, carry clear
000240r 2               
000240r 2               
000240r 2               LAB_133E
000240r 2  4C rr rr           JMP   LAB_127D          ; else we just wait for Basic command, no "Ready"
000243r 2               
000243r 2               ; print "? " and get BASIC input
000243r 2               
000243r 2               LAB_INLN
000243r 2  20 rr rr           JSR   LAB_18E3          ; print "?" character
000246r 2  20 rr rr           JSR   LAB_18E0          ; print " "
000249r 2  D0 05              BNE   LAB_1357          ; call for BASIC input and return
00024Br 2               
00024Br 2               ; receive line from keyboard
00024Br 2               
00024Br 2                                             ; $08 as delete key (BACKSPACE on standard keyboard)
00024Br 2               LAB_134B
00024Br 2  20 rr rr           JSR   LAB_PRNA          ; go print the character
00024Er 2  CA                 DEX                     ; decrement the buffer counter (delete)
00024Fr 2  2C                 .byte $2C               ; make LDX into BIT abs
000250r 2               
000250r 2               ; call for BASIC input (main entry point)
000250r 2               
000250r 2               LAB_1357
000250r 2  A2 00              LDX   #$00              ; clear BASIC line buffer pointer
000252r 2               LAB_1359
000252r 2  20 rr rr           JSR   V_INPT            ; call scan input device
000255r 2  90 FB              BCC   LAB_1359          ; loop if no byte
000257r 2               
000257r 2  F0 F9              BEQ   LAB_1359          ; loop until valid input (ignore NULLs)
000259r 2               
000259r 2  C9 07              CMP   #$07              ; compare with [BELL]
00025Br 2  F0 10              BEQ   LAB_1378          ; branch if [BELL]
00025Dr 2               
00025Dr 2  C9 0D              CMP   #$0D              ; compare with [CR]
00025Fr 2  F0 19              BEQ   LAB_1384          ; do CR/LF exit if [CR]
000261r 2               
000261r 2  E0 00              CPX   #$00              ; compare pointer with $00
000263r 2  D0 04              BNE   LAB_1374          ; branch if not empty
000265r 2               
000265r 2               ; next two lines ignore any non print character and [SPACE] if input buffer empty
000265r 2               
000265r 2  C9 21              CMP   #$21              ; compare with [SP]+1
000267r 2  90 E9              BCC   LAB_1359          ; if < ignore character
000269r 2               
000269r 2               LAB_1374
000269r 2  C9 08              CMP   #$08              ; compare with [BACKSPACE] (delete last character)
00026Br 2  F0 DE              BEQ   LAB_134B          ; go delete last character
00026Dr 2               
00026Dr 2               LAB_1378
00026Dr 2  E0 47              CPX   #Ibuffe-Ibuffs    ; compare character count with max
00026Fr 2  B0 0C              BCS   LAB_138E          ; skip store and do [BELL] if buffer full
000271r 2               
000271r 2  9D 21 02           STA   Ibuffs,X          ; else store in buffer
000274r 2  E8                 INX                     ; increment pointer
000275r 2               LAB_137F
000275r 2  20 rr rr           JSR   LAB_PRNA          ; go print the character
000278r 2  D0 D8              BNE   LAB_1359          ; always loop for next character
00027Ar 2               
00027Ar 2               LAB_1384
00027Ar 2  4C rr rr           JMP   LAB_1866          ; do CR/LF exit to BASIC
00027Dr 2               
00027Dr 2               ; announce buffer full
00027Dr 2               
00027Dr 2               LAB_138E
00027Dr 2  A9 07              LDA   #$07              ; [BELL] character into A
00027Fr 2  D0 F4              BNE   LAB_137F          ; go print the [BELL] but ignore input character
000281r 2                                             ; branch always
000281r 2               
000281r 2               ; crunch keywords into Basic tokens
000281r 2               ; position independent buffer version ..
000281r 2               ; faster, dictionary search version ....
000281r 2               
000281r 2               LAB_13A6
000281r 2  A0 FF              LDY   #$FF              ; set save index (makes for easy math later)
000283r 2               
000283r 2  38                 SEC                     ; set carry for subtract
000284r 2  A5 C3              LDA   Bpntrl            ; get basic execute pointer low byte
000286r 2  E9 21              SBC   #<Ibuffs          ; subtract input buffer start pointer
000288r 2  AA                 TAX                     ; copy result to X (index past line # if any)
000289r 2               
000289r 2  86 60              STX   Oquote            ; clear open quote/DATA flag
00028Br 2               LAB_13AC
00028Br 2  BD 21 02           LDA   Ibuffs,X          ; get byte from input buffer
00028Er 2  F0 51              BEQ   LAB_13EC          ; if null save byte then exit
000290r 2               
000290r 2  C9 5F              CMP   #'_'              ; compare with "_"
000292r 2  B0 4D              BCS   LAB_13EC          ; if >= go save byte then continue crunching
000294r 2               
000294r 2  C9 3C              CMP   #'<'              ; compare with "<"
000296r 2  B0 0E              BCS   LAB_13CC          ; if >= go crunch now
000298r 2               
000298r 2  C9 30              CMP   #'0'              ; compare with "0"
00029Ar 2  B0 45              BCS   LAB_13EC          ; if >= go save byte then continue crunching
00029Cr 2               
00029Cr 2  85 5C              STA   Scnquo            ; save buffer byte as search character
00029Er 2  C9 22              CMP   #$22              ; is it quote character?
0002A0r 2  F0 61              BEQ   LAB_1410          ; branch if so (copy quoted string)
0002A2r 2               
0002A2r 2  C9 2A              CMP   #'*'              ; compare with "*"
0002A4r 2  90 3B              BCC   LAB_13EC          ; if < go save byte then continue crunching
0002A6r 2               
0002A6r 2                                             ; else crunch now
0002A6r 2               LAB_13CC
0002A6r 2  24 60              BIT   Oquote            ; get open quote/DATA token flag
0002A8r 2  70 37              BVS   LAB_13EC          ; branch if b6 of Oquote set (was DATA)
0002AAr 2                                             ; go save byte then continue crunching
0002AAr 2               
0002AAr 2  86 78              STX   TempB             ; save buffer read index
0002ACr 2  84 BA              STY   csidx             ; copy buffer save index
0002AEr 2  A0 rr              LDY   #<TAB_1STC        ; get keyword first character table low address
0002B0r 2  84 73              STY   ut2_pl            ; save pointer low byte
0002B2r 2  A0 rr              LDY   #>TAB_1STC        ; get keyword first character table high address
0002B4r 2  84 74              STY   ut2_ph            ; save pointer high byte
0002B6r 2  A0 00              LDY   #$00              ; clear table pointer
0002B8r 2               
0002B8r 2               LAB_13D0
0002B8r 2  D1 73              CMP   (ut2_pl),Y        ; compare with keyword first character table byte
0002BAr 2  F0 05              BEQ   LAB_13D1          ; go do word_table_chr if match
0002BCr 2               
0002BCr 2  90 21              BCC   LAB_13EA          ; if < keyword first character table byte go restore
0002BEr 2                                             ; Y and save to crunched
0002BEr 2               
0002BEr 2  C8                 INY                     ; else increment pointer
0002BFr 2  D0 F7              BNE   LAB_13D0          ; and loop (branch always)
0002C1r 2               
0002C1r 2               ; have matched first character of some keyword
0002C1r 2               
0002C1r 2               LAB_13D1
0002C1r 2  98                 TYA                     ; copy matching index
0002C2r 2  0A                 ASL                     ; *2 (bytes per pointer)
0002C3r 2  AA                 TAX                     ; copy to new index
0002C4r 2  BD rr rr           LDA   TAB_CHRT,X        ; get keyword table pointer low byte
0002C7r 2  85 73              STA   ut2_pl            ; save pointer low byte
0002C9r 2  BD rr rr           LDA   TAB_CHRT+1,X      ; get keyword table pointer high byte
0002CCr 2  85 74              STA   ut2_ph            ; save pointer high byte
0002CEr 2               
0002CEr 2  A0 FF              LDY   #$FF              ; clear table pointer (make -1 for start)
0002D0r 2               
0002D0r 2  A6 78              LDX   TempB             ; restore buffer read index
0002D2r 2               
0002D2r 2               LAB_13D6
0002D2r 2  C8                 INY                     ; next table byte
0002D3r 2  B1 73              LDA   (ut2_pl),Y        ; get byte from table
0002D5r 2               LAB_13D8
0002D5r 2  30 08              BMI   LAB_13EA          ; all bytes matched so go save token
0002D7r 2               
0002D7r 2  E8                 INX                     ; next buffer byte
0002D8r 2  DD 21 02           CMP   Ibuffs,X          ; compare with byte from input buffer
0002DBr 2  F0 F5              BEQ   LAB_13D6          ; go compare next if match
0002DDr 2               
0002DDr 2  D0 2B              BNE   LAB_1417          ; branch if >< (not found keyword)
0002DFr 2               
0002DFr 2               LAB_13EA
0002DFr 2  A4 BA              LDY   csidx             ; restore save index
0002E1r 2               
0002E1r 2                                             ; save crunched to output
0002E1r 2               LAB_13EC
0002E1r 2  E8                 INX                     ; increment buffer index (to next input byte)
0002E2r 2  C8                 INY                     ; increment save index (to next output byte)
0002E3r 2  99 21 02           STA   Ibuffs,Y          ; save byte to output
0002E6r 2  C9 00              CMP   #$00              ; set the flags, set carry
0002E8r 2  F0 32              BEQ   LAB_142A          ; do exit if was null [EOL]
0002EAr 2               
0002EAr 2                                             ; A holds token or byte here
0002EAr 2  E9 3A              SBC   #':'              ; subtract ":" (carry set by CMP #00)
0002ECr 2  F0 04              BEQ   LAB_13FF          ; branch if it was ":" (is now $00)
0002EEr 2               
0002EEr 2                                             ; A now holds token-$3A
0002EEr 2  C9 49              CMP   #TK_DATA-$3A      ; compare with DATA token - $3A
0002F0r 2  D0 02              BNE   LAB_1401          ; branch if not DATA
0002F2r 2               
0002F2r 2                                             ; token was : or DATA
0002F2r 2               LAB_13FF
0002F2r 2  85 60              STA   Oquote            ; save token-$3A (clear for ":", TK_DATA-$3A for DATA)
0002F4r 2               LAB_1401
0002F4r 2  49 57              EOR   #TK_REM-$3A       ; effectively subtract REM token offset
0002F6r 2  D0 93              BNE   LAB_13AC          ; If wasn't REM then go crunch rest of line
0002F8r 2               
0002F8r 2  85 5C              STA   Asrch             ; else was REM so set search for [EOL]
0002FAr 2               
0002FAr 2                                             ; loop for REM, "..." etc.
0002FAr 2               LAB_1408
0002FAr 2  BD 21 02           LDA   Ibuffs,X          ; get byte from input buffer
0002FDr 2  F0 E2              BEQ   LAB_13EC          ; branch if null [EOL]
0002FFr 2               
0002FFr 2  C5 5C              CMP   Asrch             ; compare with stored character
000301r 2  F0 DE              BEQ   LAB_13EC          ; branch if match (end quote)
000303r 2               
000303r 2                                             ; entry for copy string in quotes, don't crunch
000303r 2               LAB_1410
000303r 2  C8                 INY                     ; increment buffer save index
000304r 2  99 21 02           STA   Ibuffs,Y          ; save byte to output
000307r 2  E8                 INX                     ; increment buffer read index
000308r 2  D0 F0              BNE   LAB_1408          ; loop while <> 0 (should never be 0!)
00030Ar 2               
00030Ar 2                                             ; not found keyword this go
00030Ar 2               LAB_1417
00030Ar 2  A6 78              LDX   TempB             ; compare has failed, restore buffer index (start byte!)
00030Cr 2               
00030Cr 2                                             ; now find the end of this word in the table
00030Cr 2               LAB_141B
00030Cr 2  B1 73              LDA   (ut2_pl),Y        ; get table byte
00030Er 2  08                 PHP                     ; save status
00030Fr 2  C8                 INY                     ; increment table index
000310r 2  28                 PLP                     ; restore byte status
000311r 2  10 F9              BPL   LAB_141B          ; if not end of keyword go do next
000313r 2               
000313r 2  B1 73              LDA   (ut2_pl),Y        ; get byte from keyword table
000315r 2  D0 BE              BNE   LAB_13D8          ; go test next word if not zero byte (end of table)
000317r 2               
000317r 2                                             ; reached end of table with no match
000317r 2  BD 21 02           LDA   Ibuffs,X          ; restore byte from input buffer
00031Ar 2  10 C3              BPL   LAB_13EA          ; branch always (all bytes in buffer are $00-$7F)
00031Cr 2                                             ; go save byte in output and continue crunching
00031Cr 2               
00031Cr 2                                             ; reached [EOL]
00031Cr 2               LAB_142A
00031Cr 2  C8                 INY                     ; increment pointer
00031Dr 2  C8                 INY                     ; increment pointer (makes it next line pointer high byte)
00031Er 2  99 21 02           STA   Ibuffs,Y          ; save [EOL] (marks [EOT] in immediate mode)
000321r 2  C8                 INY                     ; adjust for line copy
000322r 2  C8                 INY                     ; adjust for line copy
000323r 2  C8                 INY                     ; adjust for line copy
000324r 2               ; *** begin patch for when Ibuffs is $xx00 - Daryl Rictor ***
000324r 2               ; *** insert
000324r 2                     .IF   Ibuffs&$FF=0
000324r 2                     LDA   Bpntrl            ; test for $00
000324r 2                     BNE   LAB_142P          ; not $00
000324r 2                     DEC   Bpntrh            ; allow for increment when $xx00
000324r 2               LAB_142P
000324r 2                     .ENDIF
000324r 2               ; *** end   patch for when Ibuffs is $xx00 - Daryl Rictor ***
000324r 2               ; end of patch
000324r 2  C6 C3              DEC   Bpntrl            ; allow for increment
000326r 2  60                 RTS
000327r 2               
000327r 2               ; search Basic for temp integer line number from start of mem
000327r 2               
000327r 2               LAB_SSLN
000327r 2  A5 79              LDA   Smeml             ; get start of mem low byte
000329r 2  A6 7A              LDX   Smemh             ; get start of mem high byte
00032Br 2               
00032Br 2               ; search Basic for temp integer line number from AX
00032Br 2               ; returns carry set if found
00032Br 2               ; returns Baslnl/Baslnh pointer to found or next higher (not found) line
00032Br 2               
00032Br 2               ; old 541 new 507
00032Br 2               
00032Br 2               LAB_SHLN
00032Br 2  A0 01              LDY   #$01              ; set index
00032Dr 2  85 AA              STA   Baslnl            ; save low byte as current
00032Fr 2  86 AB              STX   Baslnh            ; save high byte as current
000331r 2  B1 AA              LDA   (Baslnl),Y        ; get pointer high byte from addr
000333r 2  F0 1A              BEQ   LAB_145F          ; pointer was zero so we're done, do 'not found' exit
000335r 2               
000335r 2  A0 03              LDY   #$03              ; set index to line # high byte
000337r 2  B1 AA              LDA   (Baslnl),Y        ; get line # high byte
000339r 2  88                 DEY                     ; decrement index (point to low byte)
00033Ar 2  C5 12              CMP   Itemph            ; compare with temporary integer high byte
00033Cr 2  D0 04              BNE   LAB_1455          ; if <> skip low byte check
00033Er 2               
00033Er 2  B1 AA              LDA   (Baslnl),Y        ; get line # low byte
000340r 2  C5 11              CMP   Itempl            ; compare with temporary integer low byte
000342r 2               LAB_1455
000342r 2  B0 09              BCS   LAB_145E          ; else if temp < this line, exit (passed line#)
000344r 2               
000344r 2               LAB_1456
000344r 2  88                 DEY                     ; decrement index to next line ptr high byte
000345r 2  B1 AA              LDA   (Baslnl),Y        ; get next line pointer high byte
000347r 2  AA                 TAX                     ; copy to X
000348r 2  88                 DEY                     ; decrement index to next line ptr low byte
000349r 2  B1 AA              LDA   (Baslnl),Y        ; get next line pointer low byte
00034Br 2  90 DE              BCC   LAB_SHLN          ; go search for line # in temp (Itempl/Itemph) from AX
00034Dr 2                                             ; (carry always clear)
00034Dr 2               
00034Dr 2               LAB_145E
00034Dr 2  F0 01              BEQ   LAB_1460          ; exit if temp = found line #, carry is set
00034Fr 2               
00034Fr 2               LAB_145F
00034Fr 2  18                 CLC                     ; clear found flag
000350r 2               LAB_1460
000350r 2  60                 RTS
000351r 2               
000351r 2               ; perform NEW
000351r 2               
000351r 2               LAB_NEW
000351r 2  D0 FD              BNE   LAB_1460          ; exit if not end of statement (to do syntax error)
000353r 2               
000353r 2               LAB_1463
000353r 2  A9 00              LDA   #$00              ; clear A
000355r 2  A8                 TAY                     ; clear Y
000356r 2  91 79              STA   (Smeml),Y         ; clear first line, next line pointer, low byte
000358r 2  C8                 INY                     ; increment index
000359r 2  91 79              STA   (Smeml),Y         ; clear first line, next line pointer, high byte
00035Br 2  18                 CLC                     ; clear carry
00035Cr 2  A5 79              LDA   Smeml             ; get start of mem low byte
00035Er 2  69 02              ADC   #$02              ; calculate end of BASIC low byte
000360r 2  85 7B              STA   Svarl             ; save start of vars low byte
000362r 2  A5 7A              LDA   Smemh             ; get start of mem high byte
000364r 2  69 00              ADC   #$00              ; add any carry
000366r 2  85 7C              STA   Svarh             ; save start of vars high byte
000368r 2               
000368r 2               ; reset execution to start, clear vars and flush stack
000368r 2               
000368r 2               LAB_1477
000368r 2  18                 CLC                     ; clear carry
000369r 2  A5 79              LDA   Smeml             ; get start of mem low byte
00036Br 2  69 FF              ADC   #$FF              ; -1
00036Dr 2  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
00036Fr 2  A5 7A              LDA   Smemh             ; get start of mem high byte
000371r 2  69 FF              ADC   #$FF              ; -1+carry
000373r 2  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
000375r 2               
000375r 2               ; "CLEAR" command gets here
000375r 2               
000375r 2               LAB_147A
000375r 2  A5 85              LDA   Ememl             ; get end of mem low byte
000377r 2  A4 86              LDY   Ememh             ; get end of mem high byte
000379r 2  85 81              STA   Sstorl            ; set bottom of string space low byte
00037Br 2  84 82              STY   Sstorh            ; set bottom of string space high byte
00037Dr 2  A5 7B              LDA   Svarl             ; get start of vars low byte
00037Fr 2  A4 7C              LDY   Svarh             ; get start of vars high byte
000381r 2  85 7D              STA   Sarryl            ; save var mem end low byte
000383r 2  84 7E              STY   Sarryh            ; save var mem end high byte
000385r 2  85 7F              STA   Earryl            ; save array mem end low byte
000387r 2  84 80              STY   Earryh            ; save array mem end high byte
000389r 2  20 rr rr           JSR   LAB_161A          ; perform RESTORE command
00038Cr 2               
00038Cr 2               ; flush stack and clear continue flag
00038Cr 2               
00038Cr 2               LAB_1491
00038Cr 2  A2 68              LDX   #des_sk           ; set descriptor stack pointer
00038Er 2  86 65              STX   next_s            ; save descriptor stack pointer
000390r 2  68                 PLA                     ; pull return address low byte
000391r 2  AA                 TAX                     ; copy return address low byte
000392r 2  68                 PLA                     ; pull return address high byte
000393r 2  8E FE 01           STX   LAB_SKFE          ; save to cleared stack
000396r 2  8D FF 01           STA   LAB_SKFF          ; save to cleared stack
000399r 2  A2 FD              LDX   #$FD              ; new stack pointer
00039Br 2  9A                 TXS                     ; reset stack
00039Cr 2  A9 00              LDA   #$00              ; clear byte
00039Er 2               ;*** fix p2: no longer necessary as the continue pointer is saved anyway
00039Er 2               ;      STA   Cpntrh            ; clear continue pointer high byte
00039Er 2  85 61              STA   Sufnxf            ; clear subscript/FNX flag
0003A0r 2               LAB_14A6
0003A0r 2  60                 RTS
0003A1r 2               
0003A1r 2               ; perform CLEAR
0003A1r 2               
0003A1r 2               LAB_CLEAR
0003A1r 2  F0 D2              BEQ   LAB_147A          ; if no following token go do "CLEAR"
0003A3r 2               
0003A3r 2                                             ; else there was a following token (go do syntax error)
0003A3r 2  60                 RTS
0003A4r 2               
0003A4r 2               ; perform LIST [n][-m]
0003A4r 2               ; bigger, faster version (a _lot_ faster)
0003A4r 2               
0003A4r 2               LAB_LIST
0003A4r 2  90 06              BCC   LAB_14BD          ; branch if next character numeric (LIST n..)
0003A6r 2               
0003A6r 2  F0 04              BEQ   LAB_14BD          ; branch if next character [NULL] (LIST)
0003A8r 2               
0003A8r 2  C9 B7              CMP   #TK_MINUS         ; compare with token for -
0003AAr 2  D0 F4              BNE   LAB_14A6          ; exit if not - (LIST -m)
0003ACr 2               
0003ACr 2                                             ; LIST [[n][-m]]
0003ACr 2                                             ; this bit sets the n , if present, as the start and end
0003ACr 2               LAB_14BD
0003ACr 2  20 rr rr           JSR   LAB_GFPN          ; get fixed-point number into temp integer
0003AFr 2  20 rr rr           JSR   LAB_SSLN          ; search BASIC for temp integer line number
0003B2r 2                                             ; (pointer in Baslnl/Baslnh)
0003B2r 2  20 C2 00           JSR   LAB_GBYT          ; scan memory
0003B5r 2  F0 0C              BEQ   LAB_14D4          ; branch if no more characters
0003B7r 2               
0003B7r 2                                             ; this bit checks the - is present
0003B7r 2  C9 B7              CMP   #TK_MINUS         ; compare with token for -
0003B9r 2  D0 95              BNE   LAB_1460          ; return if not "-" (will be Syntax error)
0003BBr 2               
0003BBr 2                                             ; LIST [n]-m
0003BBr 2                                             ; the - was there so set m as the end value
0003BBr 2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
0003BEr 2  20 rr rr           JSR   LAB_GFPN          ; get fixed-point number into temp integer
0003C1r 2  D0 8D              BNE   LAB_1460          ; exit if not ok
0003C3r 2               
0003C3r 2               LAB_14D4
0003C3r 2  A5 11              LDA   Itempl            ; get temporary integer low byte
0003C5r 2  05 12              ORA   Itemph            ; OR temporary integer high byte
0003C7r 2  D0 06              BNE   LAB_14E2          ; branch if start set
0003C9r 2               
0003C9r 2  A9 FF              LDA   #$FF              ; set for -1
0003CBr 2  85 11              STA   Itempl            ; set temporary integer low byte
0003CDr 2  85 12              STA   Itemph            ; set temporary integer high byte
0003CFr 2               LAB_14E2
0003CFr 2  A0 01              LDY   #$01              ; set index for line
0003D1r 2  84 60              STY   Oquote            ; clear open quote flag
0003D3r 2  20 rr rr           JSR   LAB_CRLF          ; print CR/LF
0003D6r 2  B1 AA              LDA   (Baslnl),Y        ; get next line pointer high byte
0003D8r 2                                             ; pointer initially set by search at LAB_14BD
0003D8r 2  F0 3E              BEQ   LAB_152B          ; if null all done so exit
0003DAr 2  20 rr rr           JSR   LAB_1629          ; do CRTL-C check vector
0003DDr 2               
0003DDr 2  C8                 INY                     ; increment index for line
0003DEr 2  B1 AA              LDA   (Baslnl),Y        ; get line # low byte
0003E0r 2  AA                 TAX                     ; copy to X
0003E1r 2  C8                 INY                     ; increment index
0003E2r 2  B1 AA              LDA   (Baslnl),Y        ; get line # high byte
0003E4r 2  C5 12              CMP   Itemph            ; compare with temporary integer high byte
0003E6r 2  D0 04              BNE   LAB_14FF          ; branch if no high byte match
0003E8r 2               
0003E8r 2  E4 11              CPX   Itempl            ; compare with temporary integer low byte
0003EAr 2  F0 02              BEQ   LAB_1501          ; branch if = last line to do (< will pass next branch)
0003ECr 2               
0003ECr 2               LAB_14FF                      ; else ..
0003ECr 2  B0 2A              BCS   LAB_152B          ; if greater all done so exit
0003EEr 2               
0003EEr 2               LAB_1501
0003EEr 2  84 97              STY   Tidx1             ; save index for line
0003F0r 2  20 rr rr           JSR   LAB_295E          ; print XA as unsigned integer
0003F3r 2  A9 20              LDA   #$20              ; space is the next character
0003F5r 2               LAB_1508
0003F5r 2  A4 97              LDY   Tidx1             ; get index for line
0003F7r 2  29 7F              AND   #$7F              ; mask top out bit of character
0003F9r 2               LAB_150C
0003F9r 2  20 rr rr           JSR   LAB_PRNA          ; go print the character
0003FCr 2  C9 22              CMP   #$22              ; was it " character
0003FEr 2  D0 06              BNE   LAB_1519          ; branch if not
000400r 2               
000400r 2                                             ; we are either entering or leaving a pair of quotes
000400r 2  A5 60              LDA   Oquote            ; get open quote flag
000402r 2  49 FF              EOR   #$FF              ; toggle it
000404r 2  85 60              STA   Oquote            ; save it back
000406r 2               LAB_1519
000406r 2  C8                 INY                     ; increment index
000407r 2  B1 AA              LDA   (Baslnl),Y        ; get next byte
000409r 2  D0 0E              BNE   LAB_152E          ; branch if not [EOL] (go print character)
00040Br 2  A8                 TAY                     ; else clear index
00040Cr 2  B1 AA              LDA   (Baslnl),Y        ; get next line pointer low byte
00040Er 2  AA                 TAX                     ; copy to X
00040Fr 2  C8                 INY                     ; increment index
000410r 2  B1 AA              LDA   (Baslnl),Y        ; get next line pointer high byte
000412r 2  86 AA              STX   Baslnl            ; set pointer to line low byte
000414r 2  85 AB              STA   Baslnh            ; set pointer to line high byte
000416r 2  D0 B7              BNE   LAB_14E2          ; go do next line if not [EOT]
000418r 2                                             ; else ..
000418r 2               LAB_152B
000418r 2  60                 RTS
000419r 2               
000419r 2               LAB_152E
000419r 2  10 DE              BPL   LAB_150C          ; just go print it if not token byte
00041Br 2               
00041Br 2                                             ; else was token byte so uncrunch it (maybe)
00041Br 2  24 60              BIT   Oquote            ; test the open quote flag
00041Dr 2  30 DA              BMI   LAB_150C          ; just go print character if open quote set
00041Fr 2               
00041Fr 2  A2 rr              LDX   #>LAB_KEYT        ; get table address high byte
000421r 2  0A                 ASL                     ; *2
000422r 2  0A                 ASL                     ; *4
000423r 2  90 02              BCC   LAB_152F          ; branch if no carry
000425r 2               
000425r 2  E8                 INX                     ; else increment high byte
000426r 2  18                 CLC                     ; clear carry for add
000427r 2               LAB_152F
000427r 2  69 rr              ADC   #<LAB_KEYT        ; add low byte
000429r 2  90 01              BCC   LAB_1530          ; branch if no carry
00042Br 2               
00042Br 2  E8                 INX                     ; else increment high byte
00042Cr 2               LAB_1530
00042Cr 2  85 73              STA   ut2_pl            ; save table pointer low byte
00042Er 2  86 74              STX   ut2_ph            ; save table pointer high byte
000430r 2  84 97              STY   Tidx1             ; save index for line
000432r 2  A0 00              LDY   #$00              ; clear index
000434r 2  B1 73              LDA   (ut2_pl),Y        ; get length
000436r 2  AA                 TAX                     ; copy length
000437r 2  C8                 INY                     ; increment index
000438r 2  B1 73              LDA   (ut2_pl),Y        ; get 1st character
00043Ar 2  CA                 DEX                     ; decrement length
00043Br 2  F0 B8              BEQ   LAB_1508          ; if no more characters exit and print
00043Dr 2               
00043Dr 2  20 rr rr           JSR   LAB_PRNA          ; go print the character
000440r 2  C8                 INY                     ; increment index
000441r 2  B1 73              LDA   (ut2_pl),Y        ; get keyword address low byte
000443r 2  48                 PHA                     ; save it for now
000444r 2  C8                 INY                     ; increment index
000445r 2  B1 73              LDA   (ut2_pl),Y        ; get keyword address high byte
000447r 2  A0 00              LDY   #$00
000449r 2  85 74              STA   ut2_ph            ; save keyword pointer high byte
00044Br 2  68                 PLA                     ; pull low byte
00044Cr 2  85 73              STA   ut2_pl            ; save keyword pointer low byte
00044Er 2               LAB_1540
00044Er 2  B1 73              LDA   (ut2_pl),Y        ; get character
000450r 2  CA                 DEX                     ; decrement character count
000451r 2  F0 A2              BEQ   LAB_1508          ; if last character exit and print
000453r 2               
000453r 2  20 rr rr           JSR   LAB_PRNA          ; go print the character
000456r 2  C8                 INY                     ; increment index
000457r 2  D0 F5              BNE   LAB_1540          ; loop for next character
000459r 2               
000459r 2               ; perform FOR
000459r 2               
000459r 2               LAB_FOR
000459r 2  A9 80              LDA   #$80              ; set FNX
00045Br 2  85 61              STA   Sufnxf            ; set subscript/FNX flag
00045Dr 2  20 rr rr           JSR   LAB_LET           ; go do LET
000460r 2  68                 PLA                     ; pull return address
000461r 2  68                 PLA                     ; pull return address
000462r 2  A9 10              LDA   #$10              ; we need 16d bytes !
000464r 2  20 rr rr           JSR   LAB_1212          ; check room on stack for A bytes
000467r 2  20 rr rr           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
00046Ar 2  18                 CLC                     ; clear carry for add
00046Br 2  98                 TYA                     ; copy index to A
00046Cr 2  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
00046Er 2  48                 PHA                     ; push onto stack
00046Fr 2  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
000471r 2  69 00              ADC   #$00              ; add carry
000473r 2  48                 PHA                     ; push onto stack
000474r 2  A5 88              LDA   Clineh            ; get current line high byte
000476r 2  48                 PHA                     ; push onto stack
000477r 2  A5 87              LDA   Clinel            ; get current line low byte
000479r 2  48                 PHA                     ; push onto stack
00047Ar 2  A9 AD              LDA   #TK_TO            ; get "TO" token
00047Cr 2  20 rr rr           JSR   LAB_SCCA          ; scan for CHR$(A) , else do syntax error then warm start
00047Fr 2  20 rr rr           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
000482r 2  20 rr rr           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
000485r 2                                             ; else do type mismatch
000485r 2               ; *** begin patch  2.22p5.1   TO expression may get sign bit flipped
000485r 2               ; *** add
000485r 2  20 rr rr           JSR   LAB_27BA          ; round FAC1
000488r 2               ; *** end   patch  2.22p5.1   TO expression may get sign bit flipped
000488r 2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
00048Ar 2  09 7F              ORA   #$7F              ; set all non sign bits
00048Cr 2  25 AD              AND   FAC1_1            ; and FAC1 mantissa1
00048Er 2  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
000490r 2  A9 rr              LDA   #<LAB_159F        ; set return address low byte
000492r 2  A0 rr              LDY   #>LAB_159F        ; set return address high byte
000494r 2  85 71              STA   ut1_pl            ; save return address low byte
000496r 2  84 72              STY   ut1_ph            ; save return address high byte
000498r 2  4C rr rr           JMP   LAB_1B66          ; round FAC1 and put on stack (returns to next instruction)
00049Br 2               
00049Br 2               LAB_159F
00049Br 2  A9 rr              LDA   #<LAB_259C        ; set 1 pointer low addr (default step size)
00049Dr 2  A0 rr              LDY   #>LAB_259C        ; set 1 pointer high addr
00049Fr 2  20 rr rr           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
0004A2r 2  20 C2 00           JSR   LAB_GBYT          ; scan memory
0004A5r 2  C9 B2              CMP   #TK_STEP          ; compare with STEP token
0004A7r 2  D0 06              BNE   LAB_15B3          ; jump if not "STEP"
0004A9r 2               
0004A9r 2                                             ;.was step so ..
0004A9r 2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
0004ACr 2  20 rr rr           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
0004AFr 2                                             ; else do type mismatch
0004AFr 2               LAB_15B3
0004AFr 2  20 rr rr           JSR   LAB_27CA          ; return A=FF,C=1/-ve A=01,C=0/+ve
0004B2r 2  85 B0              STA   FAC1_s            ; set FAC1 sign (b7)
0004B4r 2                                             ; this is +1 for +ve step and -1 for -ve step, in NEXT we
0004B4r 2                                             ; compare the FOR value and the TO value and return +1 if
0004B4r 2                                             ; FOR > TO, 0 if FOR = TO and -1 if FOR < TO. the value
0004B4r 2                                             ; here (+/-1) is then compared to that result and if they
0004B4r 2                                             ; are the same (+ve and FOR > TO or -ve and FOR < TO) then
0004B4r 2                                             ; the loop is done
0004B4r 2               
0004B4r 2               ; *** begin patch  2.22p5.3   potential return address -$100 (page not incremented) ***
0004B4r 2               ; *** add
0004B4r 2               ; note MB: Unable to port to ca65 assembly
0004B4r 2               ;   .IF [* & $FF] == $FD
0004B4r 2               ;      NOP                     ; return address of JSR +1 (on  next page)
0004B4r 2               ;   .ENDIF
0004B4r 2               ; *** end   patch  2.22p5.3   potential return address -$100 (page not incremented) ***
0004B4r 2  20 rr rr           JSR   LAB_1B5B          ; push sign, round FAC1 and put on stack
0004B7r 2  A5 98              LDA   Frnxth            ; get var pointer for FOR/NEXT high byte
0004B9r 2  48                 PHA                     ; push on stack
0004BAr 2  A5 97              LDA   Frnxtl            ; get var pointer for FOR/NEXT low byte
0004BCr 2  48                 PHA                     ; push on stack
0004BDr 2  A9 81              LDA   #TK_FOR           ; get FOR token
0004BFr 2  48                 PHA                     ; push on stack
0004C0r 2               
0004C0r 2               ; interpreter inner loop
0004C0r 2               
0004C0r 2               LAB_15C2
0004C0r 2  20 rr rr           JSR   LAB_1629          ; do CRTL-C check vector
0004C3r 2  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
0004C5r 2  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte
0004C7r 2               
0004C7r 2  A6 88              LDX   Clineh            ; continue line is $FFxx for immediate mode
0004C9r 2                                             ; ($00xx for RUN from immediate mode)
0004C9r 2  E8                 INX                     ; increment it (now $00 if immediate mode)
0004CAr 2               ;*** fix p2: skip no longer necessary as the continue pointer is saved anyway
0004CAr 2               ;      BEQ   LAB_15D1          ; branch if null (immediate mode)
0004CAr 2               
0004CAr 2  85 8B              STA   Cpntrl            ; save continue pointer low byte
0004CCr 2  84 8C              STY   Cpntrh            ; save continue pointer high byte
0004CEr 2               LAB_15D1
0004CEr 2  A0 00              LDY   #$00              ; clear index
0004D0r 2  B1 C3              LDA   (Bpntrl),Y        ; get next byte
0004D2r 2  F0 07              BEQ   LAB_15DC          ; branch if null [EOL]
0004D4r 2               
0004D4r 2  C9 3A              CMP   #':'              ; compare with ":"
0004D6r 2  F0 1D              BEQ   LAB_15F6          ; branch if = (statement separator)
0004D8r 2               
0004D8r 2               LAB_15D9
0004D8r 2  4C rr rr           JMP   LAB_SNER          ; else syntax error then warm start
0004DBr 2               
0004DBr 2                                             ; have reached [EOL]
0004DBr 2               LAB_15DC
0004DBr 2  A0 02              LDY   #$02              ; set index
0004DDr 2  B1 C3              LDA   (Bpntrl),Y        ; get next line pointer high byte
0004DFr 2  18                 CLC                     ; clear carry for no "BREAK" message
0004E0r 2  F0 50              BEQ   LAB_1651          ; if null go to immediate mode (was immediate or [EOT]
0004E2r 2                                             ; marker)
0004E2r 2               
0004E2r 2  C8                 INY                     ; increment index
0004E3r 2  B1 C3              LDA   (Bpntrl),Y        ; get line # low byte
0004E5r 2  85 87              STA   Clinel            ; save current line low byte
0004E7r 2  C8                 INY                     ; increment index
0004E8r 2  B1 C3              LDA   (Bpntrl),Y        ; get line # high byte
0004EAr 2  85 88              STA   Clineh            ; save current line high byte
0004ECr 2  98                 TYA                     ; A now = 4
0004EDr 2  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
0004EFr 2  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
0004F1r 2  90 02              BCC   LAB_15F6          ; branch if no overflow
0004F3r 2               
0004F3r 2  E6 C4              INC   Bpntrh            ; else increment BASIC execute pointer high byte
0004F5r 2               LAB_15F6
0004F5r 2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
0004F8r 2               
0004F8r 2               LAB_15F9
0004F8r 2  20 rr rr           JSR   LAB_15FF          ; go interpret BASIC code from (Bpntrl)
0004FBr 2               
0004FBr 2               LAB_15FC
0004FBr 2  4C rr rr           JMP   LAB_15C2          ; loop
0004FEr 2               
0004FEr 2               ; interpret BASIC code from (Bpntrl)
0004FEr 2               
0004FEr 2               LAB_15FF
0004FEr 2  F0 4E              BEQ   LAB_1628          ; exit if zero [EOL]
000500r 2               
000500r 2               LAB_1602
000500r 2  0A                 ASL                     ; *2 bytes per vector and normalise token
000501r 2  B0 03              BCS   LAB_1609          ; branch if was token
000503r 2               
000503r 2  4C rr rr           JMP   LAB_LET           ; else go do implied LET
000506r 2               
000506r 2               LAB_1609
000506r 2  C9 56              CMP   #(TK_TAB-$80)*2   ; compare normalised token * 2 with TAB
000508r 2  B0 CE              BCS   LAB_15D9          ; branch if A>=TAB (do syntax error then warm start)
00050Ar 2                                             ; only tokens before TAB can start a line
00050Ar 2  A8                 TAY                     ; copy to index
00050Br 2  B9 rr rr           LDA   LAB_CTBL+1,Y      ; get vector high byte
00050Er 2  48                 PHA                     ; onto stack
00050Fr 2  B9 rr rr           LDA   LAB_CTBL,Y        ; get vector low byte
000512r 2  48                 PHA                     ; onto stack
000513r 2  4C BC 00           JMP   LAB_IGBY          ; jump to increment and scan memory
000516r 2                                             ; then "return" to vector
000516r 2               
000516r 2               ; CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
000516r 2               ; key press is detected.
000516r 2               
000516r 2               LAB_1629
000516r 2  6C 03 02           JMP   (VEC_CC)          ; ctrl c check vector
000519r 2               
000519r 2               ; if there was a key press it gets back here ..
000519r 2               
000519r 2               LAB_1636
000519r 2  C9 03              CMP   #$03              ; compare with CTRL-C
00051Br 2               
00051Br 2               ; perform STOP
00051Br 2               
00051Br 2               LAB_STOP
00051Br 2  B0 01              BCS   LAB_163B          ; branch if token follows STOP
00051Dr 2                                             ; else just END
00051Dr 2               ; END
00051Dr 2               
00051Dr 2               LAB_END
00051Dr 2  18                 CLC                     ; clear the carry, indicate a normal program end
00051Er 2               LAB_163B
00051Er 2  D0 61              BNE   LAB_167A          ; if wasn't CTRL-C or there is a following byte return
000520r 2               
000520r 2  A5 C4              LDA   Bpntrh            ; get the BASIC execute pointer high byte
000522r 2               ;*** fix p2: skip no longer necessary as the continue pointer is saved anyway
000522r 2               ;      EOR   #>Ibuffs          ; compare with buffer address high byte (Cb unchanged)
000522r 2               ;      BEQ   LAB_164F          ; branch if the BASIC pointer is in the input buffer
000522r 2               ;                              ; (can't continue in immediate mode)
000522r 2               ;                              ; else ..
000522r 2               ;      EOR   #>Ibuffs          ; correct the bits
000522r 2  A4 C3              LDY   Bpntrl            ; get BASIC execute pointer low byte
000524r 2  84 8B              STY   Cpntrl            ; save continue pointer low byte
000526r 2  85 8C              STA   Cpntrh            ; save continue pointer high byte
000528r 2               LAB_1647
000528r 2  A5 87              LDA   Clinel            ; get current line low byte
00052Ar 2  A4 88              LDY   Clineh            ; get current line high byte
00052Cr 2  85 89              STA   Blinel            ; save break line low byte
00052Er 2  84 8A              STY   Blineh            ; save break line high byte
000530r 2               LAB_164F
000530r 2  68                 PLA                     ; pull return address low
000531r 2  68                 PLA                     ; pull return address high
000532r 2               LAB_1651
000532r 2  90 07              BCC   LAB_165E          ; if was program end just do warm start
000534r 2               
000534r 2                                             ; else ..
000534r 2  A9 rr              LDA   #<LAB_BMSG        ; point to "Break" low byte
000536r 2  A0 rr              LDY   #>LAB_BMSG        ; point to "Break" high byte
000538r 2  4C rr rr           JMP   LAB_1269          ; print "Break" and do warm start
00053Br 2               
00053Br 2               LAB_165E
00053Br 2  4C rr rr           JMP   LAB_1274          ; go do warm start
00053Er 2               
00053Er 2               ; perform RESTORE
00053Er 2               
00053Er 2               LAB_RESTORE
00053Er 2  D0 0F              BNE   LAB_RESTOREn      ; branch if next character not null (RESTORE n)
000540r 2               
000540r 2               LAB_161A
000540r 2  38                 SEC                     ; set carry for subtract
000541r 2  A5 79              LDA   Smeml             ; get start of mem low byte
000543r 2  E9 01              SBC   #$01              ; -1
000545r 2  A4 7A              LDY   Smemh             ; get start of mem high byte
000547r 2  B0 01              BCS   LAB_1624          ; branch if no underflow
000549r 2               
000549r 2               LAB_uflow
000549r 2  88                 DEY                     ; else decrement high byte
00054Ar 2               LAB_1624
00054Ar 2  85 8F              STA   Dptrl             ; save DATA pointer low byte
00054Cr 2  84 90              STY   Dptrh             ; save DATA pointer high byte
00054Er 2               LAB_1628
00054Er 2  60                 RTS
00054Fr 2               
00054Fr 2                                             ; is RESTORE n
00054Fr 2               LAB_RESTOREn
00054Fr 2  20 rr rr           JSR   LAB_GFPN          ; get fixed-point number into temp integer
000552r 2  20 rr rr           JSR   LAB_SNBL          ; scan for next BASIC line
000555r 2  A5 88              LDA   Clineh            ; get current line high byte
000557r 2  C5 12              CMP   Itemph            ; compare with temporary integer high byte
000559r 2  B0 0B              BCS   LAB_reset_search  ; branch if >= (start search from beginning)
00055Br 2               
00055Br 2  98                 TYA                     ; else copy line index to A
00055Cr 2  38                 SEC                     ; set carry (+1)
00055Dr 2  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
00055Fr 2  A6 C4              LDX   Bpntrh            ; get BASIC execute pointer high byte
000561r 2  90 07              BCC   LAB_go_search     ; branch if no overflow to high byte
000563r 2               
000563r 2  E8                 INX                     ; increment high byte
000564r 2  B0 04              BCS   LAB_go_search     ; branch always (can never be carry clear)
000566r 2               
000566r 2               ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
000566r 2               
000566r 2               LAB_reset_search
000566r 2  A5 79              LDA   Smeml             ; get start of mem low byte
000568r 2  A6 7A              LDX   Smemh             ; get start of mem high byte
00056Ar 2               
00056Ar 2               ; search for line # in temp (Itempl/Itemph) from (AX)
00056Ar 2               
00056Ar 2               LAB_go_search
00056Ar 2               
00056Ar 2  20 rr rr           JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
00056Dr 2  B0 03              BCS   LAB_line_found    ; if carry set go set pointer
00056Fr 2               
00056Fr 2  4C rr rr           JMP   LAB_16F7          ; else go do "Undefined statement" error
000572r 2               
000572r 2               LAB_line_found
000572r 2                                             ; carry already set for subtract
000572r 2  A5 AA              LDA   Baslnl            ; get pointer low byte
000574r 2  E9 01              SBC   #$01              ; -1
000576r 2  A4 AB              LDY   Baslnh            ; get pointer high byte
000578r 2  B0 D0              BCS   LAB_1624          ; branch if no underflow (save DATA pointer and return)
00057Ar 2               
00057Ar 2  90 CD              BCC   LAB_uflow         ; else decrement high byte then save DATA pointer and
00057Cr 2                                             ; return (branch always)
00057Cr 2               
00057Cr 2               ; perform NULL
00057Cr 2               
00057Cr 2               LAB_NULL
00057Cr 2  20 rr rr           JSR   LAB_GTBY          ; get byte parameter
00057Fr 2  86 0D              STX   Nullct            ; save new NULL count
000581r 2               LAB_167A
000581r 2  60                 RTS
000582r 2               
000582r 2               ; perform CONT
000582r 2               
000582r 2               LAB_CONT
000582r 2  D0 FD              BNE   LAB_167A          ; if following byte exit to do syntax error
000584r 2               
000584r 2  A4 8C              LDY   Cpntrh            ; get continue pointer high byte
000586r 2  C0 02              CPY   #>Ibuffs          ; *** fix p2: test direct mode
000588r 2  D0 05              BNE   LAB_166C          ; go do continue if we can
00058Ar 2               
00058Ar 2  A2 1E              LDX   #$1E              ; error code $1E ("Can't continue" error)
00058Cr 2  4C rr rr           JMP   LAB_XERR          ; do error #X, then warm start
00058Fr 2               
00058Fr 2                                             ; we can continue so ..
00058Fr 2               LAB_166C
00058Fr 2  A9 93              LDA   #TK_ON            ; set token for ON
000591r 2  20 rr rr           JSR   LAB_IRQ           ; set IRQ flags
000594r 2  A9 93              LDA   #TK_ON            ; set token for ON
000596r 2  20 rr rr           JSR   LAB_NMI           ; set NMI flags
000599r 2               
000599r 2  84 C4              STY   Bpntrh            ; save BASIC execute pointer high byte
00059Br 2  A5 8B              LDA   Cpntrl            ; get continue pointer low byte
00059Dr 2  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
00059Fr 2  A5 89              LDA   Blinel            ; get break line low byte
0005A1r 2  A4 8A              LDY   Blineh            ; get break line high byte
0005A3r 2  85 87              STA   Clinel            ; set current line low byte
0005A5r 2  84 88              STY   Clineh            ; set current line high byte
0005A7r 2  60                 RTS
0005A8r 2               
0005A8r 2               ; perform RUN
0005A8r 2               
0005A8r 2               LAB_RUN
0005A8r 2  D0 03              BNE   LAB_1696          ; branch if RUN n
0005AAr 2  4C rr rr           JMP   LAB_1477          ; reset execution to start, clear variables, flush stack and
0005ADr 2                                             ; return
0005ADr 2               
0005ADr 2               ; does RUN n
0005ADr 2               
0005ADr 2               LAB_1696
0005ADr 2  20 rr rr           JSR   LAB_147A          ; go do "CLEAR"
0005B0r 2  F0 2E              BEQ   LAB_16B0          ; get n and do GOTO n (branch always as CLEAR sets Z=1)
0005B2r 2               
0005B2r 2               ; perform DO
0005B2r 2               
0005B2r 2               LAB_DO
0005B2r 2  A9 05              LDA   #$05              ; need 5 bytes for DO
0005B4r 2  20 rr rr           JSR   LAB_1212          ; check room on stack for A bytes
0005B7r 2  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
0005B9r 2  48                 PHA                     ; push on stack
0005BAr 2  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
0005BCr 2  48                 PHA                     ; push on stack
0005BDr 2  A5 88              LDA   Clineh            ; get current line high byte
0005BFr 2  48                 PHA                     ; push on stack
0005C0r 2  A5 87              LDA   Clinel            ; get current line low byte
0005C2r 2  48                 PHA                     ; push on stack
0005C3r 2  A9 9D              LDA   #TK_DO            ; token for DO
0005C5r 2  48                 PHA                     ; push on stack
0005C6r 2  20 C2 00           JSR   LAB_GBYT          ; scan memory
0005C9r 2  4C rr rr           JMP   LAB_15C2          ; go do interpreter inner loop
0005CCr 2               
0005CCr 2               ; perform GOSUB
0005CCr 2               
0005CCr 2               LAB_GOSUB
0005CCr 2  A9 05              LDA   #$05              ; need 5 bytes for GOSUB
0005CEr 2  20 rr rr           JSR   LAB_1212          ; check room on stack for A bytes
0005D1r 2  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
0005D3r 2  48                 PHA                     ; push on stack
0005D4r 2  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
0005D6r 2  48                 PHA                     ; push on stack
0005D7r 2  A5 88              LDA   Clineh            ; get current line high byte
0005D9r 2  48                 PHA                     ; push on stack
0005DAr 2  A5 87              LDA   Clinel            ; get current line low byte
0005DCr 2  48                 PHA                     ; push on stack
0005DDr 2  A9 8D              LDA   #TK_GOSUB         ; token for GOSUB
0005DFr 2  48                 PHA                     ; push on stack
0005E0r 2               LAB_16B0
0005E0r 2  20 C2 00           JSR   LAB_GBYT          ; scan memory
0005E3r 2  20 rr rr           JSR   LAB_GOTO          ; perform GOTO n
0005E6r 2  4C rr rr           JMP   LAB_15C2          ; go do interpreter inner loop
0005E9r 2                                             ; (can't RTS, we used the stack!)
0005E9r 2               
0005E9r 2               ; perform GOTO
0005E9r 2               
0005E9r 2               LAB_GOTO
0005E9r 2  20 rr rr           JSR   LAB_GFPN          ; get fixed-point number into temp integer
0005ECr 2  20 rr rr           JSR   LAB_SNBL          ; scan for next BASIC line
0005EFr 2  A5 88              LDA   Clineh            ; get current line high byte
0005F1r 2  C5 12              CMP   Itemph            ; compare with temporary integer high byte
0005F3r 2  B0 0B              BCS   LAB_16D0          ; branch if >= (start search from beginning)
0005F5r 2               
0005F5r 2  98                 TYA                     ; else copy line index to A
0005F6r 2  38                 SEC                     ; set carry (+1)
0005F7r 2  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
0005F9r 2  A6 C4              LDX   Bpntrh            ; get BASIC execute pointer high byte
0005FBr 2  90 07              BCC   LAB_16D4          ; branch if no overflow to high byte
0005FDr 2               
0005FDr 2  E8                 INX                     ; increment high byte
0005FEr 2  B0 04              BCS   LAB_16D4          ; branch always (can never be carry)
000600r 2               
000600r 2               ; search for line # in temp (Itempl/Itemph) from start of mem pointer (Smeml)
000600r 2               
000600r 2               LAB_16D0
000600r 2  A5 79              LDA   Smeml             ; get start of mem low byte
000602r 2  A6 7A              LDX   Smemh             ; get start of mem high byte
000604r 2               
000604r 2               ; search for line # in temp (Itempl/Itemph) from (AX)
000604r 2               
000604r 2               LAB_16D4
000604r 2  20 rr rr           JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
000607r 2  90 67              BCC   LAB_16F7          ; if carry clear go do "Undefined statement" error
000609r 2                                             ; (unspecified statement)
000609r 2               
000609r 2                                             ; carry already set for subtract
000609r 2  A5 AA              LDA   Baslnl            ; get pointer low byte
00060Br 2  E9 01              SBC   #$01              ; -1
00060Dr 2  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
00060Fr 2  A5 AB              LDA   Baslnh            ; get pointer high byte
000611r 2  E9 00              SBC   #$00              ; subtract carry
000613r 2  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
000615r 2               LAB_16E5
000615r 2  60                 RTS
000616r 2               
000616r 2               LAB_DONOK
000616r 2  A2 22              LDX   #$22              ; error code $22 ("LOOP without DO" error)
000618r 2  4C rr rr           JMP   LAB_XERR          ; do error #X, then warm start
00061Br 2               
00061Br 2               ; perform LOOP
00061Br 2               
00061Br 2               LAB_LOOP
00061Br 2  A8                 TAY                     ; save following token
00061Cr 2  BA                 TSX                     ; copy stack pointer
00061Dr 2  BD 03 01           LDA   LAB_STAK+3,X      ; get token byte from stack
000620r 2  C9 9D              CMP   #TK_DO            ; compare with DO token
000622r 2  D0 F2              BNE   LAB_DONOK         ; branch if no matching DO
000624r 2               
000624r 2  E8                 INX                     ; dump calling routine return address
000625r 2  E8                 INX                     ; dump calling routine return address
000626r 2  9A                 TXS                     ; correct stack
000627r 2  98                 TYA                     ; get saved following token back
000628r 2  F0 20              BEQ   LoopAlways        ; if no following token loop forever
00062Ar 2                                             ; (stack pointer in X)
00062Ar 2               
00062Ar 2  C9 3A              CMP   #':'              ; could be ':'
00062Cr 2  F0 1C              BEQ   LoopAlways        ; if :... loop forever
00062Er 2               
00062Er 2  E9 B3              SBC   #TK_UNTIL         ; subtract token for UNTIL, we know carry is set here
000630r 2  AA                 TAX                     ; copy to X (if it was UNTIL then Y will be correct)
000631r 2  F0 04              BEQ   DoRest            ; branch if was UNTIL
000633r 2               
000633r 2  CA                 DEX                     ; decrement result
000634r 2  D0 62              BNE   LAB_16FC          ; if not WHILE go do syntax error and warm start
000636r 2                                             ; only if the token was WHILE will this fail
000636r 2               
000636r 2  CA                 DEX                     ; set invert result byte
000637r 2               DoRest
000637r 2  86 98              STX   Frnxth            ; save invert result byte
000639r 2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00063Cr 2  20 rr rr           JSR   LAB_EVEX          ; evaluate expression
00063Fr 2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
000641r 2  F0 02              BEQ   DoCmp             ; if =0 go do straight compare
000643r 2               
000643r 2  A9 FF              LDA   #$FF              ; else set all bits
000645r 2               DoCmp
000645r 2  BA                 TSX                     ; copy stack pointer
000646r 2  45 98              EOR   Frnxth            ; EOR with invert byte
000648r 2  D0 1A              BNE   LoopDone          ; if <> 0 clear stack and back to interpreter loop
00064Ar 2               
00064Ar 2                                             ; loop condition wasn't met so do it again
00064Ar 2               LoopAlways
00064Ar 2  BD 02 01           LDA   LAB_STAK+2,X      ; get current line low byte
00064Dr 2  85 87              STA   Clinel            ; save current line low byte
00064Fr 2  BD 03 01           LDA   LAB_STAK+3,X      ; get current line high byte
000652r 2  85 88              STA   Clineh            ; save current line high byte
000654r 2  BD 04 01           LDA   LAB_STAK+4,X      ; get BASIC execute pointer low byte
000657r 2  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
000659r 2  BD 05 01           LDA   LAB_STAK+5,X      ; get BASIC execute pointer high byte
00065Cr 2  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
00065Er 2  20 C2 00           JSR   LAB_GBYT          ; scan memory
000661r 2  4C rr rr           JMP   LAB_15C2          ; go do interpreter inner loop
000664r 2               
000664r 2                                             ; clear stack and back to interpreter loop
000664r 2               LoopDone
000664r 2  E8                 INX                     ; dump DO token
000665r 2  E8                 INX                     ; dump current line low byte
000666r 2  E8                 INX                     ; dump current line high byte
000667r 2  E8                 INX                     ; dump BASIC execute pointer low byte
000668r 2  E8                 INX                     ; dump BASIC execute pointer high byte
000669r 2  9A                 TXS                     ; correct stack
00066Ar 2  4C rr rr           JMP   LAB_DATA          ; go perform DATA (find : or [EOL])
00066Dr 2               
00066Dr 2               ; do the return without gosub error
00066Dr 2               
00066Dr 2               LAB_16F4
00066Dr 2  A2 04              LDX   #$04              ; error code $04 ("RETURN without GOSUB" error)
00066Fr 2  2C                 .byte $2C               ; makes next line BIT LAB_0EA2
000670r 2               
000670r 2               LAB_16F7                      ; do undefined statement error
000670r 2  A2 0E              LDX   #$0E              ; error code $0E ("Undefined statement" error)
000672r 2  4C rr rr           JMP   LAB_XERR          ; do error #X, then warm start
000675r 2               
000675r 2               ; perform RETURN
000675r 2               
000675r 2               LAB_RETURN
000675r 2  D0 9E              BNE   LAB_16E5          ; exit if following token (to allow syntax error)
000677r 2               
000677r 2               LAB_16E8
000677r 2  68                 PLA                     ; dump calling routine return address
000678r 2  68                 PLA                     ; dump calling routine return address
000679r 2  68                 PLA                     ; pull token
00067Ar 2  C9 8D              CMP   #TK_GOSUB         ; compare with GOSUB token
00067Cr 2  D0 EF              BNE   LAB_16F4          ; branch if no matching GOSUB
00067Er 2               
00067Er 2               LAB_16FF
00067Er 2  68                 PLA                     ; pull current line low byte
00067Fr 2  85 87              STA   Clinel            ; save current line low byte
000681r 2  68                 PLA                     ; pull current line high byte
000682r 2  85 88              STA   Clineh            ; save current line high byte
000684r 2  68                 PLA                     ; pull BASIC execute pointer low byte
000685r 2  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
000687r 2  68                 PLA                     ; pull BASIC execute pointer high byte
000688r 2  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
00068Ar 2               
00068Ar 2                                             ; now do the DATA statement as we could be returning into
00068Ar 2                                             ; the middle of an ON <var> GOSUB n,m,p,q line
00068Ar 2                                             ; (the return address used by the DATA statement is the one
00068Ar 2                                             ; pushed before the GOSUB was executed!)
00068Ar 2               
00068Ar 2               ; perform DATA
00068Ar 2               
00068Ar 2               LAB_DATA
00068Ar 2  20 rr rr           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
00068Dr 2               
00068Dr 2                                             ; set BASIC execute pointer
00068Dr 2               LAB_170F
00068Dr 2  98                 TYA                     ; copy index to A
00068Er 2  18                 CLC                     ; clear carry for add
00068Fr 2  65 C3              ADC   Bpntrl            ; add BASIC execute pointer low byte
000691r 2  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
000693r 2  90 02              BCC   LAB_1719          ; skip next if no carry
000695r 2               
000695r 2  E6 C4              INC   Bpntrh            ; else increment BASIC execute pointer high byte
000697r 2               LAB_1719
000697r 2  60                 RTS
000698r 2               
000698r 2               LAB_16FC
000698r 2  4C rr rr           JMP   LAB_SNER          ; do syntax error then warm start
00069Br 2               
00069Br 2               ; scan for next BASIC statement ([:] or [EOL])
00069Br 2               ; returns Y as index to [:] or [EOL]
00069Br 2               
00069Br 2               LAB_SNBS
00069Br 2  A2 3A              LDX   #':'              ; set look for character = ":"
00069Dr 2  2C                 .byte $2C               ; makes next line BIT $00A2
00069Er 2               
00069Er 2               ; scan for next BASIC line
00069Er 2               ; returns Y as index to [EOL]
00069Er 2               
00069Er 2               LAB_SNBL
00069Er 2  A2 00              LDX   #$00              ; set alt search character = [EOL]
0006A0r 2  A0 00              LDY   #$00              ; set search character = [EOL]
0006A2r 2  84 5C              STY   Asrch             ; store search character
0006A4r 2               LAB_1725
0006A4r 2  8A                 TXA                     ; get alt search character
0006A5r 2  45 5C              EOR   Asrch             ; toggle search character, effectively swap with $00
0006A7r 2  85 5C              STA   Asrch             ; save swapped search character
0006A9r 2               LAB_172D
0006A9r 2  B1 C3              LDA   (Bpntrl),Y        ; get next byte
0006ABr 2  F0 EA              BEQ   LAB_1719          ; exit if null [EOL]
0006ADr 2               
0006ADr 2  C5 5C              CMP   Asrch             ; compare with search character
0006AFr 2  F0 E6              BEQ   LAB_1719          ; exit if found
0006B1r 2               
0006B1r 2  C8                 INY                     ; increment index
0006B2r 2  C9 22              CMP   #$22              ; compare current character with open quote
0006B4r 2  D0 F3              BNE   LAB_172D          ; if not open quote go get next character
0006B6r 2               
0006B6r 2  F0 EC              BEQ   LAB_1725          ; if found go swap search character for alt search character
0006B8r 2               
0006B8r 2               ; perform IF
0006B8r 2               
0006B8r 2               LAB_IF
0006B8r 2  20 rr rr           JSR   LAB_EVEX          ; evaluate the expression
0006BBr 2  20 C2 00           JSR   LAB_GBYT          ; scan memory
0006BEr 2  C9 B0              CMP   #TK_THEN          ; compare with THEN token
0006C0r 2  F0 11              BEQ   LAB_174B          ; if it was THEN go do IF
0006C2r 2               
0006C2r 2                                             ; wasn't IF .. THEN so must be IF .. GOTO
0006C2r 2  C9 89              CMP   #TK_GOTO          ; compare with GOTO token
0006C4r 2  D0 D2              BNE   LAB_16FC          ; if it wasn't GOTO go do syntax error
0006C6r 2               
0006C6r 2  A6 C3              LDX   Bpntrl            ; save the basic pointer low byte
0006C8r 2  A4 C4              LDY   Bpntrh            ; save the basic pointer high byte
0006CAr 2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
0006CDr 2  B0 C9              BCS   LAB_16FC          ; if not numeric go do syntax error
0006CFr 2               
0006CFr 2  86 C3              STX   Bpntrl            ; restore the basic pointer low byte
0006D1r 2  84 C4              STY   Bpntrh            ; restore the basic pointer high byte
0006D3r 2               LAB_174B
0006D3r 2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
0006D5r 2  F0 1E              BEQ   LAB_174E          ; if the result was zero go look for an ELSE
0006D7r 2               
0006D7r 2  20 BC 00           JSR   LAB_IGBY          ; else increment and scan memory
0006DAr 2  B0 03              BCS   LAB_174D          ; if not numeric go do var or keyword
0006DCr 2               
0006DCr 2               LAB_174C
0006DCr 2  4C rr rr           JMP   LAB_GOTO          ; else was numeric so do GOTO n
0006DFr 2               
0006DFr 2                                             ; is var or keyword
0006DFr 2               LAB_174D
0006DFr 2               ; *** patch       allow NEXT, LOOP & RETURN to find FOR, DO or GOSUB structure on stack
0006DFr 2               ; *** replace
0006DFr 2               ;      CMP   #TK_RETURN        ; compare the byte with the token for RETURN
0006DFr 2               ;      BNE   LAB_174G          ; if it wasn't RETURN go interpret BASIC code from (Bpntrl)
0006DFr 2               ;                              ; and return to this code to process any following code
0006DFr 2               ;
0006DFr 2               ;      JMP   LAB_1602          ; else it was RETURN so interpret BASIC code from (Bpntrl)
0006DFr 2               ;                              ; but don't return here
0006DFr 2               ;
0006DFr 2               ;LAB_174G
0006DFr 2               ;      JSR   LAB_15FF          ; interpret BASIC code from (Bpntrl)
0006DFr 2               ;
0006DFr 2               ;; the IF was executed and there may be a following ELSE so the code needs to return
0006DFr 2               ;; here to check and ignore the ELSE if present
0006DFr 2               ;
0006DFr 2               ;      LDY   #$00              ; clear the index
0006DFr 2               ;      LDA   (Bpntrl),Y        ; get the next BASIC byte
0006DFr 2               ;      CMP   #TK_ELSE          ; compare it with the token for ELSE
0006DFr 2               ;      BEQ   LAB_DATA          ; if ELSE ignore the following statement
0006DFr 2               ;
0006DFr 2               ;; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
0006DFr 2               ;; following ELSE will, correctly, cause a syntax error
0006DFr 2               ;
0006DFr 2               ;      RTS                     ; else return to the interpreter inner loop
0006DFr 2               ;
0006DFr 2               ; *** with
0006DFr 2  68                 PLA                     ; discard interpreter loop return address
0006E0r 2  68                 PLA                     ; so data structures are at the correct stack offset
0006E1r 2  20 C2 00           JSR   LAB_GBYT          ; restore token or variable
0006E4r 2  20 rr rr           JSR   LAB_15FF          ; interpret BASIC code from (Bpntrl)
0006E7r 2               
0006E7r 2               ; the IF was executed and there may be a following ELSE so the code needs to return
0006E7r 2               ; here to check and ignore the ELSE if present
0006E7r 2               
0006E7r 2  A0 00              LDY   #$00              ; clear the index
0006E9r 2  B1 C3              LDA   (Bpntrl),Y        ; get the next BASIC byte
0006EBr 2  C9 AC              CMP   #TK_ELSE          ; compare it with the token for ELSE
0006EDr 2  D0 03              BNE   LAB_no_ELSE       ; no - continue on this line
0006EFr 2  20 rr rr           JSR   LAB_DATA          ; yes - skip the rest of the line
0006F2r 2               
0006F2r 2               ; there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
0006F2r 2               ; following ELSE will, correctly, cause a syntax error
0006F2r 2               
0006F2r 2               LAB_no_ELSE
0006F2r 2  4C rr rr           JMP LAB_15C2            ; return to the interpreter inner loop
0006F5r 2               ; *** end patch  allow NEXT, LOOP & RETURN to find FOR, DO or GOSUB structure on stack
0006F5r 2               
0006F5r 2               ; perform ELSE after IF
0006F5r 2               
0006F5r 2               LAB_174E
0006F5r 2  A0 00              LDY   #$00              ; clear the BASIC byte index
0006F7r 2  A2 01              LDX   #$01              ; clear the nesting depth
0006F9r 2               LAB_1750
0006F9r 2  C8                 INY                     ; increment the BASIC byte index
0006FAr 2  B1 C3              LDA   (Bpntrl),Y        ; get the next BASIC byte
0006FCr 2  F0 0F              BEQ   LAB_1753          ; if EOL go add the pointer and return
0006FEr 2               
0006FEr 2  C9 8B              CMP   #TK_IF            ; compare the byte with the token for IF
000700r 2  D0 03              BNE   LAB_1752          ; if not IF token skip the depth increment
000702r 2               
000702r 2  E8                 INX                     ; else increment the nesting depth ..
000703r 2  D0 F4              BNE   LAB_1750          ; .. and continue looking
000705r 2               
000705r 2               LAB_1752
000705r 2  C9 AC              CMP   #TK_ELSE          ; compare the byte with the token for ELSE
000707r 2  D0 F0              BNE   LAB_1750          ; if not ELSE token continue looking
000709r 2               
000709r 2  CA                 DEX                     ; was ELSE so decrement the nesting depth
00070Ar 2  D0 ED              BNE   LAB_1750          ; loop if still nested
00070Cr 2               
00070Cr 2  C8                 INY                     ; increment the BASIC byte index past the ELSE
00070Dr 2               
00070Dr 2               ; found the matching ELSE, now do <{n|statement}>
00070Dr 2               
00070Dr 2               LAB_1753
00070Dr 2  98                 TYA                     ; else copy line index to A
00070Er 2  18                 CLC                     ; clear carry for add
00070Fr 2  65 C3              ADC   Bpntrl            ; add the BASIC execute pointer low byte
000711r 2  85 C3              STA   Bpntrl            ; save the BASIC execute pointer low byte
000713r 2  90 02              BCC   LAB_1754          ; branch if no overflow to high byte
000715r 2               
000715r 2  E6 C4              INC   Bpntrh            ; else increment the BASIC execute pointer high byte
000717r 2               LAB_1754
000717r 2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00071Ar 2  90 C0              BCC   LAB_174C          ; if numeric do GOTO n
00071Cr 2                                             ; the code will return to the interpreter loop at the
00071Cr 2                                             ; tail end of the GOTO <n>
00071Cr 2               
00071Cr 2  4C rr rr           JMP   LAB_15FF          ; interpret BASIC code from (Bpntrl)
00071Fr 2                                             ; the code will return to the interpreter loop at the
00071Fr 2                                             ; tail end of the <statement>
00071Fr 2               
00071Fr 2               ; perform REM, skip (rest of) line
00071Fr 2               
00071Fr 2               LAB_REM
00071Fr 2  20 rr rr           JSR   LAB_SNBL          ; scan for next BASIC line
000722r 2  4C rr rr           JMP   LAB_170F          ; go set BASIC execute pointer and return, branch always
000725r 2               
000725r 2               LAB_16FD
000725r 2  4C rr rr           JMP   LAB_SNER          ; do syntax error then warm start
000728r 2               
000728r 2               ; perform ON
000728r 2               
000728r 2               LAB_ON
000728r 2  C9 A9              CMP   #TK_IRQ           ; was it IRQ token ?
00072Ar 2  D0 03              BNE   LAB_NOIN          ; if not go check NMI
00072Cr 2               
00072Cr 2  4C rr rr           JMP   LAB_SIRQ          ; else go set-up IRQ
00072Fr 2               
00072Fr 2               LAB_NOIN
00072Fr 2  C9 AA              CMP   #TK_NMI           ; was it NMI token ?
000731r 2  D0 03              BNE   LAB_NONM          ; if not go do normal ON command
000733r 2               
000733r 2  4C rr rr           JMP   LAB_SNMI          ; else go set-up NMI
000736r 2               
000736r 2               LAB_NONM
000736r 2  20 rr rr           JSR   LAB_GTBY          ; get byte parameter
000739r 2  48                 PHA                     ; push GOTO/GOSUB token
00073Ar 2  C9 8D              CMP   #TK_GOSUB         ; compare with GOSUB token
00073Cr 2  F0 04              BEQ   LAB_176B          ; branch if GOSUB
00073Er 2               
00073Er 2  C9 89              CMP   #TK_GOTO          ; compare with GOTO token
000740r 2               LAB_1767
000740r 2  D0 E3              BNE   LAB_16FD          ; if not GOTO do syntax error then warm start
000742r 2               
000742r 2               
000742r 2               ; next character was GOTO or GOSUB
000742r 2               
000742r 2               LAB_176B
000742r 2  C6 AF              DEC   FAC1_3            ; decrement index (byte value)
000744r 2  D0 04              BNE   LAB_1773          ; branch if not zero
000746r 2               
000746r 2  68                 PLA                     ; pull GOTO/GOSUB token
000747r 2  4C rr rr           JMP   LAB_1602          ; go execute it
00074Ar 2               
00074Ar 2               LAB_1773
00074Ar 2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00074Dr 2  20 rr rr           JSR   LAB_GFPN          ; get fixed-point number into temp integer (skip this n)
000750r 2                                             ; (we could LDX #',' and JSR LAB_SNBL+2, then we
000750r 2                                             ; just BNE LAB_176B for the loop. should be quicker ..
000750r 2                                             ; no we can't, what if we meet a colon or [EOL]?)
000750r 2  C9 2C              CMP   #$2C              ; compare next character with ","
000752r 2  F0 EE              BEQ   LAB_176B          ; loop if ","
000754r 2               
000754r 2               LAB_177E
000754r 2  68                 PLA                     ; else pull keyword token (run out of options)
000755r 2                                             ; also dump +/-1 pointer low byte and exit
000755r 2               LAB_177F
000755r 2  60                 RTS
000756r 2               
000756r 2               ; takes n * 106 + 11 cycles where n is the number of digits
000756r 2               
000756r 2               ; get fixed-point number into temp integer
000756r 2               
000756r 2               LAB_GFPN
000756r 2  A2 00              LDX   #$00              ; clear reg
000758r 2  86 11              STX   Itempl            ; clear temporary integer low byte
00075Ar 2               LAB_1785
00075Ar 2  86 12              STX   Itemph            ; save temporary integer high byte
00075Cr 2  B0 F7              BCS   LAB_177F          ; return if carry set, end of scan, character was
00075Er 2                                             ; not 0-9
00075Er 2               
00075Er 2  E0 19              CPX   #$19              ; compare high byte with $19
000760r 2  A8                 TAY                     ; ensure Zb = 0 if the branch is taken
000761r 2  B0 DD              BCS   LAB_1767          ; branch if >=, makes max line # 63999 because next
000763r 2                                             ; bit does *$0A, = 64000, compare at target will fail
000763r 2                                             ; and do syntax error
000763r 2               
000763r 2  E9 2F              SBC   #'0'-1            ; subtract "0", $2F + carry, from byte
000765r 2  A8                 TAY                     ; copy binary digit
000766r 2  A5 11              LDA   Itempl            ; get temporary integer low byte
000768r 2  0A                 ASL                     ; *2 low byte
000769r 2  26 12              ROL   Itemph            ; *2 high byte
00076Br 2  0A                 ASL                     ; *2 low byte
00076Cr 2  26 12              ROL   Itemph            ; *2 high byte, *4
00076Er 2  65 11              ADC   Itempl            ; + low byte, *5
000770r 2  85 11              STA   Itempl            ; save it
000772r 2  8A                 TXA                     ; get high byte copy to A
000773r 2  65 12              ADC   Itemph            ; + high byte, *5
000775r 2  06 11              ASL   Itempl            ; *2 low byte, *10d
000777r 2  2A                 ROL                     ; *2 high byte, *10d
000778r 2  AA                 TAX                     ; copy high byte back to X
000779r 2  98                 TYA                     ; get binary digit back
00077Ar 2  65 11              ADC   Itempl            ; add number low byte
00077Cr 2  85 11              STA   Itempl            ; save number low byte
00077Er 2  90 01              BCC   LAB_17B3          ; if no overflow to high byte get next character
000780r 2               
000780r 2  E8                 INX                     ; else increment high byte
000781r 2               LAB_17B3
000781r 2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
000784r 2  4C rr rr           JMP   LAB_1785          ; loop for next character
000787r 2               
000787r 2               ; perform DEC
000787r 2               
000787r 2               LAB_DEC
000787r 2  A9 rr              LDA   #<LAB_2AFD        ; set -1 pointer low byte
000789r 2  2C                 .byte $2C               ; BIT abs to skip the LDA below
00078Ar 2               
00078Ar 2               ; perform INC
00078Ar 2               
00078Ar 2               LAB_INC
00078Ar 2  A9 rr              LDA   #<LAB_259C        ; set 1 pointer low byte
00078Cr 2               LAB_17B5
00078Cr 2  48                 PHA                     ; save +/-1 pointer low byte
00078Dr 2               LAB_17B7
00078Dr 2  20 rr rr           JSR   LAB_GVAR          ; get var address
000790r 2  A6 5F              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
000792r 2  30 1E              BMI   IncrErr           ; exit if string
000794r 2               
000794r 2  85 97              STA   Lvarpl            ; save var address low byte
000796r 2  84 98              STY   Lvarph            ; save var address high byte
000798r 2  20 rr rr           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
00079Br 2  68                 PLA                     ; get +/-1 pointer low byte
00079Cr 2  48                 PHA                     ; save +/-1 pointer low byte
00079Dr 2  A0 rr              LDY   #>LAB_259C        ; set +/-1 pointer high byte (both the same)
00079Fr 2  20 rr rr           JSR   LAB_246C          ; add (AY) to FAC1
0007A2r 2  20 rr rr           JSR   LAB_PFAC          ; pack FAC1 into variable (Lvarpl)
0007A5r 2               
0007A5r 2  20 C2 00           JSR   LAB_GBYT          ; scan memory
0007A8r 2  C9 2C              CMP   #','              ; compare with ","
0007AAr 2  D0 A8              BNE   LAB_177E          ; exit if not "," (either end or error)
0007ACr 2               
0007ACr 2                                             ; was "," so another INCR variable to do
0007ACr 2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
0007AFr 2  4C rr rr           JMP   LAB_17B7          ; go do next var
0007B2r 2               
0007B2r 2               IncrErr
0007B2r 2  4C rr rr           JMP   LAB_1ABC          ; do "Type mismatch" error then warm start
0007B5r 2               
0007B5r 2               ; perform LET
0007B5r 2               
0007B5r 2               LAB_LET
0007B5r 2  20 rr rr           JSR   LAB_GVAR          ; get var address
0007B8r 2  85 97              STA   Lvarpl            ; save var address low byte
0007BAr 2  84 98              STY   Lvarph            ; save var address high byte
0007BCr 2  A9 C1              LDA   #TK_EQUAL         ; get = token
0007BEr 2  20 rr rr           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
0007C1r 2  A5 5F              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
0007C3r 2  48                 PHA                     ; push data type flag
0007C4r 2  20 rr rr           JSR   LAB_EVEX          ; evaluate expression
0007C7r 2  68                 PLA                     ; pop data type flag
0007C8r 2  2A                 ROL                     ; set carry if type = string
0007C9r 2               ; *** begin patch  result of a string compare stores string pointer to variable
0007C9r 2               ;                  but should store FAC1 (true/false value)
0007C9r 2               ; *** replace
0007C9r 2               ;      JSR   LAB_CKTM          ; type match check, set C for string
0007C9r 2               ;      BNE   LAB_17D5          ; branch if string
0007C9r 2               ; *** with
0007C9r 2  20 rr rr           JSR   LAB_CKTM          ; type match check, keep C (expected type)
0007CCr 2  B0 03              BCS   LAB_17D5          ; branch if string
0007CEr 2               ; *** end patch
0007CEr 2               
0007CEr 2  4C rr rr           JMP   LAB_PFAC          ; pack FAC1 into variable (Lvarpl) and return
0007D1r 2               
0007D1r 2               ; string LET
0007D1r 2               
0007D1r 2               LAB_17D5
0007D1r 2  A0 02              LDY   #$02              ; set index to pointer high byte
0007D3r 2  B1 AE              LDA   (des_pl),Y        ; get string pointer high byte
0007D5r 2  C5 82              CMP   Sstorh            ; compare bottom of string space high byte
0007D7r 2  90 17              BCC   LAB_17F4          ; if less assign value and exit (was in program memory)
0007D9r 2               
0007D9r 2  D0 07              BNE   LAB_17E6          ; branch if >
0007DBr 2                                             ; else was equal so compare low bytes
0007DBr 2  88                 DEY                     ; decrement index
0007DCr 2  B1 AE              LDA   (des_pl),Y        ; get pointer low byte
0007DEr 2  C5 81              CMP   Sstorl            ; compare bottom of string space low byte
0007E0r 2  90 0E              BCC   LAB_17F4          ; if less assign value and exit (was in program memory)
0007E2r 2               
0007E2r 2                                             ; pointer was >= to bottom of string space pointer
0007E2r 2               LAB_17E6
0007E2r 2  A4 AF              LDY   des_ph            ; get descriptor pointer high byte
0007E4r 2  C4 7C              CPY   Svarh             ; compare start of vars high byte
0007E6r 2  90 08              BCC   LAB_17F4          ; branch if less (descriptor is on stack)
0007E8r 2               
0007E8r 2  D0 0D              BNE   LAB_17FB          ; branch if greater (descriptor is not on stack)
0007EAr 2               
0007EAr 2                                             ; else high bytes were equal so ..
0007EAr 2  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
0007ECr 2  C5 7B              CMP   Svarl             ; compare start of vars low byte
0007EEr 2  B0 07              BCS   LAB_17FB          ; branch if >= (descriptor is not on stack)
0007F0r 2               
0007F0r 2               LAB_17F4
0007F0r 2  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
0007F2r 2  A4 AF              LDY   des_ph            ; get descriptor pointer high byte
0007F4r 2  4C rr rr           JMP   LAB_1811          ; clean stack, copy descriptor to variable and return
0007F7r 2               
0007F7r 2                                             ; make space and copy string
0007F7r 2               LAB_17FB
0007F7r 2  A0 00              LDY   #$00              ; index to length
0007F9r 2  B1 AE              LDA   (des_pl),Y        ; get string length
0007FBr 2  20 rr rr           JSR   LAB_209C          ; copy string
0007FEr 2  A5 9E              LDA   des_2l            ; get descriptor pointer low byte
000800r 2  A4 9F              LDY   des_2h            ; get descriptor pointer high byte
000802r 2  85 B8              STA   ssptr_l           ; save descriptor pointer low byte
000804r 2  84 B9              STY   ssptr_h           ; save descriptor pointer high byte
000806r 2  20 rr rr           JSR   LAB_228A          ; copy string from descriptor (sdescr) to (Sutill)
000809r 2  A9 AC              LDA   #<FAC1_e          ; set descriptor pointer low byte
00080Br 2  A0 00              LDY   #>FAC1_e          ; get descriptor pointer high byte
00080Dr 2               
00080Dr 2                                             ; clean stack and assign value to string variable
00080Dr 2               LAB_1811
00080Dr 2  85 9E              STA   des_2l            ; save descriptor_2 pointer low byte
00080Fr 2  84 9F              STY   des_2h            ; save descriptor_2 pointer high byte
000811r 2  20 rr rr           JSR   LAB_22EB          ; clean descriptor stack, YA = pointer
000814r 2  A0 00              LDY   #$00              ; index to length
000816r 2  B1 9E              LDA   (des_2l),Y        ; get string length
000818r 2  91 97              STA   (Lvarpl),Y        ; copy to let string variable
00081Ar 2  C8                 INY                     ; index to string pointer low byte
00081Br 2  B1 9E              LDA   (des_2l),Y        ; get string pointer low byte
00081Dr 2  91 97              STA   (Lvarpl),Y        ; copy to let string variable
00081Fr 2  C8                 INY                     ; index to string pointer high byte
000820r 2  B1 9E              LDA   (des_2l),Y        ; get string pointer high byte
000822r 2  91 97              STA   (Lvarpl),Y        ; copy to let string variable
000824r 2  60                 RTS
000825r 2               
000825r 2               ; perform GET
000825r 2               
000825r 2               LAB_GET
000825r 2  20 rr rr           JSR   LAB_GVAR          ; get var address
000828r 2  85 97              STA   Lvarpl            ; save var address low byte
00082Ar 2  84 98              STY   Lvarph            ; save var address high byte
00082Cr 2  20 rr rr           JSR   INGET             ; get input byte
00082Fr 2  A6 5F              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
000831r 2  30 07              BMI   LAB_GETS          ; go get string character
000833r 2               
000833r 2                                             ; was numeric get
000833r 2  A8                 TAY                     ; copy character to Y
000834r 2  20 rr rr           JSR   LAB_1FD0          ; convert Y to byte in FAC1
000837r 2  4C rr rr           JMP   LAB_PFAC          ; pack FAC1 into variable (Lvarpl) and return
00083Ar 2               
00083Ar 2               LAB_GETS
00083Ar 2  48                 PHA                     ; save character
00083Br 2  A9 01              LDA   #$01              ; string is single byte
00083Dr 2  B0 01              BCS   LAB_IsByte        ; branch if byte received
00083Fr 2               
00083Fr 2  68                 PLA                     ; string is null
000840r 2               LAB_IsByte
000840r 2  20 rr rr           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
000843r 2                                             ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
000843r 2  F0 05              BEQ   LAB_NoSt          ; skip store if null string
000845r 2               
000845r 2  68                 PLA                     ; get character back
000846r 2  A0 00              LDY   #$00              ; clear index
000848r 2  91 AD              STA   (str_pl),Y        ; save byte in string (byte IS string!)
00084Ar 2               LAB_NoSt
00084Ar 2  20 rr rr           JSR   LAB_RTST          ; check for space on descriptor stack then put address
00084Dr 2                                             ; and length on descriptor stack and update stack pointers
00084Dr 2               
00084Dr 2  4C rr rr           JMP   LAB_17D5          ; do string LET and return
000850r 2               
000850r 2               ; perform PRINT
000850r 2               
000850r 2               LAB_1829
000850r 2  20 rr rr           JSR   LAB_18C6          ; print string from Sutill/Sutilh
000853r 2               LAB_182C
000853r 2  20 C2 00           JSR   LAB_GBYT          ; scan memory
000856r 2               
000856r 2               ; PRINT
000856r 2               
000856r 2               LAB_PRINT
000856r 2  F0 3B              BEQ   LAB_CRLF          ; if nothing following just print CR/LF
000858r 2               
000858r 2               LAB_1831
000858r 2  C9 AB              CMP   #TK_TAB           ; compare with TAB( token
00085Ar 2  F0 56              BEQ   LAB_18A2          ; go do TAB/SPC
00085Cr 2               
00085Cr 2  C9 AF              CMP   #TK_SPC           ; compare with SPC( token
00085Er 2  F0 52              BEQ   LAB_18A2          ; go do TAB/SPC
000860r 2               
000860r 2  C9 2C              CMP   #','              ; compare with ","
000862r 2  F0 38              BEQ   LAB_188B          ; go do move to next TAB mark
000864r 2               
000864r 2  C9 3B              CMP   #';'              ; compare with ";"
000866r 2  F0 66              BEQ   LAB_18BD          ; if ";" continue with PRINT processing
000868r 2               
000868r 2  20 rr rr           JSR   LAB_EVEX          ; evaluate expression
00086Br 2  24 5F              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
00086Dr 2  30 E1              BMI   LAB_1829          ; branch if string
00086Fr 2               
00086Fr 2  20 rr rr           JSR   LAB_296E          ; convert FAC1 to string
000872r 2  20 rr rr           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
000875r 2  A0 00              LDY   #$00              ; clear index
000877r 2               
000877r 2               ; don't check fit if terminal width byte is zero
000877r 2               
000877r 2  A5 0F              LDA   TWidth            ; get terminal width byte
000879r 2  F0 0A              BEQ   LAB_185E          ; skip check if zero
00087Br 2               
00087Br 2  38                 SEC                     ; set carry for subtract
00087Cr 2  E5 0E              SBC   TPos              ; subtract terminal position
00087Er 2  F1 AE              SBC   (des_pl),Y        ; subtract string length
000880r 2  B0 03              BCS   LAB_185E          ; branch if less than terminal width
000882r 2               
000882r 2  20 rr rr           JSR   LAB_CRLF          ; else print CR/LF
000885r 2               LAB_185E
000885r 2  20 rr rr           JSR   LAB_18C6          ; print string from Sutill/Sutilh
000888r 2  F0 C9              BEQ   LAB_182C          ; always go continue processing line
00088Ar 2               
00088Ar 2               ; CR/LF return to BASIC from BASIC input handler
00088Ar 2               
00088Ar 2               LAB_1866
00088Ar 2  A9 00              LDA   #$00              ; clear byte
00088Cr 2  9D 21 02           STA   Ibuffs,X          ; null terminate input
00088Fr 2  A2 21              LDX   #<Ibuffs          ; set X to buffer start-1 low byte
000891r 2  A0 02              LDY   #>Ibuffs          ; set Y to buffer start-1 high byte
000893r 2               
000893r 2               ; print CR/LF
000893r 2               
000893r 2               LAB_CRLF
000893r 2  A9 0D              LDA   #$0D              ; load [CR]
000895r 2  20 rr rr           JSR   LAB_PRNA          ; go print the character
000898r 2  A9 0A              LDA   #$0A              ; load [LF]
00089Ar 2  D0 52              BNE   LAB_PRNA          ; go print the character and return, branch always
00089Cr 2               
00089Cr 2               LAB_188B
00089Cr 2  A5 0E              LDA   TPos              ; get terminal position
00089Er 2  C5 10              CMP   Iclim             ; compare with input column limit
0008A0r 2  90 05              BCC   LAB_1897          ; branch if less
0008A2r 2               
0008A2r 2  20 rr rr           JSR   LAB_CRLF          ; else print CR/LF (next line)
0008A5r 2  D0 27              BNE   LAB_18BD          ; continue with PRINT processing (branch always)
0008A7r 2               
0008A7r 2               LAB_1897
0008A7r 2  38                 SEC                     ; set carry for subtract
0008A8r 2               LAB_1898
0008A8r 2  E5 64              SBC   TabSiz            ; subtract TAB size
0008AAr 2  B0 FC              BCS   LAB_1898          ; loop if result was +ve
0008ACr 2               
0008ACr 2  49 FF              EOR   #$FF              ; complement it
0008AEr 2  69 01              ADC   #$01              ; +1 (twos complement)
0008B0r 2  D0 12              BNE   LAB_18B6          ; always print A spaces (result is never $00)
0008B2r 2               
0008B2r 2                                             ; do TAB/SPC
0008B2r 2               LAB_18A2
0008B2r 2  48                 PHA                     ; save token
0008B3r 2  20 rr rr           JSR   LAB_SGBY          ; scan and get byte parameter
0008B6r 2  C9 29              CMP   #$29              ; is next character )
0008B8r 2  D0 7B              BNE   LAB_1910          ; if not do syntax error then warm start
0008BAr 2               
0008BAr 2  68                 PLA                     ; get token back
0008BBr 2  C9 AB              CMP   #TK_TAB           ; was it TAB ?
0008BDr 2  D0 06              BNE   LAB_18B7          ; if not go do SPC
0008BFr 2               
0008BFr 2                                             ; calculate TAB offset
0008BFr 2  8A                 TXA                     ; copy integer value to A
0008C0r 2  E5 0E              SBC   TPos              ; subtract terminal position
0008C2r 2  90 0A              BCC   LAB_18BD          ; branch if result was < 0 (can't TAB backwards)
0008C4r 2               
0008C4r 2                                             ; print A spaces
0008C4r 2               LAB_18B6
0008C4r 2  AA                 TAX                     ; copy result to X
0008C5r 2               LAB_18B7
0008C5r 2  8A                 TXA                     ; set flags on size for SPC
0008C6r 2  F0 06              BEQ   LAB_18BD          ; branch if result was = $0, already here
0008C8r 2               
0008C8r 2                                             ; print X spaces
0008C8r 2               LAB_18BA
0008C8r 2  20 rr rr           JSR   LAB_18E0          ; print " "
0008CBr 2  CA                 DEX                     ; decrement count
0008CCr 2  D0 FA              BNE   LAB_18BA          ; loop if not all done
0008CEr 2               
0008CEr 2                                             ; continue with PRINT processing
0008CEr 2               LAB_18BD
0008CEr 2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
0008D1r 2  D0 85              BNE   LAB_1831          ; if more to print go do it
0008D3r 2               
0008D3r 2  60                 RTS
0008D4r 2               
0008D4r 2               ; print null terminated string from memory
0008D4r 2               
0008D4r 2               LAB_18C3
0008D4r 2  20 rr rr           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
0008D7r 2               
0008D7r 2               ; print string from Sutill/Sutilh
0008D7r 2               
0008D7r 2               LAB_18C6
0008D7r 2  20 rr rr           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
0008DAr 2                                             ; space returns with A = length, X=$71=pointer low byte,
0008DAr 2                                             ; Y=$72=pointer high byte
0008DAr 2  A0 00              LDY   #$00              ; reset index
0008DCr 2  AA                 TAX                     ; copy length to X
0008DDr 2  F0 49              BEQ   LAB_188C          ; exit (RTS) if null string
0008DFr 2               
0008DFr 2               LAB_18CD
0008DFr 2               
0008DFr 2  B1 71              LDA   (ut1_pl),Y        ; get next byte
0008E1r 2  20 rr rr           JSR   LAB_PRNA          ; go print the character
0008E4r 2  C8                 INY                     ; increment index
0008E5r 2  CA                 DEX                     ; decrement count
0008E6r 2  D0 F7              BNE   LAB_18CD          ; loop if not done yet
0008E8r 2               
0008E8r 2  60                 RTS
0008E9r 2               
0008E9r 2                                             ; Print single format character
0008E9r 2               ; print " "
0008E9r 2               
0008E9r 2               LAB_18E0
0008E9r 2  A9 20              LDA   #$20              ; load " "
0008EBr 2  2C                 .byte $2C               ; change next line to BIT LAB_3FA9
0008ECr 2               
0008ECr 2               ; print "?" character
0008ECr 2               
0008ECr 2               LAB_18E3
0008ECr 2  A9 3F              LDA   #$3F              ; load "?" character
0008EEr 2               
0008EEr 2               ; print character in A
0008EEr 2               ; now includes the null handler
0008EEr 2               ; also includes infinite line length code
0008EEr 2               ; note! some routines expect this one to exit with Zb=0
0008EEr 2               
0008EEr 2               LAB_PRNA
0008EEr 2  C9 20              CMP   #' '              ; compare with " "
0008F0r 2  90 19              BCC   LAB_18F9          ; branch if less (non printing)
0008F2r 2               
0008F2r 2                                             ; else printable character
0008F2r 2  48                 PHA                     ; save the character
0008F3r 2               
0008F3r 2               ; don't check fit if terminal width byte is zero
0008F3r 2               
0008F3r 2  A5 0F              LDA   TWidth            ; get terminal width
0008F5r 2  D0 0A              BNE   LAB_18F0          ; branch if not zero (not infinite length)
0008F7r 2               
0008F7r 2               ; is "infinite line" so check TAB position
0008F7r 2               
0008F7r 2  A5 0E              LDA   TPos              ; get position
0008F9r 2  E5 64              SBC   TabSiz            ; subtract TAB size, carry set by CMP #$20 above
0008FBr 2  D0 0B              BNE   LAB_18F7          ; skip reset if different
0008FDr 2               
0008FDr 2  85 0E              STA   TPos              ; else reset position
0008FFr 2  F0 07              BEQ   LAB_18F7          ; go print character
000901r 2               
000901r 2               LAB_18F0
000901r 2  C5 0E              CMP   TPos              ; compare with terminal character position
000903r 2  D0 03              BNE   LAB_18F7          ; branch if not at end of line
000905r 2               
000905r 2  20 rr rr           JSR   LAB_CRLF          ; else print CR/LF
000908r 2               LAB_18F7
000908r 2  E6 0E              INC   TPos              ; increment terminal position
00090Ar 2  68                 PLA                     ; get character back
00090Br 2               LAB_18F9
00090Br 2  20 rr rr           JSR   V_OUTP            ; output byte via output vector
00090Er 2  C9 0D              CMP   #$0D              ; compare with [CR]
000910r 2  D0 14              BNE   LAB_188A          ; branch if not [CR]
000912r 2               
000912r 2                                             ; else print nullct nulls after the [CR]
000912r 2  86 78              STX   TempB             ; save buffer index
000914r 2  A6 0D              LDX   Nullct            ; get null count
000916r 2  F0 0A              BEQ   LAB_1886          ; branch if no nulls
000918r 2               
000918r 2  A9 00              LDA   #$00              ; load [NULL]
00091Ar 2               LAB_1880
00091Ar 2  20 rr rr           JSR   LAB_PRNA          ; go print the character
00091Dr 2  CA                 DEX                     ; decrement count
00091Er 2  D0 FA              BNE   LAB_1880          ; loop if not all done
000920r 2               
000920r 2  A9 0D              LDA   #$0D              ; restore the character (and set the flags)
000922r 2               LAB_1886
000922r 2  86 0E              STX   TPos              ; clear terminal position (X always = zero when we get here)
000924r 2  A6 78              LDX   TempB             ; restore buffer index
000926r 2               LAB_188A
000926r 2  29 FF              AND   #$FF              ; set the flags
000928r 2               LAB_188C
000928r 2  60                 RTS
000929r 2               
000929r 2               ; handle bad input data
000929r 2               
000929r 2               LAB_1904
000929r 2  A5 62              LDA   Imode             ; get input mode flag, $00=INPUT, $00=READ
00092Br 2  10 0B              BPL   LAB_1913          ; branch if INPUT (go do redo)
00092Dr 2               
00092Dr 2  A5 8D              LDA   Dlinel            ; get current DATA line low byte
00092Fr 2  A4 8E              LDY   Dlineh            ; get current DATA line high byte
000931r 2  85 87              STA   Clinel            ; save current line low byte
000933r 2  84 88              STY   Clineh            ; save current line high byte
000935r 2               LAB_1910
000935r 2  4C rr rr           JMP   LAB_SNER          ; do syntax error then warm start
000938r 2               
000938r 2                                             ; mode was INPUT
000938r 2               LAB_1913
000938r 2  A9 rr              LDA   #<LAB_REDO        ; point to redo message (low addr)
00093Ar 2  A0 rr              LDY   #>LAB_REDO        ; point to redo message (high addr)
00093Cr 2  20 rr rr           JSR   LAB_18C3          ; print null terminated string from memory
00093Fr 2  A5 8B              LDA   Cpntrl            ; get continue pointer low byte
000941r 2  A4 8C              LDY   Cpntrh            ; get continue pointer high byte
000943r 2  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
000945r 2  84 C4              STY   Bpntrh            ; save BASIC execute pointer high byte
000947r 2  60                 RTS
000948r 2               
000948r 2               ; perform INPUT
000948r 2               
000948r 2               LAB_INPUT
000948r 2  C9 22              CMP   #$22              ; compare next byte with open quote
00094Ar 2  D0 0B              BNE   LAB_1934          ; branch if no prompt string
00094Cr 2               
00094Cr 2  20 rr rr           JSR   LAB_1BC1          ; print "..." string
00094Fr 2  A9 3B              LDA   #$3B              ; load A with ";"
000951r 2  20 rr rr           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
000954r 2  20 rr rr           JSR   LAB_18C6          ; print string from Sutill/Sutilh
000957r 2               
000957r 2                                             ; done with prompt, now get data
000957r 2               LAB_1934
000957r 2  20 rr rr           JSR   LAB_CKRN          ; check not Direct, back here if ok
00095Ar 2  20 rr rr           JSR   LAB_INLN          ; print "? " and get BASIC input
00095Dr 2  A9 00              LDA   #$00              ; set mode = INPUT
00095Fr 2  CD 21 02           CMP   Ibuffs            ; test first byte in buffer
000962r 2  D0 09              BNE   LAB_1953          ; branch if not null input
000964r 2               
000964r 2               ; *** change p2: keep carry set to throw break message
000964r 2               ;      CLC                     ; was null input so clear carry to exit program
000964r 2  4C rr rr           JMP   LAB_1647          ; go do BREAK exit
000967r 2               
000967r 2               ; perform READ
000967r 2               
000967r 2               LAB_READ
000967r 2  A6 8F              LDX   Dptrl             ; get DATA pointer low byte
000969r 2  A4 90              LDY   Dptrh             ; get DATA pointer high byte
00096Br 2  A9 80              LDA   #$80              ; set mode = READ
00096Dr 2               
00096Dr 2               LAB_1953
00096Dr 2  85 62              STA   Imode             ; set input mode flag, $00=INPUT, $80=READ
00096Fr 2  86 91              STX   Rdptrl            ; save READ pointer low byte
000971r 2  84 92              STY   Rdptrh            ; save READ pointer high byte
000973r 2               
000973r 2                                             ; READ or INPUT next variable from list
000973r 2               LAB_195B
000973r 2  20 rr rr           JSR   LAB_GVAR          ; get (var) address
000976r 2  85 97              STA   Lvarpl            ; save address low byte
000978r 2  84 98              STY   Lvarph            ; save address high byte
00097Ar 2  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
00097Cr 2  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte
00097Er 2  85 11              STA   Itempl            ; save as temporary integer low byte
000980r 2  84 12              STY   Itemph            ; save as temporary integer high byte
000982r 2  A6 91              LDX   Rdptrl            ; get READ pointer low byte
000984r 2  A4 92              LDY   Rdptrh            ; get READ pointer high byte
000986r 2  86 C3              STX   Bpntrl            ; set BASIC execute pointer low byte
000988r 2  84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
00098Ar 2  20 C2 00           JSR   LAB_GBYT          ; scan memory
00098Dr 2  D0 11              BNE   LAB_1988          ; branch if not null
00098Fr 2               
00098Fr 2                                             ; pointer was to null entry
00098Fr 2  24 62              BIT   Imode             ; test input mode flag, $00=INPUT, $80=READ
000991r 2  30 65              BMI   LAB_19DD          ; branch if READ
000993r 2               
000993r 2                                             ; mode was INPUT
000993r 2  20 rr rr           JSR   LAB_18E3          ; print "?" character (double ? for extended input)
000996r 2  20 rr rr           JSR   LAB_INLN          ; print "? " and get BASIC input
000999r 2  86 C3              STX   Bpntrl            ; set BASIC execute pointer low byte
00099Br 2  84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
00099Dr 2               LAB_1985
00099Dr 2  20 C2 00           JSR   LAB_GBYT          ; scan memory
0009A0r 2               LAB_1988
0009A0r 2  24 5F              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
0009A2r 2  10 24              BPL   LAB_19B0          ; branch if numeric
0009A4r 2               
0009A4r 2                                             ; else get string
0009A4r 2  85 5B              STA   Srchc             ; save search character
0009A6r 2  C9 22              CMP   #$22              ; was it " ?
0009A8r 2  F0 07              BEQ   LAB_1999          ; branch if so
0009AAr 2               
0009AAr 2  A9 3A              LDA   #':'              ; else search character is ":"
0009ACr 2  85 5B              STA   Srchc             ; set new search character
0009AEr 2  A9 2C              LDA   #','              ; other search character is ","
0009B0r 2  18                 CLC                     ; clear carry for add
0009B1r 2               LAB_1999
0009B1r 2  85 5C              STA   Asrch             ; set second search character
0009B3r 2  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
0009B5r 2  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte
0009B7r 2               
0009B7r 2  69 00              ADC   #$00              ; c is =1 if we came via the BEQ LAB_1999, else =0
0009B9r 2  90 01              BCC   LAB_19A4          ; branch if no execute pointer low byte rollover
0009BBr 2               
0009BBr 2  C8                 INY                     ; else increment high byte
0009BCr 2               LAB_19A4
0009BCr 2  20 rr rr           JSR   LAB_20B4          ; print Srchc or Asrch terminated string to Sutill/Sutilh
0009BFr 2  20 rr rr           JSR   LAB_23F3          ; restore BASIC execute pointer from temp (Btmpl/Btmph)
0009C2r 2  20 rr rr           JSR   LAB_17D5          ; go do string LET
0009C5r 2  4C rr rr           JMP   LAB_19B6          ; go check string terminator
0009C8r 2               
0009C8r 2                                             ; get numeric INPUT
0009C8r 2               LAB_19B0
0009C8r 2  20 rr rr           JSR   LAB_2887          ; get FAC1 from string
0009CBr 2  20 rr rr           JSR   LAB_PFAC          ; pack FAC1 into (Lvarpl)
0009CEr 2               LAB_19B6
0009CEr 2  20 C2 00           JSR   LAB_GBYT          ; scan memory
0009D1r 2  F0 0A              BEQ   LAB_19C5          ; branch if null (last entry)
0009D3r 2               
0009D3r 2  C9 2C              CMP   #','              ; else compare with ","
0009D5r 2  F0 03              BEQ   LAB_19C2          ; branch if ","
0009D7r 2               
0009D7r 2  4C rr rr           JMP   LAB_1904          ; else go handle bad input data
0009DAr 2               
0009DAr 2                                             ; got good input data
0009DAr 2               LAB_19C2
0009DAr 2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
0009DDr 2               LAB_19C5
0009DDr 2  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte (temp READ/INPUT ptr)
0009DFr 2  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte (temp READ/INPUT ptr)
0009E1r 2  85 91              STA   Rdptrl            ; save for now
0009E3r 2  84 92              STY   Rdptrh            ; save for now
0009E5r 2  A5 11              LDA   Itempl            ; get temporary integer low byte (temp BASIC execute ptr)
0009E7r 2  A4 12              LDY   Itemph            ; get temporary integer high byte (temp BASIC execute ptr)
0009E9r 2  85 C3              STA   Bpntrl            ; set BASIC execute pointer low byte
0009EBr 2  84 C4              STY   Bpntrh            ; set BASIC execute pointer high byte
0009EDr 2  20 C2 00           JSR   LAB_GBYT          ; scan memory
0009F0r 2  F0 2C              BEQ   LAB_1A03          ; if null go do extra ignored message
0009F2r 2               
0009F2r 2  20 rr rr           JSR   LAB_1C01          ; else scan for "," , else do syntax error then warm start
0009F5r 2  4C rr rr           JMP   LAB_195B          ; go INPUT next variable from list
0009F8r 2               
0009F8r 2                                             ; find next DATA statement or do "Out of DATA" error
0009F8r 2               LAB_19DD
0009F8r 2  20 rr rr           JSR   LAB_SNBS          ; scan for next BASIC statement ([:] or [EOL])
0009FBr 2  C8                 INY                     ; increment index
0009FCr 2  AA                 TAX                     ; copy character ([:] or [EOL])
0009FDr 2  D0 12              BNE   LAB_19F6          ; branch if [:]
0009FFr 2               
0009FFr 2  A2 06              LDX   #$06              ; set for "Out of DATA" error
000A01r 2  C8                 INY                     ; increment index, now points to next line pointer high byte
000A02r 2  B1 C3              LDA   (Bpntrl),Y        ; get next line pointer high byte
000A04r 2  F0 73              BEQ   LAB_1A54          ; branch if end (eventually does error X)
000A06r 2               
000A06r 2  C8                 INY                     ; increment index
000A07r 2  B1 C3              LDA   (Bpntrl),Y        ; get next line # low byte
000A09r 2  85 8D              STA   Dlinel            ; save current DATA line low byte
000A0Br 2  C8                 INY                     ; increment index
000A0Cr 2  B1 C3              LDA   (Bpntrl),Y        ; get next line # high byte
000A0Er 2  C8                 INY                     ; increment index
000A0Fr 2  85 8E              STA   Dlineh            ; save current DATA line high byte
000A11r 2               LAB_19F6
000A11r 2  B1 C3              LDA   (Bpntrl),Y        ; get byte
000A13r 2  C8                 INY                     ; increment index
000A14r 2  AA                 TAX                     ; copy to X
000A15r 2  20 rr rr           JSR   LAB_170F          ; set BASIC execute pointer
000A18r 2  E0 83              CPX   #TK_DATA          ; compare with "DATA" token
000A1Ar 2  F0 81              BEQ   LAB_1985          ; was "DATA" so go do next READ
000A1Cr 2               
000A1Cr 2  D0 DA              BNE   LAB_19DD          ; go find next statement if not "DATA"
000A1Er 2               
000A1Er 2               ; end of INPUT/READ routine
000A1Er 2               
000A1Er 2               LAB_1A03
000A1Er 2  A5 91              LDA   Rdptrl            ; get temp READ pointer low byte
000A20r 2  A4 92              LDY   Rdptrh            ; get temp READ pointer high byte
000A22r 2  A6 62              LDX   Imode             ; get input mode flag, $00=INPUT, $80=READ
000A24r 2  10 03              BPL   LAB_1A0E          ; branch if INPUT
000A26r 2               
000A26r 2  4C rr rr           JMP   LAB_1624          ; save AY as DATA pointer and return
000A29r 2               
000A29r 2                                             ; we were getting INPUT
000A29r 2               LAB_1A0E
000A29r 2  A0 00              LDY   #$00              ; clear index
000A2Br 2  B1 91              LDA   (Rdptrl),Y        ; get next byte
000A2Dr 2  D0 01              BNE   LAB_1A1B          ; error if not end of INPUT
000A2Fr 2               
000A2Fr 2  60                 RTS
000A30r 2               
000A30r 2                                             ; user typed too much
000A30r 2               LAB_1A1B
000A30r 2  A9 rr              LDA   #<LAB_IMSG        ; point to extra ignored message (low addr)
000A32r 2  A0 rr              LDY   #>LAB_IMSG        ; point to extra ignored message (high addr)
000A34r 2  4C rr rr           JMP   LAB_18C3          ; print null terminated string from memory and return
000A37r 2               
000A37r 2               ; search the stack for FOR activity
000A37r 2               ; exit with z=1 if FOR else exit with z=0
000A37r 2               
000A37r 2               LAB_11A1
000A37r 2  BA                 TSX                     ; copy stack pointer
000A38r 2  E8                 INX                     ; +1 pass return address
000A39r 2  E8                 INX                     ; +2 pass return address
000A3Ar 2  E8                 INX                     ; +3 pass calling routine return address
000A3Br 2  E8                 INX                     ; +4 pass calling routine return address
000A3Cr 2               LAB_11A6
000A3Cr 2  BD 01 01           LDA   LAB_STAK+1,X      ; get token byte from stack
000A3Fr 2  C9 81              CMP   #TK_FOR           ; is it FOR token
000A41r 2  D0 21              BNE   LAB_11CE          ; exit if not FOR token
000A43r 2               
000A43r 2                                             ; was FOR token
000A43r 2  A5 98              LDA   Frnxth            ; get var pointer for FOR/NEXT high byte
000A45r 2  D0 0A              BNE   LAB_11BB          ; branch if not null
000A47r 2               
000A47r 2  BD 02 01           LDA   LAB_STAK+2,X      ; get FOR variable pointer low byte
000A4Ar 2  85 97              STA   Frnxtl            ; save var pointer for FOR/NEXT low byte
000A4Cr 2  BD 03 01           LDA   LAB_STAK+3,X      ; get FOR variable pointer high byte
000A4Fr 2  85 98              STA   Frnxth            ; save var pointer for FOR/NEXT high byte
000A51r 2               LAB_11BB
000A51r 2  DD 03 01           CMP   LAB_STAK+3,X      ; compare var pointer with stacked var pointer (high byte)
000A54r 2  D0 07              BNE   LAB_11C7          ; branch if no match
000A56r 2               
000A56r 2  A5 97              LDA   Frnxtl            ; get var pointer for FOR/NEXT low byte
000A58r 2  DD 02 01           CMP   LAB_STAK+2,X      ; compare var pointer with stacked var pointer (low byte)
000A5Br 2  F0 07              BEQ   LAB_11CE          ; exit if match found
000A5Dr 2               
000A5Dr 2               LAB_11C7
000A5Dr 2  8A                 TXA                     ; copy index
000A5Er 2  18                 CLC                     ; clear carry for add
000A5Fr 2  69 10              ADC   #$10              ; add FOR stack use size
000A61r 2  AA                 TAX                     ; copy back to index
000A62r 2  D0 D8              BNE   LAB_11A6          ; loop if not at start of stack
000A64r 2               
000A64r 2               LAB_11CE
000A64r 2  60                 RTS
000A65r 2               
000A65r 2               ; perform NEXT
000A65r 2               
000A65r 2               LAB_NEXT
000A65r 2  D0 04              BNE   LAB_1A46          ; branch if NEXT var
000A67r 2               
000A67r 2  A0 00              LDY   #$00              ; else clear Y
000A69r 2  F0 03              BEQ   LAB_1A49          ; branch always (no variable to search for)
000A6Br 2               
000A6Br 2               ; NEXT var
000A6Br 2               
000A6Br 2               LAB_1A46
000A6Br 2  20 rr rr           JSR   LAB_GVAR          ; get variable address
000A6Er 2               LAB_1A49
000A6Er 2  85 97              STA   Frnxtl            ; store variable pointer low byte
000A70r 2  84 98              STY   Frnxth            ; store variable pointer high byte
000A72r 2                                             ; (both cleared if no variable defined)
000A72r 2  20 rr rr           JSR   LAB_11A1          ; search the stack for FOR activity
000A75r 2  F0 04              BEQ   LAB_1A56          ; branch if found
000A77r 2               
000A77r 2  A2 00              LDX   #$00              ; else set error $00 ("NEXT without FOR" error)
000A79r 2               LAB_1A54
000A79r 2  F0 63              BEQ   LAB_1ABE          ; do error #X, then warm start
000A7Br 2               
000A7Br 2               LAB_1A56
000A7Br 2  9A                 TXS                     ; set stack pointer, X set by search, dumps return addresses
000A7Cr 2               
000A7Cr 2  8A                 TXA                     ; copy stack pointer
000A7Dr 2  38                 SEC                     ; set carry for subtract
000A7Er 2  E9 F7              SBC   #$F7              ; point to TO var
000A80r 2  85 73              STA   ut2_pl            ; save pointer to TO var for compare
000A82r 2  69 FB              ADC   #$FB              ; point to STEP var
000A84r 2               
000A84r 2  A0 01              LDY   #>LAB_STAK        ; point to stack page high byte
000A86r 2  20 rr rr           JSR   LAB_UFAC          ; unpack memory (STEP value) into FAC1
000A89r 2  BA                 TSX                     ; get stack pointer back
000A8Ar 2  BD 08 01           LDA   LAB_STAK+8,X      ; get step sign
000A8Dr 2  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
000A8Fr 2  A5 97              LDA   Frnxtl            ; get FOR variable pointer low byte
000A91r 2  A4 98              LDY   Frnxth            ; get FOR variable pointer high byte
000A93r 2  20 rr rr           JSR   LAB_246C          ; add (FOR variable) to FAC1
000A96r 2  20 rr rr           JSR   LAB_PFAC          ; pack FAC1 into (FOR variable)
000A99r 2  A0 01              LDY   #>LAB_STAK        ; point to stack page high byte
000A9Br 2  20 rr rr           JSR   LAB_27FA          ; compare FAC1 with (Y,ut2_pl) (TO value)
000A9Er 2  BA                 TSX                     ; get stack pointer back
000A9Fr 2  DD 08 01           CMP   LAB_STAK+8,X      ; compare step sign
000AA2r 2  F0 17              BEQ   LAB_1A9B          ; branch if = (loop complete)
000AA4r 2               
000AA4r 2                                             ; loop back and do it all again
000AA4r 2  BD 0D 01           LDA   LAB_STAK+$0D,X    ; get FOR line low byte
000AA7r 2  85 87              STA   Clinel            ; save current line low byte
000AA9r 2  BD 0E 01           LDA   LAB_STAK+$0E,X    ; get FOR line high byte
000AACr 2  85 88              STA   Clineh            ; save current line high byte
000AAEr 2  BD 10 01           LDA   LAB_STAK+$10,X    ; get BASIC execute pointer low byte
000AB1r 2  85 C3              STA   Bpntrl            ; save BASIC execute pointer low byte
000AB3r 2  BD 0F 01           LDA   LAB_STAK+$0F,X    ; get BASIC execute pointer high byte
000AB6r 2  85 C4              STA   Bpntrh            ; save BASIC execute pointer high byte
000AB8r 2               LAB_1A98
000AB8r 2  4C rr rr           JMP   LAB_15C2          ; go do interpreter inner loop
000ABBr 2               
000ABBr 2                                             ; loop complete so carry on
000ABBr 2               LAB_1A9B
000ABBr 2  8A                 TXA                     ; stack copy to A
000ABCr 2  69 0F              ADC   #$0F              ; add $10 ($0F+carry) to dump FOR structure
000ABEr 2  AA                 TAX                     ; copy back to index
000ABFr 2  9A                 TXS                     ; copy to stack pointer
000AC0r 2  20 C2 00           JSR   LAB_GBYT          ; scan memory
000AC3r 2  C9 2C              CMP   #','              ; compare with ","
000AC5r 2  D0 F1              BNE   LAB_1A98          ; branch if not "," (go do interpreter inner loop)
000AC7r 2               
000AC7r 2                                             ; was "," so another NEXT variable to do
000AC7r 2  20 BC 00           JSR   LAB_IGBY          ; else increment and scan memory
000ACAr 2  20 rr rr           JSR   LAB_1A46          ; do NEXT (var)
000ACDr 2               
000ACDr 2               ; evaluate expression and check is numeric, else do type mismatch
000ACDr 2               
000ACDr 2               LAB_EVNM
000ACDr 2  20 rr rr           JSR   LAB_EVEX          ; evaluate expression
000AD0r 2               
000AD0r 2               ; check if source is numeric, else do type mismatch
000AD0r 2               
000AD0r 2               LAB_CTNM
000AD0r 2  18                 CLC                     ; destination is numeric
000AD1r 2  24                 .byte $24               ; makes next line BIT $38
000AD2r 2               
000AD2r 2               ; check if source is string, else do type mismatch
000AD2r 2               
000AD2r 2               LAB_CTST
000AD2r 2  38                 SEC                     ; required type is string
000AD3r 2               
000AD3r 2               ; type match check, set C for string, clear C for numeric
000AD3r 2               
000AD3r 2               LAB_CKTM
000AD3r 2  24 5F              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
000AD5r 2  30 03              BMI   LAB_1ABA          ; branch if data type is string
000AD7r 2               
000AD7r 2                                             ; else data type was numeric
000AD7r 2  B0 03              BCS   LAB_1ABC          ; if required type is string do type mismatch error
000AD9r 2               LAB_1AB9
000AD9r 2  60                 RTS
000ADAr 2               
000ADAr 2                                             ; data type was string, now check required type
000ADAr 2               LAB_1ABA
000ADAr 2  B0 FD              BCS   LAB_1AB9          ; exit if required type is string
000ADCr 2               
000ADCr 2                                             ; else do type mismatch error
000ADCr 2               LAB_1ABC
000ADCr 2  A2 18              LDX   #$18              ; error code $18 ("Type mismatch" error)
000ADEr 2               LAB_1ABE
000ADEr 2  4C rr rr           JMP   LAB_XERR          ; do error #X, then warm start
000AE1r 2               
000AE1r 2               ; evaluate expression
000AE1r 2               
000AE1r 2               LAB_EVEX
000AE1r 2  A6 C3              LDX   Bpntrl            ; get BASIC execute pointer low byte
000AE3r 2  D0 02              BNE   LAB_1AC7          ; skip next if not zero
000AE5r 2               
000AE5r 2  C6 C4              DEC   Bpntrh            ; else decrement BASIC execute pointer high byte
000AE7r 2               LAB_1AC7
000AE7r 2  C6 C3              DEC   Bpntrl            ; decrement BASIC execute pointer low byte
000AE9r 2               
000AE9r 2               LAB_EVEZ
000AE9r 2  A9 00              LDA   #$00              ; set null precedence (flag done)
000AEBr 2               LAB_1ACC
000AEBr 2  48                 PHA                     ; push precedence byte
000AECr 2  A9 02              LDA   #$02              ; 2 bytes
000AEEr 2  20 rr rr           JSR   LAB_1212          ; check room on stack for A bytes
000AF1r 2  20 rr rr           JSR   LAB_GVAL          ; get value from line
000AF4r 2  A9 00              LDA   #$00              ; clear A
000AF6r 2  85 9B              STA   comp_f            ; clear compare function flag
000AF8r 2               LAB_1ADB
000AF8r 2  20 C2 00           JSR   LAB_GBYT          ; scan memory
000AFBr 2               LAB_1ADE
000AFBr 2  38                 SEC                     ; set carry for subtract
000AFCr 2  E9 C0              SBC   #TK_GT            ; subtract token for > (lowest comparison function)
000AFEr 2  90 17              BCC   LAB_1AFA          ; branch if < TK_GT
000B00r 2               
000B00r 2  C9 03              CMP   #$03              ; compare with ">" to "<" tokens
000B02r 2  B0 13              BCS   LAB_1AFA          ; branch if >= TK_SGN (highest evaluation function +1)
000B04r 2               
000B04r 2                                             ; was token for > = or < (A = 0, 1 or 2)
000B04r 2  C9 01              CMP   #$01              ; compare with token for =
000B06r 2  2A                 ROL                     ; *2, b0 = carry (=1 if token was = or <)
000B07r 2                                             ; (A = 0, 3 or 5)
000B07r 2  49 01              EOR   #$01              ; toggle b0
000B09r 2                                             ; (A = 1, 2 or 4. 1 if >, 2 if =, 4 if <)
000B09r 2  45 9B              EOR   comp_f            ; EOR with compare function flag bits
000B0Br 2  C5 9B              CMP   comp_f            ; compare with compare function flag
000B0Dr 2  90 67              BCC   LAB_1B53          ; if <(comp_f) do syntax error then warm start
000B0Fr 2                                             ; was more than one <, = or >)
000B0Fr 2               
000B0Fr 2  85 9B              STA   comp_f            ; save new compare function flag
000B11r 2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
000B14r 2  4C rr rr           JMP   LAB_1ADE          ; go do next character
000B17r 2               
000B17r 2                                             ; token is < ">" or > "<" tokens
000B17r 2               LAB_1AFA
000B17r 2  A6 9B              LDX   comp_f            ; get compare function flag
000B19r 2  D0 2C              BNE   LAB_1B2A          ; branch if compare function
000B1Br 2               
000B1Br 2  B0 79              BCS   LAB_1B78          ; go do functions
000B1Dr 2               
000B1Dr 2                                             ; else was <  TK_GT so is operator or lower
000B1Dr 2  69 0A              ADC   #TK_GT-TK_PLUS    ; add # of operators (+, -, *, /, ^, AND, OR or EOR)
000B1Fr 2  90 75              BCC   LAB_1B78          ; branch if < + operator
000B21r 2               
000B21r 2                                             ; carry was set so token was +, -, *, /, ^, AND, OR or EOR
000B21r 2  D0 07              BNE   LAB_1B0B          ; branch if not + token
000B23r 2               
000B23r 2  24 5F              BIT   Dtypef            ; test data type flag, $FF=string, $00=numeric
000B25r 2  10 03              BPL   LAB_1B0B          ; branch if not string
000B27r 2               
000B27r 2                                             ; will only be $00 if type is string and token was +
000B27r 2  4C rr rr           JMP   LAB_224D          ; add strings, string 1 is in descriptor des_pl, string 2
000B2Ar 2                                             ; is in line, and return
000B2Ar 2               
000B2Ar 2               LAB_1B0B
000B2Ar 2  85 71              STA   ut1_pl            ; save it
000B2Cr 2  0A                 ASL                     ; *2
000B2Dr 2  65 71              ADC   ut1_pl            ; *3
000B2Fr 2  A8                 TAY                     ; copy to index
000B30r 2               LAB_1B13
000B30r 2  68                 PLA                     ; pull previous precedence
000B31r 2  D9 rr rr           CMP   LAB_OPPT,Y        ; compare with precedence byte
000B34r 2  B0 65              BCS   LAB_1B7D          ; branch if A >=
000B36r 2               
000B36r 2  20 rr rr           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
000B39r 2               LAB_1B1C
000B39r 2  48                 PHA                     ; save precedence
000B3Ar 2               LAB_1B1D
000B3Ar 2  20 rr rr           JSR   LAB_1B43          ; get vector, execute function then continue evaluation
000B3Dr 2  68                 PLA                     ; restore precedence
000B3Er 2  A4 99              LDY   prstk             ; get precedence stacked flag
000B40r 2  10 19              BPL   LAB_1B3C          ; branch if stacked values
000B42r 2               
000B42r 2  AA                 TAX                     ; copy precedence (set flags)
000B43r 2  F0 76              BEQ   LAB_1B9D          ; exit if done
000B45r 2               
000B45r 2  D0 5D              BNE   LAB_1B86          ; else pop FAC2 and return, branch always
000B47r 2               
000B47r 2               LAB_1B2A
000B47r 2  26 5F              ROL   Dtypef            ; shift data type flag into Cb
000B49r 2  8A                 TXA                     ; copy compare function flag
000B4Ar 2  85 5F              STA   Dtypef            ; clear data type flag, X is 0xxx xxxx
000B4Cr 2  2A                 ROL                     ; shift data type into compare function byte b0
000B4Dr 2  A6 C3              LDX   Bpntrl            ; get BASIC execute pointer low byte
000B4Fr 2  D0 02              BNE   LAB_1B34          ; branch if no underflow
000B51r 2               
000B51r 2  C6 C4              DEC   Bpntrh            ; else decrement BASIC execute pointer high byte
000B53r 2               LAB_1B34
000B53r 2  C6 C3              DEC   Bpntrl            ; decrement BASIC execute pointer low byte
000B55r 2               TK_LT_PLUS  = TK_LT-TK_PLUS
000B55r 2  A0 24              LDY   #TK_LT_PLUS*3     ; set offset to last operator entry
000B57r 2  85 9B              STA   comp_f            ; save new compare function flag
000B59r 2  D0 D5              BNE   LAB_1B13          ; branch always
000B5Br 2               
000B5Br 2               LAB_1B3C
000B5Br 2  D9 rr rr           CMP   LAB_OPPT,Y        ;.compare with stacked function precedence
000B5Er 2  B0 44              BCS   LAB_1B86          ; branch if A >=, pop FAC2 and return
000B60r 2               
000B60r 2  90 D7              BCC   LAB_1B1C          ; branch always
000B62r 2               
000B62r 2               ;.get vector, execute function then continue evaluation
000B62r 2               
000B62r 2               LAB_1B43
000B62r 2  B9 rr rr           LDA   LAB_OPPT+2,Y      ; get function vector high byte
000B65r 2  48                 PHA                     ; onto stack
000B66r 2  B9 rr rr           LDA   LAB_OPPT+1,Y      ; get function vector low byte
000B69r 2  48                 PHA                     ; onto stack
000B6Ar 2                                             ; now push sign, round FAC1 and put on stack
000B6Ar 2               ; *** begin patch  2.22p5.3   potential return address -$100 (page not incremented) ***
000B6Ar 2               ; *** add
000B6Ar 2               ; note MB: Unable to port to ca65 assembly
000B6Ar 2               ;   .IF [* & $FF] == $FD
000B6Ar 2               ;      NOP                     ; return address of JSR +1 (on  next page)
000B6Ar 2               ;   .ENDIF
000B6Ar 2               ; *** end   patch  2.22p5.3   potential return address -$100 (page not incremented) ***
000B6Ar 2  20 rr rr           JSR   LAB_1B5B          ; function will return here, then the next RTS will call
000B6Dr 2                                             ; the function
000B6Dr 2  A5 9B              LDA   comp_f            ; get compare function flag
000B6Fr 2  48                 PHA                     ; push compare evaluation byte
000B70r 2  B9 rr rr           LDA   LAB_OPPT,Y        ; get precedence byte
000B73r 2  4C rr rr           JMP   LAB_1ACC          ; continue evaluating expression
000B76r 2               
000B76r 2               LAB_1B53
000B76r 2  4C rr rr           JMP   LAB_SNER          ; do syntax error then warm start
000B79r 2               
000B79r 2               ; push sign, round FAC1 and put on stack
000B79r 2               
000B79r 2               LAB_1B5B
000B79r 2  68                 PLA                     ; get return addr low byte
000B7Ar 2  85 71              STA   ut1_pl            ; save it
000B7Cr 2  E6 71              INC   ut1_pl            ; increment it (was ret-1 pushed? yes!)
000B7Er 2                                             ; note! no check is made on the high byte! if the calling
000B7Er 2                                             ; routine assembles to a page edge then this all goes
000B7Er 2                                             ; horribly wrong !!!
000B7Er 2  68                 PLA                     ; get return addr high byte
000B7Fr 2  85 72              STA   ut1_ph            ; save it
000B81r 2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
000B83r 2  48                 PHA                     ; push sign
000B84r 2               
000B84r 2               ; round FAC1 and put on stack
000B84r 2               
000B84r 2               ; *** begin patch  2.22p5.1   TO expression may get sign bit flipped
000B84r 2               ; *** replace
000B84r 2               ;LAB_1B66
000B84r 2               ;      JSR   LAB_27BA          ; round FAC1
000B84r 2               ; *** with
000B84r 2  20 rr rr           JSR   LAB_27BA          ; round FAC1
000B87r 2               LAB_1B66
000B87r 2               ; *** end   patch  2.22p5.1   TO expression may get sign bit flipped
000B87r 2  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
000B89r 2  48                 PHA                     ; push on stack
000B8Ar 2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
000B8Cr 2  48                 PHA                     ; push on stack
000B8Dr 2  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
000B8Fr 2  48                 PHA                     ; push on stack
000B90r 2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
000B92r 2  48                 PHA                     ; push on stack
000B93r 2  6C 71 00           JMP   (ut1_pl)          ; return, sort of
000B96r 2               
000B96r 2               ; do functions
000B96r 2               
000B96r 2               LAB_1B78
000B96r 2  A0 FF              LDY   #$FF              ; flag function
000B98r 2  68                 PLA                     ; pull precedence byte
000B99r 2               LAB_1B7B
000B99r 2  F0 20              BEQ   LAB_1B9D          ; exit if done
000B9Br 2               
000B9Br 2               LAB_1B7D
000B9Br 2  C9 64              CMP   #$64              ; compare previous precedence with $64
000B9Dr 2  F0 03              BEQ   LAB_1B84          ; branch if was $64 (< function)
000B9Fr 2               
000B9Fr 2  20 rr rr           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
000BA2r 2               LAB_1B84
000BA2r 2  84 99              STY   prstk             ; save precedence stacked flag
000BA4r 2               
000BA4r 2                                             ; pop FAC2 and return
000BA4r 2               LAB_1B86
000BA4r 2  68                 PLA                     ; pop byte
000BA5r 2  4A                 LSR                     ; shift out comparison evaluation lowest bit
000BA6r 2  85 63              STA   Cflag             ; save comparison evaluation flag
000BA8r 2  68                 PLA                     ; pop exponent
000BA9r 2  85 B3              STA   FAC2_e            ; save FAC2 exponent
000BABr 2  68                 PLA                     ; pop mantissa1
000BACr 2  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
000BAEr 2  68                 PLA                     ; pop mantissa2
000BAFr 2  85 B5              STA   FAC2_2            ; save FAC2 mantissa2
000BB1r 2  68                 PLA                     ; pop mantissa3
000BB2r 2  85 B6              STA   FAC2_3            ; save FAC2 mantissa3
000BB4r 2  68                 PLA                     ; pop sign
000BB5r 2  85 B7              STA   FAC2_s            ; save FAC2 sign (b7)
000BB7r 2  45 B0              EOR   FAC1_s            ; EOR FAC1 sign (b7)
000BB9r 2  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
000BBBr 2               LAB_1B9D
000BBBr 2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
000BBDr 2  60                 RTS
000BBEr 2               
000BBEr 2               ; print "..." string to string util area
000BBEr 2               
000BBEr 2               LAB_1BC1
000BBEr 2  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
000BC0r 2  A4 C4              LDY   Bpntrh            ; get BASIC execute pointer high byte
000BC2r 2  69 00              ADC   #$00              ; add carry to low byte
000BC4r 2  90 01              BCC   LAB_1BCA          ; branch if no overflow
000BC6r 2               
000BC6r 2  C8                 INY                     ; increment high byte
000BC7r 2               LAB_1BCA
000BC7r 2  20 rr rr           JSR   LAB_20AE          ; print " terminated string to Sutill/Sutilh
000BCAr 2  4C rr rr           JMP   LAB_23F3          ; restore BASIC execute pointer from temp and return
000BCDr 2               
000BCDr 2               ; get value from line
000BCDr 2               
000BCDr 2               LAB_GVAL
000BCDr 2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
000BD0r 2  B0 03              BCS   LAB_1BAC          ; branch if not numeric character
000BD2r 2               
000BD2r 2                                             ; else numeric string found (e.g. 123)
000BD2r 2               LAB_1BA9
000BD2r 2  4C rr rr           JMP   LAB_2887          ; get FAC1 from string and return
000BD5r 2               
000BD5r 2               ; get value from line .. continued
000BD5r 2               
000BD5r 2                                             ; wasn't a number so ..
000BD5r 2               LAB_1BAC
000BD5r 2  AA                 TAX                     ; set the flags
000BD6r 2  30 2F              BMI   LAB_1BD0          ; if -ve go test token values
000BD8r 2               
000BD8r 2                                             ; else it is either a string, number, variable or (<expr>)
000BD8r 2  C9 24              CMP   #'$'              ; compare with "$"
000BDAr 2  F0 F6              BEQ   LAB_1BA9          ; branch if "$", hex number
000BDCr 2               
000BDCr 2  C9 25              CMP   #'%'              ; else compare with "%"
000BDEr 2  F0 F2              BEQ   LAB_1BA9          ; branch if "%", binary number
000BE0r 2               
000BE0r 2  C9 2E              CMP   #'.'              ; compare with "."
000BE2r 2  F0 EE              BEQ   LAB_1BA9          ; if so get FAC1 from string and return (e.g. was .123)
000BE4r 2               
000BE4r 2                                             ; it wasn't any sort of number so ..
000BE4r 2  C9 22              CMP   #$22              ; compare with "
000BE6r 2  F0 D6              BEQ   LAB_1BC1          ; branch if open quote
000BE8r 2               
000BE8r 2                                             ; wasn't any sort of number so ..
000BE8r 2               
000BE8r 2               ; evaluate expression within parentheses
000BE8r 2               
000BE8r 2  C9 28              CMP   #'('              ; compare with "("
000BEAr 2  D0 5B              BNE   LAB_1C18          ; if not "(" get (var), return value in FAC1 and $ flag
000BECr 2               
000BECr 2               LAB_1BF7
000BECr 2  20 rr rr           JSR   LAB_EVEZ          ; evaluate expression, no decrement
000BEFr 2               
000BEFr 2               ; all the 'scan for' routines return the character after the sought character
000BEFr 2               
000BEFr 2               ; scan for ")" , else do syntax error then warm start
000BEFr 2               
000BEFr 2               LAB_1BFB
000BEFr 2  A9 29              LDA   #$29              ; load A with ")"
000BF1r 2               
000BF1r 2               ; scan for CHR$(A) , else do syntax error then warm start
000BF1r 2               
000BF1r 2               LAB_SCCA
000BF1r 2  A0 00              LDY   #$00              ; clear index
000BF3r 2  D1 C3              CMP   (Bpntrl),Y        ; check next byte is = A
000BF5r 2  D0 0B              BNE   LAB_SNER          ; if not do syntax error then warm start
000BF7r 2               
000BF7r 2  4C BC 00           JMP   LAB_IGBY          ; increment and scan memory then return
000BFAr 2               
000BFAr 2               ; scan for "(" , else do syntax error then warm start
000BFAr 2               
000BFAr 2               LAB_1BFE
000BFAr 2  A9 28              LDA   #$28              ; load A with "("
000BFCr 2  D0 F3              BNE   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
000BFEr 2                                             ; (branch always)
000BFEr 2               
000BFEr 2               ; scan for "," , else do syntax error then warm start
000BFEr 2               
000BFEr 2               LAB_1C01
000BFEr 2  A9 2C              LDA   #$2C              ; load A with ","
000C00r 2  D0 EF              BNE   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
000C02r 2                                             ; (branch always)
000C02r 2               
000C02r 2               ; syntax error then warm start
000C02r 2               
000C02r 2               LAB_SNER
000C02r 2  A2 02              LDX   #$02              ; error code $02 ("Syntax" error)
000C04r 2  4C rr rr           JMP   LAB_XERR          ; do error #X, then warm start
000C07r 2               
000C07r 2               ; get value from line .. continued
000C07r 2               ; do tokens
000C07r 2               
000C07r 2               LAB_1BD0
000C07r 2  C9 B7              CMP   #TK_MINUS         ; compare with token for -
000C09r 2  F0 29              BEQ   LAB_1C11          ; branch if - token (do set-up for functions)
000C0Br 2               
000C0Br 2                                             ; wasn't -n so ..
000C0Br 2  C9 B6              CMP   #TK_PLUS          ; compare with token for +
000C0Dr 2  F0 BE              BEQ   LAB_GVAL          ; branch if + token (+n = n so ignore leading +)
000C0Fr 2               
000C0Fr 2  C9 B1              CMP   #TK_NOT           ; compare with token for NOT
000C11r 2  D0 13              BNE   LAB_1BE7          ; branch if not token for NOT
000C13r 2               
000C13r 2                                             ; was NOT token
000C13r 2               TK_EQUAL_PLUS     = TK_EQUAL-TK_PLUS
000C13r 2  A0 21              LDY   #TK_EQUAL_PLUS*3  ; offset to NOT function
000C15r 2  D0 1F              BNE   LAB_1C13          ; do set-up for function then execute (branch always)
000C17r 2               
000C17r 2               ; do = compare
000C17r 2               
000C17r 2               LAB_EQUAL
000C17r 2  20 rr rr           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
000C1Ar 2  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
000C1Cr 2  49 FF              EOR   #$FF              ; invert it
000C1Er 2  A8                 TAY                     ; copy it
000C1Fr 2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
000C21r 2  49 FF              EOR   #$FF              ; invert it
000C23r 2  4C rr rr           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
000C26r 2               
000C26r 2               ; get value from line .. continued
000C26r 2               
000C26r 2                                             ; wasn't +, -, or NOT so ..
000C26r 2               LAB_1BE7
000C26r 2  C9 AE              CMP   #TK_FN            ; compare with token for FN
000C28r 2  D0 03              BNE   LAB_1BEE          ; branch if not token for FN
000C2Ar 2               
000C2Ar 2  4C rr rr           JMP   LAB_201E          ; go evaluate FNx
000C2Dr 2               
000C2Dr 2               ; get value from line .. continued
000C2Dr 2               
000C2Dr 2                                             ; wasn't +, -, NOT or FN so ..
000C2Dr 2               LAB_1BEE
000C2Dr 2  E9 C3              SBC   #TK_SGN           ; subtract with token for SGN
000C2Fr 2  B0 27              BCS   LAB_1C27          ; if a function token go do it
000C31r 2               
000C31r 2  4C rr rr           JMP   LAB_SNER          ; else do syntax error
000C34r 2               
000C34r 2               ; set-up for functions
000C34r 2               
000C34r 2               LAB_1C11
000C34r 2               TK_GT_PLUS  = TK_GT-TK_PLUS
000C34r 2  A0 1E              LDY   #TK_GT_PLUS*3     ; set offset from base to > operator
000C36r 2               LAB_1C13
000C36r 2  68                 PLA                     ; dump return address low byte
000C37r 2               ; *** begin patch  2.22p5.4  concatenate MINUS or NOT() crashes EhBASIC  ***
000C37r 2               ; *** replace
000C37r 2               ;      PLA                     ; dump return address high byte
000C37r 2               ;      JMP   LAB_1B1D          ; execute function then continue evaluation
000C37r 2               ; *** with
000C37r 2  AA                 TAX                     ; save to trap concatenate
000C38r 2  68                 PLA                     ; dump return address high byte
000C39r 2  E0 rr              CPX   #<(LAB_224Da+2)   ; from concatenate low return address?
000C3Br 2  D0 04              BNE   LAB_1C13b         ; No - continue!
000C3Dr 2  C9 rr              CMP   #>(LAB_224Da+2)   ; from concatenate high return address?
000C3Fr 2  F0 03              BEQ   LAB_1C13a         ; Yes - error!
000C41r 2               LAB_1C13b
000C41r 2  4C rr rr           JMP   LAB_1B1D          ; execute function then continue evaluation
000C44r 2               LAB_1C13a
000C44r 2  4C rr rr           JMP   LAB_1ABC          ; throw "type mismatch error" then warm start
000C47r 2               ; *** end   patch  2.22p5.4  concatenate MINUS or NOT() crashes EhBASIC  ***
000C47r 2               
000C47r 2               ; variable name set-up
000C47r 2               ; get (var), return value in FAC_1 and $ flag
000C47r 2               
000C47r 2               LAB_1C18
000C47r 2  20 rr rr           JSR   LAB_GVAR          ; get (var) address
000C4Ar 2  85 AE              STA   FAC1_2            ; save address low byte in FAC1 mantissa2
000C4Cr 2  84 AF              STY   FAC1_3            ; save address high byte in FAC1 mantissa3
000C4Er 2  A6 5F              LDX   Dtypef            ; get data type flag, $FF=string, $00=numeric
000C50r 2  30 03              BMI   LAB_1C25          ; if string then return (does RTS)
000C52r 2               
000C52r 2               LAB_1C24
000C52r 2  4C rr rr           JMP   LAB_UFAC          ; unpack memory (AY) into FAC1
000C55r 2               
000C55r 2               LAB_1C25
000C55r 2               ; *** begin patch  string pointer high byte trashed when moved to stack
000C55r 2               ; *** add
000C55r 2  46 B9              LSR   FAC1_r            ; clear bit 7 (<$80) = do not round up
000C57r 2               ; *** end patch
000C57r 2  60                 RTS
000C58r 2               
000C58r 2               ; get value from line .. continued
000C58r 2               ; only functions left so ..
000C58r 2               
000C58r 2               ; set up function references
000C58r 2               
000C58r 2               ; new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
000C58r 2               ; to process function calls. now the function vector is computed and pushed on the stack
000C58r 2               ; and the preprocess offset is read. if the preprocess offset is non zero then the vector
000C58r 2               ; is calculated and the routine called, if not this routine just does RTS. whichever
000C58r 2               ; happens the RTS at the end of this routine, or the end of the preprocess routine, calls
000C58r 2               ; the function code
000C58r 2               
000C58r 2               ; this also removes some less than elegant code that was used to bypass type checking
000C58r 2               ; for functions that returned strings
000C58r 2               
000C58r 2               LAB_1C27
000C58r 2  0A                 ASL                     ; *2 (2 bytes per function address)
000C59r 2  A8                 TAY                     ; copy to index
000C5Ar 2               
000C5Ar 2  B9 rr rr           LDA   LAB_FTBM,Y        ; get function jump vector high byte
000C5Dr 2  48                 PHA                     ; push functions jump vector high byte
000C5Er 2  B9 rr rr           LDA   LAB_FTBL,Y        ; get function jump vector low byte
000C61r 2  48                 PHA                     ; push functions jump vector low byte
000C62r 2               
000C62r 2  B9 rr rr           LDA   LAB_FTPM,Y        ; get function pre process vector high byte
000C65r 2  F0 05              BEQ   LAB_1C56          ; skip pre process if null vector
000C67r 2               
000C67r 2  48                 PHA                     ; push functions pre process vector high byte
000C68r 2  B9 rr rr           LDA   LAB_FTPL,Y        ; get function pre process vector low byte
000C6Br 2  48                 PHA                     ; push functions pre process vector low byte
000C6Cr 2               
000C6Cr 2               LAB_1C56
000C6Cr 2  60                 RTS                     ; do function, or pre process, call
000C6Dr 2               
000C6Dr 2               ; process string expression in parenthesis
000C6Dr 2               
000C6Dr 2               LAB_PPFS
000C6Dr 2  20 rr rr           JSR   LAB_1BF7          ; process expression in parenthesis
000C70r 2  4C rr rr           JMP   LAB_CTST          ; check if source is string then do function,
000C73r 2                                             ; else do type mismatch
000C73r 2               
000C73r 2               ; process numeric expression in parenthesis
000C73r 2               
000C73r 2               LAB_PPFN
000C73r 2  20 rr rr           JSR   LAB_1BF7          ; process expression in parenthesis
000C76r 2  4C rr rr           JMP   LAB_CTNM          ; check if source is numeric then do function,
000C79r 2                                             ; else do type mismatch
000C79r 2               
000C79r 2               ; set numeric data type and increment BASIC execute pointer
000C79r 2               
000C79r 2               LAB_PPBI
000C79r 2  46 5F              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
000C7Br 2  4C BC 00           JMP   LAB_IGBY          ; increment and scan memory then do function
000C7Er 2               
000C7Er 2               ; process string for LEFT$, RIGHT$ or MID$
000C7Er 2               
000C7Er 2               LAB_LRMS
000C7Er 2  20 rr rr           JSR   LAB_EVEZ          ; evaluate (should be string) expression
000C81r 2  20 rr rr           JSR   LAB_1C01          ; scan for ",", else do syntax error then warm start
000C84r 2  20 rr rr           JSR   LAB_CTST          ; check if source is string, else do type mismatch
000C87r 2               
000C87r 2  68                 PLA                     ; get function jump vector low byte
000C88r 2  AA                 TAX                     ; save functions jump vector low byte
000C89r 2  68                 PLA                     ; get function jump vector high byte
000C8Ar 2  A8                 TAY                     ; save functions jump vector high byte
000C8Br 2  A5 AF              LDA   des_ph            ; get descriptor pointer high byte
000C8Dr 2  48                 PHA                     ; push string pointer high byte
000C8Er 2  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
000C90r 2  48                 PHA                     ; push string pointer low byte
000C91r 2  98                 TYA                     ; get function jump vector high byte back
000C92r 2  48                 PHA                     ; save functions jump vector high byte
000C93r 2  8A                 TXA                     ; get function jump vector low byte back
000C94r 2  48                 PHA                     ; save functions jump vector low byte
000C95r 2  20 rr rr           JSR   LAB_GTBY          ; get byte parameter
000C98r 2  8A                 TXA                     ; copy byte parameter to A
000C99r 2  60                 RTS                     ; go do function
000C9Ar 2               
000C9Ar 2               ; process numeric expression(s) for BIN$ or HEX$
000C9Ar 2               
000C9Ar 2               LAB_BHSS
000C9Ar 2  20 rr rr           JSR   LAB_EVEZ          ; process expression
000C9Dr 2  20 rr rr           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
000CA0r 2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
000CA2r 2  C9 98              CMP   #$98              ; compare with exponent = 2^24
000CA4r 2  B0 20              BCS   LAB_BHER          ; branch if n>=2^24 (is too big)
000CA6r 2               
000CA6r 2  20 rr rr           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
000CA9r 2  A2 02              LDX   #$02              ; 3 bytes to do
000CABr 2               LAB_CFAC
000CABr 2  B5 AD              LDA   FAC1_1,X          ; get byte from FAC1
000CADr 2  95 11              STA   nums_1,X          ; save byte to temp
000CAFr 2  CA                 DEX                     ; decrement index
000CB0r 2  10 F9              BPL   LAB_CFAC          ; copy FAC1 mantissa to temp
000CB2r 2               
000CB2r 2  20 C2 00           JSR   LAB_GBYT          ; get next BASIC byte
000CB5r 2  A2 00              LDX   #$00              ; set default to no leading "0"s
000CB7r 2  C9 29              CMP   #')'              ; compare with close bracket
000CB9r 2  F0 0A              BEQ   LAB_1C54          ; if ")" go do rest of function
000CBBr 2               
000CBBr 2  20 rr rr           JSR   LAB_SCGB          ; scan for "," and get byte
000CBEr 2  20 C2 00           JSR   LAB_GBYT          ; get last byte back
000CC1r 2  C9 29              CMP   #')'              ; is next character )
000CC3r 2  D0 01              BNE   LAB_BHER          ; if not ")" go do error
000CC5r 2               
000CC5r 2               LAB_1C54
000CC5r 2  60                 RTS                     ; else do function
000CC6r 2               
000CC6r 2               LAB_BHER
000CC6r 2  4C rr rr           JMP   LAB_FCER          ; do function call error then warm start
000CC9r 2               
000CC9r 2               ; perform EOR
000CC9r 2               
000CC9r 2               ; added operator format is the same as AND or OR, precedence is the same as OR
000CC9r 2               
000CC9r 2               ; this bit worked first time but it took a while to sort out the operator table
000CC9r 2               ; pointers and offsets afterwards!
000CC9r 2               
000CC9r 2               LAB_EOR
000CC9r 2  20 rr rr           JSR   GetFirst          ; get first integer expression (no sign check)
000CCCr 2  45 5B              EOR   XOAw_l            ; EOR with expression 1 low byte
000CCEr 2  A8                 TAY                     ; save in Y
000CCFr 2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
000CD1r 2  45 5C              EOR   XOAw_h            ; EOR with expression 1 high byte
000CD3r 2  4C rr rr           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
000CD6r 2               
000CD6r 2               ; perform OR
000CD6r 2               
000CD6r 2               LAB_OR
000CD6r 2  20 rr rr           JSR   GetFirst          ; get first integer expression (no sign check)
000CD9r 2  05 5B              ORA   XOAw_l            ; OR with expression 1 low byte
000CDBr 2  A8                 TAY                     ; save in Y
000CDCr 2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
000CDEr 2  05 5C              ORA   XOAw_h            ; OR with expression 1 high byte
000CE0r 2  4C rr rr           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
000CE3r 2               
000CE3r 2               ; perform AND
000CE3r 2               
000CE3r 2               LAB_AND
000CE3r 2  20 rr rr           JSR   GetFirst          ; get first integer expression (no sign check)
000CE6r 2  25 5B              AND   XOAw_l            ; AND with expression 1 low byte
000CE8r 2  A8                 TAY                     ; save in Y
000CE9r 2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
000CEBr 2  25 5C              AND   XOAw_h            ; AND with expression 1 high byte
000CEDr 2  4C rr rr           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
000CF0r 2               
000CF0r 2               ; get first value for OR, AND or EOR
000CF0r 2               
000CF0r 2               GetFirst
000CF0r 2  20 rr rr           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
000CF3r 2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
000CF5r 2  85 5C              STA   XOAw_h            ; save it
000CF7r 2  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
000CF9r 2  85 5B              STA   XOAw_l            ; save it
000CFBr 2  20 rr rr           JSR   LAB_279B          ; copy FAC2 to FAC1 (get 2nd value in expression)
000CFEr 2  20 rr rr           JSR   LAB_EVIR          ; evaluate integer expression (no sign check)
000D01r 2  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
000D03r 2               LAB_1C95
000D03r 2  60                 RTS
000D04r 2               
000D04r 2               ; perform comparisons
000D04r 2               
000D04r 2               ; do < compare
000D04r 2               
000D04r 2               LAB_LTHAN
000D04r 2  20 rr rr           JSR   LAB_CKTM          ; type match check, set C for string
000D07r 2  B0 13              BCS   LAB_1CAE          ; branch if string
000D09r 2               
000D09r 2                                             ; do numeric < compare
000D09r 2  A5 B7              LDA   FAC2_s            ; get FAC2 sign (b7)
000D0Br 2  09 7F              ORA   #$7F              ; set all non sign bits
000D0Dr 2  25 B4              AND   FAC2_1            ; and FAC2 mantissa1 (AND in sign bit)
000D0Fr 2  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
000D11r 2  A9 B3              LDA   #<FAC2_e          ; set pointer low byte to FAC2
000D13r 2  A0 00              LDY   #>FAC2_e          ; set pointer high byte to FAC2
000D15r 2  20 rr rr           JSR   LAB_27F8          ; compare FAC1 with FAC2 (AY)
000D18r 2  AA                 TAX                     ; copy result
000D19r 2  4C rr rr           JMP   LAB_1CE1          ; go evaluate result
000D1Cr 2               
000D1Cr 2                                             ; do string < compare
000D1Cr 2               LAB_1CAE
000D1Cr 2  46 5F              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
000D1Er 2  C6 9B              DEC   comp_f            ; clear < bit in compare function flag
000D20r 2  20 rr rr           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
000D23r 2                                             ; space returns with A = length, X=pointer low byte,
000D23r 2                                             ; Y=pointer high byte
000D23r 2  85 AC              STA   str_ln            ; save length
000D25r 2  86 AD              STX   str_pl            ; save string pointer low byte
000D27r 2  84 AE              STY   str_ph            ; save string pointer high byte
000D29r 2  A5 B5              LDA   FAC2_2            ; get descriptor pointer low byte
000D2Br 2  A4 B6              LDY   FAC2_3            ; get descriptor pointer high byte
000D2Dr 2  20 rr rr           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
000D30r 2                                             ; returns with A = length, X=pointer low byte,
000D30r 2                                             ; Y=pointer high byte
000D30r 2  86 B5              STX   FAC2_2            ; save string pointer low byte
000D32r 2  84 B6              STY   FAC2_3            ; save string pointer high byte
000D34r 2  AA                 TAX                     ; copy length
000D35r 2  38                 SEC                     ; set carry for subtract
000D36r 2  E5 AC              SBC   str_ln            ; subtract string 1 length
000D38r 2  F0 08              BEQ   LAB_1CD6          ; branch if str 1 length = string 2 length
000D3Ar 2               
000D3Ar 2  A9 01              LDA   #$01              ; set str 1 length > string 2 length
000D3Cr 2  90 04              BCC   LAB_1CD6          ; branch if so
000D3Er 2               
000D3Er 2  A6 AC              LDX   str_ln            ; get string 1 length
000D40r 2  A9 FF              LDA   #$FF              ; set str 1 length < string 2 length
000D42r 2               LAB_1CD6
000D42r 2  85 B0              STA   FAC1_s            ; save length compare
000D44r 2  A0 FF              LDY   #$FF              ; set index
000D46r 2  E8                 INX                     ; adjust for loop
000D47r 2               LAB_1CDB
000D47r 2  C8                 INY                     ; increment index
000D48r 2  CA                 DEX                     ; decrement count
000D49r 2  D0 07              BNE   LAB_1CE6          ; branch if still bytes to do
000D4Br 2               
000D4Br 2  A6 B0              LDX   FAC1_s            ; get length compare back
000D4Dr 2               LAB_1CE1
000D4Dr 2  30 0F              BMI   LAB_1CF2          ; branch if str 1 < str 2
000D4Fr 2               
000D4Fr 2  18                 CLC                     ; flag str 1 <= str 2
000D50r 2  90 0C              BCC   LAB_1CF2          ; go evaluate result
000D52r 2               
000D52r 2               LAB_1CE6
000D52r 2  B1 B5              LDA   (FAC2_2),Y        ; get string 2 byte
000D54r 2  D1 AD              CMP   (FAC1_1),Y        ; compare with string 1 byte
000D56r 2  F0 EF              BEQ   LAB_1CDB          ; loop if bytes =
000D58r 2               
000D58r 2  A2 FF              LDX   #$FF              ; set str 1 < string 2
000D5Ar 2  B0 02              BCS   LAB_1CF2          ; branch if so
000D5Cr 2               
000D5Cr 2  A2 01              LDX   #$01              ;  set str 1 > string 2
000D5Er 2               LAB_1CF2
000D5Er 2  E8                 INX                     ; x = 0, 1 or 2
000D5Fr 2  8A                 TXA                     ; copy to A
000D60r 2  2A                 ROL                     ; *2 (1, 2 or 4)
000D61r 2  25 63              AND   Cflag             ; AND with comparison evaluation flag
000D63r 2  F0 02              BEQ   LAB_1CFB          ; branch if 0 (compare is false)
000D65r 2               
000D65r 2  A9 FF              LDA   #$FF              ; else set result true
000D67r 2               LAB_1CFB
000D67r 2  4C rr rr           JMP   LAB_27DB          ; save A as integer byte and return
000D6Ar 2               
000D6Ar 2               LAB_1CFE
000D6Ar 2  20 rr rr           JSR   LAB_1C01          ; scan for ",", else do syntax error then warm start
000D6Dr 2               
000D6Dr 2               ; perform DIM
000D6Dr 2               
000D6Dr 2               LAB_DIM
000D6Dr 2  AA                 TAX                     ; copy "DIM" flag to X
000D6Er 2  20 rr rr           JSR   LAB_1D10          ; search for variable
000D71r 2  20 C2 00           JSR   LAB_GBYT          ; scan memory
000D74r 2  D0 F4              BNE   LAB_1CFE          ; scan for "," and loop if not null
000D76r 2               
000D76r 2  60                 RTS
000D77r 2               
000D77r 2               ; perform << (left shift)
000D77r 2               
000D77r 2               LAB_LSHIFT
000D77r 2  20 rr rr           JSR   GetPair           ; get integer expression and byte (no sign check)
000D7Ar 2  A5 AE              LDA   FAC1_2            ; get expression high byte
000D7Cr 2  A6 78              LDX   TempB             ; get shift count
000D7Er 2  F0 22              BEQ   NoShift           ; branch if zero
000D80r 2               
000D80r 2  E0 10              CPX   #$10              ; compare bit count with 16d
000D82r 2  B0 23              BCS   TooBig            ; branch if >=
000D84r 2               
000D84r 2               Ls_loop
000D84r 2  06 AF              ASL   FAC1_3            ; shift low byte
000D86r 2  2A                 ROL                     ; shift high byte
000D87r 2  CA                 DEX                     ; decrement bit count
000D88r 2  D0 FA              BNE   Ls_loop           ; loop if shift not complete
000D8Ar 2               
000D8Ar 2  A4 AF              LDY   FAC1_3            ; get expression low byte
000D8Cr 2  4C rr rr           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
000D8Fr 2               
000D8Fr 2               ; perform >> (right shift)
000D8Fr 2               
000D8Fr 2               LAB_RSHIFT
000D8Fr 2  20 rr rr           JSR   GetPair           ; get integer expression and byte (no sign check)
000D92r 2  A5 AE              LDA   FAC1_2            ; get expression high byte
000D94r 2  A6 78              LDX   TempB             ; get shift count
000D96r 2  F0 0A              BEQ   NoShift           ; branch if zero
000D98r 2               
000D98r 2  E0 10              CPX   #$10              ; compare bit count with 16d
000D9Ar 2  B0 0B              BCS   TooBig            ; branch if >=
000D9Cr 2               
000D9Cr 2               Rs_loop
000D9Cr 2  4A                 LSR                     ; shift high byte
000D9Dr 2  66 AF              ROR   FAC1_3            ; shift low byte
000D9Fr 2  CA                 DEX                     ; decrement bit count
000DA0r 2  D0 FA              BNE   Rs_loop           ; loop if shift not complete
000DA2r 2               
000DA2r 2               NoShift
000DA2r 2  A4 AF              LDY   FAC1_3            ; get expression low byte
000DA4r 2  4C rr rr           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
000DA7r 2               
000DA7r 2               TooBig
000DA7r 2  A9 00              LDA   #$00              ; clear high byte
000DA9r 2  A8                 TAY                     ; copy to low byte
000DAAr 2  4C rr rr           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
000DADr 2               
000DADr 2               GetPair
000DADr 2  20 rr rr           JSR   LAB_EVBY          ; evaluate byte expression, result in X
000DB0r 2  86 78              STX   TempB             ; save it
000DB2r 2  20 rr rr           JSR   LAB_279B          ; copy FAC2 to FAC1 (get 2nd value in expression)
000DB5r 2  4C rr rr           JMP   LAB_EVIR          ; evaluate integer expression (no sign check)
000DB8r 2               
000DB8r 2               ; search for variable
000DB8r 2               
000DB8r 2               ; return pointer to variable in Cvaral/Cvarah
000DB8r 2               
000DB8r 2               LAB_GVAR
000DB8r 2  A2 00              LDX   #$00              ; set DIM flag = $00
000DBAr 2  20 C2 00           JSR   LAB_GBYT          ; scan memory (1st character)
000DBDr 2               LAB_1D10
000DBDr 2  86 5E              STX   Defdim            ; save DIM flag
000DBFr 2               LAB_1D12
000DBFr 2  85 93              STA   Varnm1            ; save 1st character
000DC1r 2  29 7F              AND   #$7F              ; clear FN flag bit
000DC3r 2  20 rr rr           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
000DC6r 2  B0 03              BCS   LAB_1D1F          ; branch if ok
000DC8r 2               
000DC8r 2  4C rr rr           JMP   LAB_SNER          ; else syntax error then warm start
000DCBr 2               
000DCBr 2                                             ; was variable name so ..
000DCBr 2               LAB_1D1F
000DCBr 2  A2 00              LDX   #$00              ; clear 2nd character temp
000DCDr 2  86 5F              STX   Dtypef            ; clear data type flag, $FF=string, $00=numeric
000DCFr 2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory (2nd character)
000DD2r 2  90 05              BCC   LAB_1D2D          ; branch if character = "0"-"9" (ok)
000DD4r 2               
000DD4r 2                                             ; 2nd character wasn't "0" to "9" so ..
000DD4r 2  20 rr rr           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
000DD7r 2  90 0B              BCC   LAB_1D38          ; branch if <"A" or >"Z" (go check if string)
000DD9r 2               
000DD9r 2               LAB_1D2D
000DD9r 2  AA                 TAX                     ; copy 2nd character
000DDAr 2               
000DDAr 2                                             ; ignore further (valid) characters in the variable name
000DDAr 2               LAB_1D2E
000DDAr 2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory (3rd character)
000DDDr 2  90 FB              BCC   LAB_1D2E          ; loop if character = "0"-"9" (ignore)
000DDFr 2               
000DDFr 2  20 rr rr           JSR   LAB_CASC          ; check byte, return C=0 if<"A" or >"Z"
000DE2r 2  B0 F6              BCS   LAB_1D2E          ; loop if character = "A"-"Z" (ignore)
000DE4r 2               
000DE4r 2                                             ; check if string variable
000DE4r 2               LAB_1D38
000DE4r 2  C9 24              CMP   #'$'              ; compare with "$"
000DE6r 2  D0 0B              BNE   LAB_1D47          ; branch if not string
000DE8r 2               
000DE8r 2               ; to introduce a new variable type (% suffix for integers say) then this branch
000DE8r 2               ; will need to go to that check and then that branch, if it fails, go to LAB_1D47
000DE8r 2               
000DE8r 2                                             ; type is string
000DE8r 2  A9 FF              LDA   #$FF              ; set data type = string
000DEAr 2  85 5F              STA   Dtypef            ; set data type flag, $FF=string, $00=numeric
000DECr 2  8A                 TXA                     ; get 2nd character back
000DEDr 2  09 80              ORA   #$80              ; set top bit (indicate string var)
000DEFr 2  AA                 TAX                     ; copy back to 2nd character temp
000DF0r 2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
000DF3r 2               
000DF3r 2               ; after we have determined the variable type we need to come back here to determine
000DF3r 2               ; if it's an array of type. this would plug in a%(b[,c[,d]])) integer arrays nicely
000DF3r 2               
000DF3r 2               
000DF3r 2               LAB_1D47                      ; gets here with character after var name in A
000DF3r 2  86 94              STX   Varnm2            ; save 2nd character
000DF5r 2  05 61              ORA   Sufnxf            ; or with subscript/FNX flag (or FN name)
000DF7r 2  C9 28              CMP   #'('              ; compare with "("
000DF9r 2  D0 03              BNE   LAB_1D53          ; branch if not "("
000DFBr 2               
000DFBr 2  4C rr rr           JMP   LAB_1E17          ; go find, or make, array
000DFEr 2               
000DFEr 2               ; either find or create var
000DFEr 2               ; var name (1st two characters only!) is in Varnm1,Varnm2
000DFEr 2               
000DFEr 2                                             ; variable name wasn't var(... so look for plain var
000DFEr 2               LAB_1D53
000DFEr 2  A9 00              LDA   #$00              ; clear A
000E00r 2  85 61              STA   Sufnxf            ; clear subscript/FNX flag
000E02r 2  A5 7B              LDA   Svarl             ; get start of vars low byte
000E04r 2  A6 7C              LDX   Svarh             ; get start of vars high byte
000E06r 2  A0 00              LDY   #$00              ; clear index
000E08r 2               LAB_1D5D
000E08r 2  86 AB              STX   Vrschh            ; save search address high byte
000E0Ar 2               LAB_1D5F
000E0Ar 2  85 AA              STA   Vrschl            ; save search address low byte
000E0Cr 2  E4 7E              CPX   Sarryh            ; compare high address with var space end
000E0Er 2  D0 04              BNE   LAB_1D69          ; skip next compare if <>
000E10r 2               
000E10r 2                                             ; high addresses were = so compare low addresses
000E10r 2  C5 7D              CMP   Sarryl            ; compare low address with var space end
000E12r 2  F0 2C              BEQ   LAB_1D8B          ; if not found go make new var
000E14r 2               
000E14r 2               LAB_1D69
000E14r 2  A5 93              LDA   Varnm1            ; get 1st character of var to find
000E16r 2  D1 AA              CMP   (Vrschl),Y        ; compare with variable name 1st character
000E18r 2  D0 08              BNE   LAB_1D77          ; branch if no match
000E1Ar 2               
000E1Ar 2                                             ; 1st characters match so compare 2nd characters
000E1Ar 2  A5 94              LDA   Varnm2            ; get 2nd character of var to find
000E1Cr 2  C8                 INY                     ; index to point to variable name 2nd character
000E1Dr 2  D1 AA              CMP   (Vrschl),Y        ; compare with variable name 2nd character
000E1Fr 2  F0 69              BEQ   LAB_1DD7          ; branch if match (found var)
000E21r 2               
000E21r 2  88                 DEY                     ; else decrement index (now = $00)
000E22r 2               LAB_1D77
000E22r 2  18                 CLC                     ; clear carry for add
000E23r 2  A5 AA              LDA   Vrschl            ; get search address low byte
000E25r 2  69 06              ADC   #$06              ; +6 (offset to next var name)
000E27r 2  90 E1              BCC   LAB_1D5F          ; loop if no overflow to high byte
000E29r 2               
000E29r 2  E8                 INX                     ; else increment high byte
000E2Ar 2  D0 DC              BNE   LAB_1D5D          ; loop always (RAM doesn't extend to $FFFF !)
000E2Cr 2               
000E2Cr 2               ; check byte, return C=0 if<"A" or >"Z" or "a" to "z"
000E2Cr 2               
000E2Cr 2               LAB_CASC
000E2Cr 2  C9 61              CMP   #'a'              ; compare with "a"
000E2Er 2  B0 0A              BCS   LAB_1D83          ; go check <"z"+1
000E30r 2               
000E30r 2               ; check byte, return C=0 if<"A" or >"Z"
000E30r 2               
000E30r 2               LAB_1D82
000E30r 2  C9 41              CMP   #'A'              ; compare with "A"
000E32r 2  90 05              BCC   LAB_1D8A          ; exit if less
000E34r 2               
000E34r 2                                             ; carry is set
000E34r 2  E9 5B              SBC   #$5B              ; subtract "Z"+1
000E36r 2  38                 SEC                     ; set carry
000E37r 2  E9 A5              SBC   #$A5              ; subtract $A5 (restore byte)
000E39r 2                                             ; carry clear if byte>$5A
000E39r 2               LAB_1D8A
000E39r 2  60                 RTS
000E3Ar 2               
000E3Ar 2               LAB_1D83
000E3Ar 2  E9 7B              SBC   #$7B              ; subtract "z"+1
000E3Cr 2  38                 SEC                     ; set carry
000E3Dr 2  E9 85              SBC   #$85              ; subtract $85 (restore byte)
000E3Fr 2                                             ; carry clear if byte>$7A
000E3Fr 2  60                 RTS
000E40r 2               
000E40r 2                                             ; reached end of variable mem without match
000E40r 2                                             ; .. so create new variable
000E40r 2               LAB_1D8B
000E40r 2  68                 PLA                     ; pop return address low byte
000E41r 2  48                 PHA                     ; push return address low byte
000E42r 2               LAB_1C18p2  = LAB_1C18+2
000E42r 2  C9 rr              CMP   #<LAB_1C18p2      ; compare with expected calling routine return low byte
000E44r 2  D0 05              BNE   LAB_1D98          ; if not get (var) go create new var
000E46r 2               
000E46r 2               ; This will only drop through if the call was from LAB_1C18 and is only called
000E46r 2               ; from there if it is searching for a variable from the RHS of a LET a=b statement
000E46r 2               ; it prevents the creation of variables not assigned a value.
000E46r 2               
000E46r 2               ; value returned by this is either numeric zero (exponent byte is $00) or null string
000E46r 2               ; (descriptor length byte is $00). in fact a pointer to any $00 byte would have done.
000E46r 2               
000E46r 2               ; doing this saves 6 bytes of variable memory and 168 machine cycles of time
000E46r 2               
000E46r 2               ; this is where you would put the undefined variable error call e.g.
000E46r 2               
000E46r 2               ;                             ; variable doesn't exist so flag error
000E46r 2               ;     LDX   #$24              ; error code $24 ("undefined variable" error)
000E46r 2               ;     JMP   LAB_XERR          ; do error #X then warm start
000E46r 2               
000E46r 2               ; the above code has been tested and works a treat! (it replaces the three code lines
000E46r 2               ; below)
000E46r 2               
000E46r 2                                             ; else return dummy null value
000E46r 2  A9 rr              LDA   #<LAB_1D96        ; low byte point to $00,$00
000E48r 2                                             ; (uses part of misc constants table)
000E48r 2  A0 rr              LDY   #>LAB_1D96        ; high byte point to $00,$00
000E4Ar 2  60                 RTS
000E4Br 2               
000E4Br 2                                             ; create new numeric variable
000E4Br 2               LAB_1D98
000E4Br 2  A5 7D              LDA   Sarryl            ; get var mem end low byte
000E4Dr 2  A4 7E              LDY   Sarryh            ; get var mem end high byte
000E4Fr 2  85 AA              STA   Ostrtl            ; save old block start low byte
000E51r 2  84 AB              STY   Ostrth            ; save old block start high byte
000E53r 2  A5 7F              LDA   Earryl            ; get array mem end low byte
000E55r 2  A4 80              LDY   Earryh            ; get array mem end high byte
000E57r 2  85 A6              STA   Obendl            ; save old block end low byte
000E59r 2  84 A7              STY   Obendh            ; save old block end high byte
000E5Br 2  18                 CLC                     ; clear carry for add
000E5Cr 2  69 06              ADC   #$06              ; +6 (space for one var)
000E5Er 2  90 01              BCC   LAB_1DAE          ; branch if no overflow to high byte
000E60r 2               
000E60r 2  C8                 INY                     ; else increment high byte
000E61r 2               LAB_1DAE
000E61r 2  85 A4              STA   Nbendl            ; set new block end low byte
000E63r 2  84 A5              STY   Nbendh            ; set new block end high byte
000E65r 2  20 rr rr           JSR   LAB_11CF          ; open up space in memory
000E68r 2  A5 A4              LDA   Nbendl            ; get new start low byte
000E6Ar 2  A4 A5              LDY   Nbendh            ; get new start high byte (-$100)
000E6Cr 2  C8                 INY                     ; correct high byte
000E6Dr 2  85 7D              STA   Sarryl            ; save new var mem end low byte
000E6Fr 2  84 7E              STY   Sarryh            ; save new var mem end high byte
000E71r 2  A0 00              LDY   #$00              ; clear index
000E73r 2  A5 93              LDA   Varnm1            ; get var name 1st character
000E75r 2  91 AA              STA   (Vrschl),Y        ; save var name 1st character
000E77r 2  C8                 INY                     ; increment index
000E78r 2  A5 94              LDA   Varnm2            ; get var name 2nd character
000E7Ar 2  91 AA              STA   (Vrschl),Y        ; save var name 2nd character
000E7Cr 2  A9 00              LDA   #$00              ; clear A
000E7Er 2  C8                 INY                     ; increment index
000E7Fr 2  91 AA              STA   (Vrschl),Y        ; initialise var byte
000E81r 2  C8                 INY                     ; increment index
000E82r 2  91 AA              STA   (Vrschl),Y        ; initialise var byte
000E84r 2  C8                 INY                     ; increment index
000E85r 2  91 AA              STA   (Vrschl),Y        ; initialise var byte
000E87r 2  C8                 INY                     ; increment index
000E88r 2  91 AA              STA   (Vrschl),Y        ; initialise var byte
000E8Ar 2               
000E8Ar 2                                             ; found a match for var ((Vrschl) = ptr)
000E8Ar 2               LAB_1DD7
000E8Ar 2  A5 AA              LDA   Vrschl            ; get var address low byte
000E8Cr 2  18                 CLC                     ; clear carry for add
000E8Dr 2  69 02              ADC   #$02              ; +2 (offset past var name bytes)
000E8Fr 2  A4 AB              LDY   Vrschh            ; get var address high byte
000E91r 2  90 01              BCC   LAB_1DE1          ; branch if no overflow from add
000E93r 2               
000E93r 2  C8                 INY                     ; else increment high byte
000E94r 2               LAB_1DE1
000E94r 2  85 95              STA   Cvaral            ; save current var address low byte
000E96r 2  84 96              STY   Cvarah            ; save current var address high byte
000E98r 2  60                 RTS
000E99r 2               
000E99r 2               ; set-up array pointer (Adatal/h) to first element in array
000E99r 2               ; set Adatal,Adatah to Astrtl,Astrth+2*Dimcnt+#$05
000E99r 2               
000E99r 2               LAB_1DE6
000E99r 2  A5 5D              LDA   Dimcnt            ; get # of dimensions (1, 2 or 3)
000E9Br 2  0A                 ASL                     ; *2 (also clears the carry !)
000E9Cr 2  69 05              ADC   #$05              ; +5 (result is 7, 9 or 11 here)
000E9Er 2  65 AA              ADC   Astrtl            ; add array start pointer low byte
000EA0r 2  A4 AB              LDY   Astrth            ; get array pointer high byte
000EA2r 2  90 01              BCC   LAB_1DF2          ; branch if no overflow
000EA4r 2               
000EA4r 2  C8                 INY                     ; else increment high byte
000EA5r 2               LAB_1DF2
000EA5r 2  85 A4              STA   Adatal            ; save array data pointer low byte
000EA7r 2  84 A5              STY   Adatah            ; save array data pointer high byte
000EA9r 2  60                 RTS
000EAAr 2               
000EAAr 2               ; evaluate integer expression
000EAAr 2               
000EAAr 2               LAB_EVIN
000EAAr 2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
000EADr 2  20 rr rr           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
000EB0r 2                                             ; else do type mismatch
000EB0r 2               
000EB0r 2               ; evaluate integer expression (no check)
000EB0r 2               
000EB0r 2               LAB_EVPI
000EB0r 2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
000EB2r 2  30 0D              BMI   LAB_1E12          ; do function call error if -ve
000EB4r 2               
000EB4r 2               ; evaluate integer expression (no sign check)
000EB4r 2               
000EB4r 2               LAB_EVIR
000EB4r 2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
000EB6r 2  C9 90              CMP   #$90              ; compare with exponent = 2^16 (n>2^15)
000EB8r 2  90 09              BCC   LAB_1E14          ; branch if n<2^16 (is ok)
000EBAr 2               
000EBAr 2  A9 rr              LDA   #<LAB_1DF7        ; set pointer low byte to -32768
000EBCr 2  A0 rr              LDY   #>LAB_1DF7        ; set pointer high byte to -32768
000EBEr 2  20 rr rr           JSR   LAB_27F8          ; compare FAC1 with (AY)
000EC1r 2               LAB_1E12
000EC1r 2  D0 74              BNE   LAB_FCER          ; if <> do function call error then warm start
000EC3r 2               
000EC3r 2               LAB_1E14
000EC3r 2  4C rr rr           JMP   LAB_2831          ; convert FAC1 floating-to-fixed and return
000EC6r 2               
000EC6r 2               ; find or make array
000EC6r 2               
000EC6r 2               LAB_1E17
000EC6r 2  A5 5E              LDA   Defdim            ; get DIM flag
000EC8r 2  48                 PHA                     ; push it
000EC9r 2  A5 5F              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
000ECBr 2  48                 PHA                     ; push it
000ECCr 2  A0 00              LDY   #$00              ; clear dimensions count
000ECEr 2               
000ECEr 2               ; now get the array dimension(s) and stack it (them) before the data type and DIM flag
000ECEr 2               
000ECEr 2               LAB_1E1F
000ECEr 2  98                 TYA                     ; copy dimensions count
000ECFr 2  48                 PHA                     ; save it
000ED0r 2  A5 94              LDA   Varnm2            ; get array name 2nd byte
000ED2r 2  48                 PHA                     ; save it
000ED3r 2  A5 93              LDA   Varnm1            ; get array name 1st byte
000ED5r 2  48                 PHA                     ; save it
000ED6r 2  20 rr rr           JSR   LAB_EVIN          ; evaluate integer expression
000ED9r 2  68                 PLA                     ; pull array name 1st byte
000EDAr 2  85 93              STA   Varnm1            ; restore array name 1st byte
000EDCr 2  68                 PLA                     ; pull array name 2nd byte
000EDDr 2  85 94              STA   Varnm2            ; restore array name 2nd byte
000EDFr 2  68                 PLA                     ; pull dimensions count
000EE0r 2  A8                 TAY                     ; restore it
000EE1r 2  BA                 TSX                     ; copy stack pointer
000EE2r 2  BD 02 01           LDA   LAB_STAK+2,X      ; get DIM flag
000EE5r 2  48                 PHA                     ; push it
000EE6r 2  BD 01 01           LDA   LAB_STAK+1,X      ; get data type flag
000EE9r 2  48                 PHA                     ; push it
000EEAr 2  A5 AE              LDA   FAC1_2            ; get this dimension size high byte
000EECr 2  9D 02 01           STA   LAB_STAK+2,X      ; stack before flag bytes
000EEFr 2  A5 AF              LDA   FAC1_3            ; get this dimension size low byte
000EF1r 2  9D 01 01           STA   LAB_STAK+1,X      ; stack before flag bytes
000EF4r 2  C8                 INY                     ; increment dimensions count
000EF5r 2  20 C2 00           JSR   LAB_GBYT          ; scan memory
000EF8r 2  C9 2C              CMP   #','              ; compare with ","
000EFAr 2  F0 D2              BEQ   LAB_1E1F          ; if found go do next dimension
000EFCr 2               
000EFCr 2  84 5D              STY   Dimcnt            ; store dimensions count
000EFEr 2  20 rr rr           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
000F01r 2  68                 PLA                     ; pull data type flag
000F02r 2  85 5F              STA   Dtypef            ; restore data type flag, $FF=string, $00=numeric
000F04r 2  68                 PLA                     ; pull DIM flag
000F05r 2  85 5E              STA   Defdim            ; restore DIM flag
000F07r 2  A6 7D              LDX   Sarryl            ; get array mem start low byte
000F09r 2  A5 7E              LDA   Sarryh            ; get array mem start high byte
000F0Br 2               
000F0Br 2               ; now check to see if we are at the end of array memory (we would be if there were
000F0Br 2               ; no arrays).
000F0Br 2               
000F0Br 2               LAB_1E5C
000F0Br 2  86 AA              STX   Astrtl            ; save as array start pointer low byte
000F0Dr 2  85 AB              STA   Astrth            ; save as array start pointer high byte
000F0Fr 2  C5 80              CMP   Earryh            ; compare with array mem end high byte
000F11r 2  D0 04              BNE   LAB_1E68          ; branch if not reached array mem end
000F13r 2               
000F13r 2  E4 7F              CPX   Earryl            ; else compare with array mem end low byte
000F15r 2  F0 39              BEQ   LAB_1EA1          ; go build array if not found
000F17r 2               
000F17r 2                                             ; search for array
000F17r 2               LAB_1E68
000F17r 2  A0 00              LDY   #$00              ; clear index
000F19r 2  B1 AA              LDA   (Astrtl),Y        ; get array name first byte
000F1Br 2  C8                 INY                     ; increment index to second name byte
000F1Cr 2  C5 93              CMP   Varnm1            ; compare with this array name first byte
000F1Er 2  D0 06              BNE   LAB_1E77          ; branch if no match
000F20r 2               
000F20r 2  A5 94              LDA   Varnm2            ; else get this array name second byte
000F22r 2  D1 AA              CMP   (Astrtl),Y        ; compare with array name second byte
000F24r 2  F0 16              BEQ   LAB_1E8D          ; array found so branch
000F26r 2               
000F26r 2                                             ; no match
000F26r 2               LAB_1E77
000F26r 2  C8                 INY                     ; increment index
000F27r 2  B1 AA              LDA   (Astrtl),Y        ; get array size low byte
000F29r 2  18                 CLC                     ; clear carry for add
000F2Ar 2  65 AA              ADC   Astrtl            ; add array start pointer low byte
000F2Cr 2  AA                 TAX                     ; copy low byte to X
000F2Dr 2  C8                 INY                     ; increment index
000F2Er 2  B1 AA              LDA   (Astrtl),Y        ; get array size high byte
000F30r 2  65 AB              ADC   Astrth            ; add array mem pointer high byte
000F32r 2  90 D7              BCC   LAB_1E5C          ; if no overflow go check next array
000F34r 2               
000F34r 2               ; do array bounds error
000F34r 2               
000F34r 2               LAB_1E85
000F34r 2  A2 10              LDX   #$10              ; error code $10 ("Array bounds" error)
000F36r 2  2C                 .byte $2C               ; makes next bit BIT LAB_08A2
000F37r 2               
000F37r 2               ; do function call error
000F37r 2               
000F37r 2               LAB_FCER
000F37r 2  A2 08              LDX   #$08              ; error code $08 ("Function call" error)
000F39r 2               LAB_1E8A
000F39r 2  4C rr rr           JMP   LAB_XERR          ; do error #X, then warm start
000F3Cr 2               
000F3Cr 2                                             ; found array, are we trying to dimension it?
000F3Cr 2               LAB_1E8D
000F3Cr 2  A2 12              LDX   #$12              ; set error $12 ("Double dimension" error)
000F3Er 2  A5 5E              LDA   Defdim            ; get DIM flag
000F40r 2  D0 F7              BNE   LAB_1E8A          ; if we are trying to dimension it do error #X, then warm
000F42r 2                                             ; start
000F42r 2               
000F42r 2               ; found the array and we're not dimensioning it so we must find an element in it
000F42r 2               
000F42r 2  20 rr rr           JSR   LAB_1DE6          ; set-up array pointer (Adatal/h) to first element in array
000F45r 2                                             ; (Astrtl,Astrth points to start of array)
000F45r 2  A5 5D              LDA   Dimcnt            ; get dimensions count
000F47r 2  A0 04              LDY   #$04              ; set index to array's # of dimensions
000F49r 2  D1 AA              CMP   (Astrtl),Y        ; compare with no of dimensions
000F4Br 2  D0 E7              BNE   LAB_1E85          ; if wrong do array bounds error, could do "Wrong
000F4Dr 2                                             ; dimensions" error here .. if we want a different
000F4Dr 2                                             ; error message
000F4Dr 2               
000F4Dr 2  4C rr rr           JMP   LAB_1F28          ; found array so go get element
000F50r 2                                             ; (could jump to LAB_1F28 as all LAB_1F24 does is take
000F50r 2                                             ; Dimcnt and save it at (Astrtl),Y which is already the
000F50r 2                                             ; same or we would have taken the BNE)
000F50r 2               
000F50r 2                                             ; array not found, so build it
000F50r 2               LAB_1EA1
000F50r 2  20 rr rr           JSR   LAB_1DE6          ; set-up array pointer (Adatal/h) to first element in array
000F53r 2                                             ; (Astrtl,Astrth points to start of array)
000F53r 2  20 rr rr           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
000F56r 2                                             ; addr to check is in AY (low/high)
000F56r 2  A0 00              LDY   #$00              ; clear Y (don't need to clear A)
000F58r 2  84 BB              STY   Aspth             ; clear array data size high byte
000F5Ar 2  A5 93              LDA   Varnm1            ; get variable name 1st byte
000F5Cr 2  91 AA              STA   (Astrtl),Y        ; save array name 1st byte
000F5Er 2  C8                 INY                     ; increment index
000F5Fr 2  A5 94              LDA   Varnm2            ; get variable name 2nd byte
000F61r 2  91 AA              STA   (Astrtl),Y        ; save array name 2nd byte
000F63r 2  A5 5D              LDA   Dimcnt            ; get dimensions count
000F65r 2  A0 04              LDY   #$04              ; index to dimension count
000F67r 2  84 BA              STY   Asptl             ; set array data size low byte (four bytes per element)
000F69r 2  91 AA              STA   (Astrtl),Y        ; set array's dimensions count
000F6Br 2               
000F6Br 2                                             ; now calculate the size of the data space for the array
000F6Br 2  18                 CLC                     ; clear carry for add (clear on subsequent loops)
000F6Cr 2               LAB_1EC0
000F6Cr 2  A2 0B              LDX   #$0B              ; set default dimension value low byte
000F6Er 2  A9 00              LDA   #$00              ; set default dimension value high byte
000F70r 2  24 5E              BIT   Defdim            ; test default DIM flag
000F72r 2  50 07              BVC   LAB_1ED0          ; branch if b6 of Defdim is clear
000F74r 2               
000F74r 2  68                 PLA                     ; else pull dimension value low byte
000F75r 2  69 01              ADC   #$01              ; +1 (allow for zeroeth element)
000F77r 2  AA                 TAX                     ; copy low byte to X
000F78r 2  68                 PLA                     ; pull dimension value high byte
000F79r 2  69 00              ADC   #$00              ; add carry from low byte
000F7Br 2               
000F7Br 2               LAB_1ED0
000F7Br 2  C8                 INY                     ; index to dimension value high byte
000F7Cr 2  91 AA              STA   (Astrtl),Y        ; save dimension value high byte
000F7Er 2  C8                 INY                     ; index to dimension value high byte
000F7Fr 2  8A                 TXA                     ; get dimension value low byte
000F80r 2  91 AA              STA   (Astrtl),Y        ; save dimension value low byte
000F82r 2  20 rr rr           JSR   LAB_1F7C          ; does XY = (Astrtl),Y * (Asptl)
000F85r 2  86 BA              STX   Asptl             ; save array data size low byte
000F87r 2  85 BB              STA   Aspth             ; save array data size high byte
000F89r 2  A4 71              LDY   ut1_pl            ; restore index (saved by subroutine)
000F8Br 2  C6 5D              DEC   Dimcnt            ; decrement dimensions count
000F8Dr 2  D0 DD              BNE   LAB_1EC0          ; loop while not = 0
000F8Fr 2               
000F8Fr 2  65 A5              ADC   Adatah            ; add size high byte to first element high byte
000F91r 2                                             ; (carry is always clear here)
000F91r 2  B0 5D              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
000F93r 2               
000F93r 2  85 A5              STA   Adatah            ; save end of array high byte
000F95r 2  A8                 TAY                     ; copy end high byte to Y
000F96r 2  8A                 TXA                     ; get array size low byte
000F97r 2  65 A4              ADC   Adatal            ; add array start low byte
000F99r 2  90 03              BCC   LAB_1EF3          ; branch if no carry
000F9Br 2               
000F9Br 2  C8                 INY                     ; else increment end of array high byte
000F9Cr 2  F0 52              BEQ   LAB_1F45          ; if overflow go do "Out of memory" error
000F9Er 2               
000F9Er 2                                             ; set-up mostly complete, now zero the array
000F9Er 2               LAB_1EF3
000F9Er 2  20 rr rr           JSR   LAB_121F          ; check available memory, "Out of memory" error if no room
000FA1r 2                                             ; addr to check is in AY (low/high)
000FA1r 2  85 7F              STA   Earryl            ; save array mem end low byte
000FA3r 2  84 80              STY   Earryh            ; save array mem end high byte
000FA5r 2  A9 00              LDA   #$00              ; clear byte for array clear
000FA7r 2  E6 BB              INC   Aspth             ; increment array size high byte (now block count)
000FA9r 2  A4 BA              LDY   Asptl             ; get array size low byte (now index to block)
000FABr 2  F0 05              BEQ   LAB_1F07          ; branch if low byte = $00
000FADr 2               
000FADr 2               LAB_1F02
000FADr 2  88                 DEY                     ; decrement index (do 0 to n-1)
000FAEr 2  91 A4              STA   (Adatal),Y        ; zero byte
000FB0r 2  D0 FB              BNE   LAB_1F02          ; loop until this block done
000FB2r 2               
000FB2r 2               LAB_1F07
000FB2r 2  C6 A5              DEC   Adatah            ; decrement array pointer high byte
000FB4r 2  C6 BB              DEC   Aspth             ; decrement block count high byte
000FB6r 2  D0 F5              BNE   LAB_1F02          ; loop until all blocks done
000FB8r 2               
000FB8r 2  E6 A5              INC   Adatah            ; correct for last loop
000FBAr 2  38                 SEC                     ; set carry for subtract
000FBBr 2  A0 02              LDY   #$02              ; index to array size low byte
000FBDr 2  A5 7F              LDA   Earryl            ; get array mem end low byte
000FBFr 2  E5 AA              SBC   Astrtl            ; subtract array start low byte
000FC1r 2  91 AA              STA   (Astrtl),Y        ; save array size low byte
000FC3r 2  C8                 INY                     ; index to array size high byte
000FC4r 2  A5 80              LDA   Earryh            ; get array mem end high byte
000FC6r 2  E5 AB              SBC   Astrth            ; subtract array start high byte
000FC8r 2  91 AA              STA   (Astrtl),Y        ; save array size high byte
000FCAr 2  A5 5E              LDA   Defdim            ; get default DIM flag
000FCCr 2  D0 53              BNE   LAB_1F7B          ; exit (RET) if this was a DIM command
000FCEr 2               
000FCEr 2                                             ; else, find element
000FCEr 2  C8                 INY                     ; index to # of dimensions
000FCFr 2               
000FCFr 2               LAB_1F24
000FCFr 2  B1 AA              LDA   (Astrtl),Y        ; get array's dimension count
000FD1r 2  85 5D              STA   Dimcnt            ; save it
000FD3r 2               
000FD3r 2               ; we have found, or built, the array. now we need to find the element
000FD3r 2               
000FD3r 2               LAB_1F28
000FD3r 2  A9 00              LDA   #$00              ; clear byte
000FD5r 2  85 BA              STA   Asptl             ; clear array data pointer low byte
000FD7r 2               LAB_1F2C
000FD7r 2  85 BB              STA   Aspth             ; save array data pointer high byte
000FD9r 2  C8                 INY                     ; increment index (point to array bound high byte)
000FDAr 2  68                 PLA                     ; pull array index low byte
000FDBr 2  AA                 TAX                     ; copy to X
000FDCr 2  85 AE              STA   FAC1_2            ; save index low byte to FAC1 mantissa2
000FDEr 2  68                 PLA                     ; pull array index high byte
000FDFr 2  85 AF              STA   FAC1_3            ; save index high byte to FAC1 mantissa3
000FE1r 2  D1 AA              CMP   (Astrtl),Y        ; compare with array bound high byte
000FE3r 2  90 0E              BCC   LAB_1F48          ; branch if within bounds
000FE5r 2               
000FE5r 2  D0 06              BNE   LAB_1F42          ; if outside bounds do array bounds error
000FE7r 2               
000FE7r 2                                             ; else high byte was = so test low bytes
000FE7r 2  C8                 INY                     ; index to array bound low byte
000FE8r 2  8A                 TXA                     ; get array index low byte
000FE9r 2  D1 AA              CMP   (Astrtl),Y        ; compare with array bound low byte
000FEBr 2  90 07              BCC   LAB_1F49          ; branch if within bounds
000FEDr 2               
000FEDr 2               LAB_1F42
000FEDr 2  4C rr rr           JMP   LAB_1E85          ; else do array bounds error
000FF0r 2               
000FF0r 2               LAB_1F45
000FF0r 2  4C rr rr           JMP   LAB_OMER          ; do "Out of memory" error then warm start
000FF3r 2               
000FF3r 2               LAB_1F48
000FF3r 2  C8                 INY                     ; index to array bound low byte
000FF4r 2               LAB_1F49
000FF4r 2  A5 BB              LDA   Aspth             ; get array data pointer high byte
000FF6r 2  05 BA              ORA   Asptl             ; OR with array data pointer low byte
000FF8r 2  F0 0A              BEQ   LAB_1F5A          ; branch if array data pointer = null (skip multiply)
000FFAr 2               
000FFAr 2  20 rr rr           JSR   LAB_1F7C          ; does XY = (Astrtl),Y * (Asptl)
000FFDr 2  8A                 TXA                     ; get result low byte
000FFEr 2  65 AE              ADC   FAC1_2            ; add index low byte from FAC1 mantissa2
001000r 2  AA                 TAX                     ; save result low byte
001001r 2  98                 TYA                     ; get result high byte
001002r 2  A4 71              LDY   ut1_pl            ; restore index
001004r 2               LAB_1F5A
001004r 2  65 AF              ADC   FAC1_3            ; add index high byte from FAC1 mantissa3
001006r 2  86 BA              STX   Asptl             ; save array data pointer low byte
001008r 2  C6 5D              DEC   Dimcnt            ; decrement dimensions count
00100Ar 2  D0 CB              BNE   LAB_1F2C          ; loop if dimensions still to do
00100Cr 2               
00100Cr 2  06 BA              ASL   Asptl             ; array data pointer low byte * 2
00100Er 2  2A                 ROL                     ; array data pointer high byte * 2
00100Fr 2  06 BA              ASL   Asptl             ; array data pointer low byte * 4
001011r 2  2A                 ROL                     ; array data pointer high byte * 4
001012r 2  A8                 TAY                     ; copy high byte
001013r 2  A5 BA              LDA   Asptl             ; get low byte
001015r 2  65 A4              ADC   Adatal            ; add array data start pointer low byte
001017r 2  85 95              STA   Cvaral            ; save as current var address low byte
001019r 2  98                 TYA                     ; get high byte back
00101Ar 2  65 A5              ADC   Adatah            ; add array data start pointer high byte
00101Cr 2  85 96              STA   Cvarah            ; save as current var address high byte
00101Er 2  A8                 TAY                     ; copy high byte to Y
00101Fr 2  A5 95              LDA   Cvaral            ; get current var address low byte
001021r 2               LAB_1F7B
001021r 2  60                 RTS
001022r 2               
001022r 2               ; does XY = (Astrtl),Y * (Asptl)
001022r 2               
001022r 2               LAB_1F7C
001022r 2  84 71              STY   ut1_pl            ; save index
001024r 2  B1 AA              LDA   (Astrtl),Y        ; get dimension size low byte
001026r 2  85 76              STA   dims_l            ; save dimension size low byte
001028r 2  88                 DEY                     ; decrement index
001029r 2  B1 AA              LDA   (Astrtl),Y        ; get dimension size high byte
00102Br 2  85 77              STA   dims_h            ; save dimension size high byte
00102Dr 2               
00102Dr 2  A9 10              LDA   #$10              ; count = $10 (16 bit multiply)
00102Fr 2  85 A8              STA   numbit            ; save bit count
001031r 2  A2 00              LDX   #$00              ; clear result low byte
001033r 2  A0 00              LDY   #$00              ; clear result high byte
001035r 2               LAB_1F8F
001035r 2  8A                 TXA                     ; get result low byte
001036r 2  0A                 ASL                     ; *2
001037r 2  AA                 TAX                     ; save result low byte
001038r 2  98                 TYA                     ; get result high byte
001039r 2  2A                 ROL                     ; *2
00103Ar 2  A8                 TAY                     ; save result high byte
00103Br 2  B0 B3              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
00103Dr 2               
00103Dr 2  06 BA              ASL   Asptl             ; shift multiplier low byte
00103Fr 2  26 BB              ROL   Aspth             ; shift multiplier high byte
001041r 2  90 0B              BCC   LAB_1FA8          ; skip add if no carry
001043r 2               
001043r 2  18                 CLC                     ; else clear carry for add
001044r 2  8A                 TXA                     ; get result low byte
001045r 2  65 76              ADC   dims_l            ; add dimension size low byte
001047r 2  AA                 TAX                     ; save result low byte
001048r 2  98                 TYA                     ; get result high byte
001049r 2  65 77              ADC   dims_h            ; add dimension size high byte
00104Br 2  A8                 TAY                     ; save result high byte
00104Cr 2  B0 A2              BCS   LAB_1F45          ; if overflow go do "Out of memory" error
00104Er 2               
00104Er 2               LAB_1FA8
00104Er 2  C6 A8              DEC   numbit            ; decrement bit count
001050r 2  D0 E3              BNE   LAB_1F8F          ; loop until all done
001052r 2               
001052r 2  60                 RTS
001053r 2               
001053r 2               ; perform FRE()
001053r 2               
001053r 2               LAB_FRE
001053r 2  A5 5F              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
001055r 2  10 03              BPL   LAB_1FB4          ; branch if numeric
001057r 2               
001057r 2  20 rr rr           JSR   LAB_22B6          ; pop string off descriptor stack, or from top of string
00105Ar 2                                             ; space returns with A = length, X=$71=pointer low byte,
00105Ar 2                                             ; Y=$72=pointer high byte
00105Ar 2               
00105Ar 2                                             ; FRE(n) was numeric so do this
00105Ar 2               LAB_1FB4
00105Ar 2  20 rr rr           JSR   LAB_GARB          ; go do garbage collection
00105Dr 2  38                 SEC                     ; set carry for subtract
00105Er 2  A5 81              LDA   Sstorl            ; get bottom of string space low byte
001060r 2  E5 7F              SBC   Earryl            ; subtract array mem end low byte
001062r 2  A8                 TAY                     ; copy result to Y
001063r 2  A5 82              LDA   Sstorh            ; get bottom of string space high byte
001065r 2  E5 80              SBC   Earryh            ; subtract array mem end high byte
001067r 2               
001067r 2               ; save and convert integer AY to FAC1
001067r 2               
001067r 2               LAB_AYFC
001067r 2  46 5F              LSR   Dtypef            ; clear data type flag, $FF=string, $00=numeric
001069r 2  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
00106Br 2  84 AE              STY   FAC1_2            ; save FAC1 mantissa2
00106Dr 2  A2 90              LDX   #$90              ; set exponent=2^16 (integer)
00106Fr 2  4C rr rr           JMP   LAB_27E3          ; set exp=X, clear FAC1_3, normalise and return
001072r 2               
001072r 2               ; perform POS()
001072r 2               
001072r 2               LAB_POS
001072r 2  A4 0E              LDY   TPos              ; get terminal position
001074r 2               
001074r 2               ; convert Y to byte in FAC1
001074r 2               
001074r 2               LAB_1FD0
001074r 2  A9 00              LDA   #$00              ; clear high byte
001076r 2  F0 EF              BEQ   LAB_AYFC          ; always save and convert integer AY to FAC1 and return
001078r 2               
001078r 2               ; check not Direct (used by DEF and INPUT)
001078r 2               
001078r 2               LAB_CKRN
001078r 2  A6 88              LDX   Clineh            ; get current line high byte
00107Ar 2  E8                 INX                     ; increment it
00107Br 2  D0 A4              BNE   LAB_1F7B          ; return if can continue not direct mode
00107Dr 2               
00107Dr 2                                             ; else do illegal direct error
00107Dr 2               LAB_1FD9
00107Dr 2  A2 16              LDX   #$16              ; error code $16 ("Illegal direct" error)
00107Fr 2               LAB_1FDB
00107Fr 2  4C rr rr           JMP   LAB_XERR          ; go do error #X, then warm start
001082r 2               
001082r 2               ; perform DEF
001082r 2               
001082r 2               LAB_DEF
001082r 2  20 rr rr           JSR   LAB_200B          ; check FNx syntax
001085r 2  85 9C              STA   func_l            ; save function pointer low byte
001087r 2  84 9D              STY   func_h            ; save function pointer high byte
001089r 2  20 rr rr           JSR   LAB_CKRN          ; check not Direct (back here if ok)
00108Cr 2  20 rr rr           JSR   LAB_1BFE          ; scan for "(" , else do syntax error then warm start
00108Fr 2  A9 80              LDA   #$80              ; set flag for FNx
001091r 2  85 61              STA   Sufnxf            ; save subscript/FNx flag
001093r 2  20 rr rr           JSR   LAB_GVAR          ; get (var) address
001096r 2  20 rr rr           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
001099r 2  20 rr rr           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
00109Cr 2  A9 C1              LDA   #TK_EQUAL         ; get = token
00109Er 2  20 rr rr           JSR   LAB_SCCA          ; scan for CHR$(A), else do syntax error then warm start
0010A1r 2  A5 96              LDA   Cvarah            ; get current var address high byte
0010A3r 2  48                 PHA                     ; push it
0010A4r 2  A5 95              LDA   Cvaral            ; get current var address low byte
0010A6r 2  48                 PHA                     ; push it
0010A7r 2  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
0010A9r 2  48                 PHA                     ; push it
0010AAr 2  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
0010ACr 2  48                 PHA                     ; push it
0010ADr 2  20 rr rr           JSR   LAB_DATA          ; go perform DATA
0010B0r 2  4C rr rr           JMP   LAB_207A          ; put execute pointer and variable pointer into function
0010B3r 2                                             ; and return
0010B3r 2               
0010B3r 2               ; check FNx syntax
0010B3r 2               
0010B3r 2               LAB_200B
0010B3r 2  A9 AE              LDA   #TK_FN            ; get FN" token
0010B5r 2  20 rr rr           JSR   LAB_SCCA          ; scan for CHR$(A) , else do syntax error then warm start
0010B8r 2                                             ; return character after A
0010B8r 2  09 80              ORA   #$80              ; set FN flag bit
0010BAr 2  85 61              STA   Sufnxf            ; save FN flag so array variable test fails
0010BCr 2  20 rr rr           JSR   LAB_1D12          ; search for FN variable
0010BFr 2  4C rr rr           JMP   LAB_CTNM          ; check if source is numeric and return, else do type
0010C2r 2                                             ; mismatch
0010C2r 2               
0010C2r 2                                             ; Evaluate FNx
0010C2r 2               LAB_201E
0010C2r 2  20 rr rr           JSR   LAB_200B          ; check FNx syntax
0010C5r 2  48                 PHA                     ; push function pointer low byte
0010C6r 2  98                 TYA                     ; copy function pointer high byte
0010C7r 2  48                 PHA                     ; push function pointer high byte
0010C8r 2  20 rr rr           JSR   LAB_1BFE          ; scan for "(", else do syntax error then warm start
0010CBr 2  20 rr rr           JSR   LAB_EVEX          ; evaluate expression
0010CEr 2  20 rr rr           JSR   LAB_1BFB          ; scan for ")", else do syntax error then warm start
0010D1r 2  20 rr rr           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
0010D4r 2  68                 PLA                     ; pop function pointer high byte
0010D5r 2  85 9D              STA   func_h            ; restore it
0010D7r 2  68                 PLA                     ; pop function pointer low byte
0010D8r 2  85 9C              STA   func_l            ; restore it
0010DAr 2  A2 20              LDX   #$20              ; error code $20 ("Undefined function" error)
0010DCr 2  A0 03              LDY   #$03              ; index to variable pointer high byte
0010DEr 2  B1 9C              LDA   (func_l),Y        ; get variable pointer high byte
0010E0r 2  F0 9D              BEQ   LAB_1FDB          ; if zero go do undefined function error
0010E2r 2               
0010E2r 2  85 96              STA   Cvarah            ; save variable address high byte
0010E4r 2  88                 DEY                     ; index to variable address low byte
0010E5r 2  B1 9C              LDA   (func_l),Y        ; get variable address low byte
0010E7r 2  85 95              STA   Cvaral            ; save variable address low byte
0010E9r 2  AA                 TAX                     ; copy address low byte
0010EAr 2               
0010EAr 2                                             ; now stack the function variable value before use
0010EAr 2  C8                 INY                     ; index to mantissa_3
0010EBr 2               LAB_2043
0010EBr 2  B1 95              LDA   (Cvaral),Y        ; get byte from variable
0010EDr 2  48                 PHA                     ; stack it
0010EEr 2  88                 DEY                     ; decrement index
0010EFr 2  10 FA              BPL   LAB_2043          ; loop until variable stacked
0010F1r 2               
0010F1r 2  A4 96              LDY   Cvarah            ; get variable address high byte
0010F3r 2  20 rr rr           JSR   LAB_2778          ; pack FAC1 (function expression value) into (XY)
0010F6r 2                                             ; (function variable), return Y=0, always
0010F6r 2  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
0010F8r 2  48                 PHA                     ; push it
0010F9r 2  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
0010FBr 2  48                 PHA                     ; push it
0010FCr 2  B1 9C              LDA   (func_l),Y        ; get function execute pointer low byte
0010FEr 2  85 C3              STA   Bpntrl            ; save as BASIC execute pointer low byte
001100r 2  C8                 INY                     ; index to high byte
001101r 2  B1 9C              LDA   (func_l),Y        ; get function execute pointer high byte
001103r 2  85 C4              STA   Bpntrh            ; save as BASIC execute pointer high byte
001105r 2  A5 96              LDA   Cvarah            ; get variable address high byte
001107r 2  48                 PHA                     ; push it
001108r 2  A5 95              LDA   Cvaral            ; get variable address low byte
00110Ar 2  48                 PHA                     ; push it
00110Br 2  20 rr rr           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
00110Er 2                                             ; else do type mismatch
00110Er 2  68                 PLA                     ; pull variable address low byte
00110Fr 2  85 9C              STA   func_l            ; save variable address low byte
001111r 2  68                 PLA                     ; pull variable address high byte
001112r 2  85 9D              STA   func_h            ; save variable address high byte
001114r 2  20 C2 00           JSR   LAB_GBYT          ; scan memory
001117r 2  F0 03              BEQ   LAB_2074          ; branch if null (should be [EOL] marker)
001119r 2               
001119r 2  4C rr rr           JMP   LAB_SNER          ; else syntax error then warm start
00111Cr 2               
00111Cr 2               ; restore Bpntrl,Bpntrh and function variable from stack
00111Cr 2               
00111Cr 2               LAB_2074
00111Cr 2  68                 PLA                     ; pull BASIC execute pointer low byte
00111Dr 2  85 C3              STA   Bpntrl            ; restore BASIC execute pointer low byte
00111Fr 2  68                 PLA                     ; pull BASIC execute pointer high byte
001120r 2  85 C4              STA   Bpntrh            ; restore BASIC execute pointer high byte
001122r 2               
001122r 2               ; put execute pointer and variable pointer into function
001122r 2               
001122r 2               LAB_207A
001122r 2  A0 00              LDY   #$00              ; clear index
001124r 2  68                 PLA                     ; pull BASIC execute pointer low byte
001125r 2  91 9C              STA   (func_l),Y        ; save to function
001127r 2  C8                 INY                     ; increment index
001128r 2  68                 PLA                     ; pull BASIC execute pointer high byte
001129r 2  91 9C              STA   (func_l),Y        ; save to function
00112Br 2  C8                 INY                     ; increment index
00112Cr 2  68                 PLA                     ; pull current var address low byte
00112Dr 2  91 9C              STA   (func_l),Y        ; save to function
00112Fr 2  C8                 INY                     ; increment index
001130r 2  68                 PLA                     ; pull current var address high byte
001131r 2  91 9C              STA   (func_l),Y        ; save to function
001133r 2  60                 RTS
001134r 2               
001134r 2               ; perform STR$()
001134r 2               
001134r 2               LAB_STRS
001134r 2  20 rr rr           JSR   LAB_CTNM          ; check if source is numeric, else do type mismatch
001137r 2  20 rr rr           JSR   LAB_296E          ; convert FAC1 to string
00113Ar 2  A9 F0              LDA   #<Decssp1         ; set result string low pointer
00113Cr 2  A0 00              LDY   #>Decssp1         ; set result string high pointer
00113Er 2  F0 12              BEQ   LAB_20AE          ; print null terminated string to Sutill/Sutilh
001140r 2               
001140r 2               ; Do string vector
001140r 2               ; copy des_pl/h to des_2l/h and make string space A bytes long
001140r 2               
001140r 2               LAB_209C
001140r 2  A6 AE              LDX   des_pl            ; get descriptor pointer low byte
001142r 2  A4 AF              LDY   des_ph            ; get descriptor pointer high byte
001144r 2  86 9E              STX   des_2l            ; save descriptor pointer low byte
001146r 2  84 9F              STY   des_2h            ; save descriptor pointer high byte
001148r 2               
001148r 2               ; make string space A bytes long
001148r 2               ; A=length, X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
001148r 2               
001148r 2               LAB_MSSP
001148r 2  20 rr rr           JSR   LAB_2115          ; make space in string memory for string A long
00114Br 2                                             ; return X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
00114Br 2  86 AD              STX   str_pl            ; save string pointer low byte
00114Dr 2  84 AE              STY   str_ph            ; save string pointer high byte
00114Fr 2  85 AC              STA   str_ln            ; save length
001151r 2  60                 RTS
001152r 2               
001152r 2               ; Scan, set up string
001152r 2               ; print " terminated string to Sutill/Sutilh
001152r 2               
001152r 2               LAB_20AE
001152r 2  A2 22              LDX   #$22              ; set terminator to "
001154r 2  86 5B              STX   Srchc             ; set search character (terminator 1)
001156r 2  86 5C              STX   Asrch             ; set terminator 2
001158r 2               
001158r 2               ; print [Srchc] or [Asrch] terminated string to Sutill/Sutilh
001158r 2               ; source is AY
001158r 2               
001158r 2               LAB_20B4
001158r 2  85 B8              STA   ssptr_l           ; store string start low byte
00115Ar 2  84 B9              STY   ssptr_h           ; store string start high byte
00115Cr 2  85 AD              STA   str_pl            ; save string pointer low byte
00115Er 2  84 AE              STY   str_ph            ; save string pointer high byte
001160r 2  A0 FF              LDY   #$FF              ; set length to -1
001162r 2               LAB_20BE
001162r 2  C8                 INY                     ; increment length
001163r 2  B1 B8              LDA   (ssptr_l),Y       ; get byte from string
001165r 2  F0 0C              BEQ   LAB_20CF          ; exit loop if null byte [EOS]
001167r 2               
001167r 2  C5 5B              CMP   Srchc             ; compare with search character (terminator 1)
001169r 2  F0 04              BEQ   LAB_20CB          ; branch if terminator
00116Br 2               
00116Br 2  C5 5C              CMP   Asrch             ; compare with terminator 2
00116Dr 2  D0 F3              BNE   LAB_20BE          ; loop if not terminator 2
00116Fr 2               
00116Fr 2               LAB_20CB
00116Fr 2  C9 22              CMP   #$22              ; compare with "
001171r 2  F0 01              BEQ   LAB_20D0          ; branch if " (carry set if = !)
001173r 2               
001173r 2               LAB_20CF
001173r 2  18                 CLC                     ; clear carry for add (only if [EOL] terminated string)
001174r 2               LAB_20D0
001174r 2  84 AC              STY   str_ln            ; save length in FAC1 exponent
001176r 2  98                 TYA                     ; copy length to A
001177r 2  65 B8              ADC   ssptr_l           ; add string start low byte
001179r 2  85 BA              STA   Sendl             ; save string end low byte
00117Br 2  A6 B9              LDX   ssptr_h           ; get string start high byte
00117Dr 2  90 01              BCC   LAB_20DC          ; branch if no low byte overflow
00117Fr 2               
00117Fr 2  E8                 INX                     ; else increment high byte
001180r 2               LAB_20DC
001180r 2  86 BB              STX   Sendh             ; save string end high byte
001182r 2  A5 B9              LDA   ssptr_h           ; get string start high byte
001184r 2               ; *** begin RAM above code / Ibuff above EhBASIC patch V2 ***
001184r 2               ; *** replace
001184r 2               ;      CMP   #>Ram_base        ; compare with start of program memory
001184r 2               ;      BCS   LAB_RTST          ; branch if not in utility area
001184r 2               ; *** with
001184r 2  F0 04              BEQ   LAB_MVST          ; fix STR$() using page zero via LAB_296E
001186r 2  C9 02              CMP   #>Ibuffs          ; compare with location of input buffer page
001188r 2  D0 0B              BNE   LAB_RTST          ; branch if not in utility area
00118Ar 2               LAB_MVST
00118Ar 2               ; *** end   RAM above code / Ibuff above EhBASIC patch V2 ***
00118Ar 2               
00118Ar 2                                             ; string in utility area, move to string memory
00118Ar 2  98                 TYA                     ; copy length to A
00118Br 2  20 rr rr           JSR   LAB_209C          ; copy des_pl/h to des_2l/h and make string space A bytes
00118Er 2                                             ; long
00118Er 2  A6 B8              LDX   ssptr_l           ; get string start low byte
001190r 2  A4 B9              LDY   ssptr_h           ; get string start high byte
001192r 2  20 rr rr           JSR   LAB_2298          ; store string A bytes long from XY to (Sutill)
001195r 2               
001195r 2               ; check for space on descriptor stack then ..
001195r 2               ; put string address and length on descriptor stack and update stack pointers
001195r 2               
001195r 2               LAB_RTST
001195r 2  A6 65              LDX   next_s            ; get string stack pointer
001197r 2  E0 71              CPX   #des_sk+$09       ; compare with max+1
001199r 2  D0 05              BNE   LAB_20F8          ; branch if space on string stack
00119Br 2               
00119Br 2                                             ; else do string too complex error
00119Br 2  A2 1C              LDX   #$1C              ; error code $1C ("String too complex" error)
00119Dr 2               LAB_20F5
00119Dr 2  4C rr rr           JMP   LAB_XERR          ; do error #X, then warm start
0011A0r 2               
0011A0r 2               ; put string address and length on descriptor stack and update stack pointers
0011A0r 2               
0011A0r 2               LAB_20F8
0011A0r 2  A5 AC              LDA   str_ln            ; get string length
0011A2r 2  95 00              STA   PLUS_0,X          ; put on string stack
0011A4r 2  A5 AD              LDA   str_pl            ; get string pointer low byte
0011A6r 2  95 01              STA   PLUS_1,X          ; put on string stack
0011A8r 2  A5 AE              LDA   str_ph            ; get string pointer high byte
0011AAr 2  95 02              STA   PLUS_2,X          ; put on string stack
0011ACr 2  A0 00              LDY   #$00              ; clear Y
0011AEr 2  86 AE              STX   des_pl            ; save string descriptor pointer low byte
0011B0r 2  84 AF              STY   des_ph            ; save string descriptor pointer high byte (always $00)
0011B2r 2  88                 DEY                     ; Y = $FF
0011B3r 2  84 5F              STY   Dtypef            ; save data type flag, $FF=string
0011B5r 2  86 66              STX   last_sl           ; save old stack pointer (current top item)
0011B7r 2  E8                 INX                     ; update stack pointer
0011B8r 2  E8                 INX                     ; update stack pointer
0011B9r 2  E8                 INX                     ; update stack pointer
0011BAr 2  86 65              STX   next_s            ; save new top item value
0011BCr 2  60                 RTS
0011BDr 2               
0011BDr 2               ; Build descriptor
0011BDr 2               ; make space in string memory for string A long
0011BDr 2               ; return X=Sutill=ptr low byte, Y=Sutill=ptr high byte
0011BDr 2               
0011BDr 2               LAB_2115
0011BDr 2  46 60              LSR   Gclctd            ; clear garbage collected flag (b7)
0011BFr 2               
0011BFr 2                                             ; make space for string A long
0011BFr 2               LAB_2117
0011BFr 2  48                 PHA                     ; save string length
0011C0r 2  49 FF              EOR   #$FF              ; complement it
0011C2r 2  38                 SEC                     ; set carry for subtract (twos comp add)
0011C3r 2  65 81              ADC   Sstorl            ; add bottom of string space low byte (subtract length)
0011C5r 2  A4 82              LDY   Sstorh            ; get bottom of string space high byte
0011C7r 2  B0 01              BCS   LAB_2122          ; skip decrement if no underflow
0011C9r 2               
0011C9r 2  88                 DEY                     ; decrement bottom of string space high byte
0011CAr 2               LAB_2122
0011CAr 2  C4 80              CPY   Earryh            ; compare with array mem end high byte
0011CCr 2  90 11              BCC   LAB_2137          ; do out of memory error if less
0011CEr 2               
0011CEr 2  D0 04              BNE   LAB_212C          ; if not = skip next test
0011D0r 2               
0011D0r 2  C5 7F              CMP   Earryl            ; compare with array mem end low byte
0011D2r 2  90 0B              BCC   LAB_2137          ; do out of memory error if less
0011D4r 2               
0011D4r 2               LAB_212C
0011D4r 2  85 81              STA   Sstorl            ; save bottom of string space low byte
0011D6r 2  84 82              STY   Sstorh            ; save bottom of string space high byte
0011D8r 2  85 83              STA   Sutill            ; save string utility ptr low byte
0011DAr 2  84 84              STY   Sutilh            ; save string utility ptr high byte
0011DCr 2  AA                 TAX                     ; copy low byte to X
0011DDr 2  68                 PLA                     ; get string length back
0011DEr 2  60                 RTS
0011DFr 2               
0011DFr 2               LAB_2137
0011DFr 2  A2 0C              LDX   #$0C              ; error code $0C ("Out of memory" error)
0011E1r 2  A5 60              LDA   Gclctd            ; get garbage collected flag
0011E3r 2  30 B8              BMI   LAB_20F5          ; if set then do error code X
0011E5r 2               
0011E5r 2  20 rr rr           JSR   LAB_GARB          ; else go do garbage collection
0011E8r 2  A9 80              LDA   #$80              ; flag for garbage collected
0011EAr 2  85 60              STA   Gclctd            ; set garbage collected flag
0011ECr 2  68                 PLA                     ; pull length
0011EDr 2  D0 D0              BNE   LAB_2117          ; go try again (loop always, length should never be = $00)
0011EFr 2               
0011EFr 2               ; garbage collection routine
0011EFr 2               
0011EFr 2               LAB_GARB
0011EFr 2  A6 85              LDX   Ememl             ; get end of mem low byte
0011F1r 2  A5 86              LDA   Ememh             ; get end of mem high byte
0011F3r 2               
0011F3r 2               ; re-run routine from last ending
0011F3r 2               
0011F3r 2               LAB_214B
0011F3r 2  86 81              STX   Sstorl            ; set string storage low byte
0011F5r 2  85 82              STA   Sstorh            ; set string storage high byte
0011F7r 2  A0 00              LDY   #$00              ; clear index
0011F9r 2  84 9D              STY   garb_h            ; clear working pointer high byte (flag no strings to move)
0011FBr 2               ; *** begin patch  2.22p5.5  garbage collection may overlap temporary strings
0011FBr 2               ; *** add
0011FBr 2  84 9C              STY   garb_l            ; clear working pointer low byte (flag no strings to move)
0011FDr 2               ; *** begin patch  2.22p5.5  garbage collection may overlap temporary strings
0011FDr 2  A5 7F              LDA   Earryl            ; get array mem end low byte
0011FFr 2  A6 80              LDX   Earryh            ; get array mem end high byte
001201r 2  85 AA              STA   Histrl            ; save as highest string low byte
001203r 2  86 AB              STX   Histrh            ; save as highest string high byte
001205r 2  A9 68              LDA   #des_sk           ; set descriptor stack pointer
001207r 2  85 71              STA   ut1_pl            ; save descriptor stack pointer low byte
001209r 2  84 72              STY   ut1_ph            ; save descriptor stack pointer high byte ($00)
00120Br 2               LAB_2161
00120Br 2  C5 65              CMP   next_s            ; compare with descriptor stack pointer
00120Dr 2  F0 05              BEQ   LAB_216A          ; branch if =
00120Fr 2               
00120Fr 2  20 rr rr           JSR   LAB_21D7          ; go garbage collect descriptor stack
001212r 2  F0 F7              BEQ   LAB_2161          ; loop always
001214r 2               
001214r 2                                             ; done stacked strings, now do string vars
001214r 2               LAB_216A
001214r 2  06 A0              ASL   g_step            ; set step size = $06
001216r 2  A5 7B              LDA   Svarl             ; get start of vars low byte
001218r 2  A6 7C              LDX   Svarh             ; get start of vars high byte
00121Ar 2  85 71              STA   ut1_pl            ; save as pointer low byte
00121Cr 2  86 72              STX   ut1_ph            ; save as pointer high byte
00121Er 2               LAB_2176
00121Er 2  E4 7E              CPX   Sarryh            ; compare start of arrays high byte
001220r 2  D0 04              BNE   LAB_217E          ; branch if no high byte match
001222r 2               
001222r 2  C5 7D              CMP   Sarryl            ; else compare start of arrays low byte
001224r 2  F0 05              BEQ   LAB_2183          ; branch if = var mem end
001226r 2               
001226r 2               LAB_217E
001226r 2  20 rr rr           JSR   LAB_21D1          ; go garbage collect strings
001229r 2  F0 F3              BEQ   LAB_2176          ; loop always
00122Br 2               
00122Br 2                                             ; done string vars, now do string arrays
00122Br 2               LAB_2183
00122Br 2  85 A4              STA   Nbendl            ; save start of arrays low byte as working pointer
00122Dr 2  86 A5              STX   Nbendh            ; save start of arrays high byte as working pointer
00122Fr 2  A9 04              LDA   #$04              ; set step size
001231r 2  85 A0              STA   g_step            ; save step size
001233r 2               LAB_218B
001233r 2  A5 A4              LDA   Nbendl            ; get pointer low byte
001235r 2  A6 A5              LDX   Nbendh            ; get pointer high byte
001237r 2               LAB_218F
001237r 2  E4 80              CPX   Earryh            ; compare with array mem end high byte
001239r 2  D0 04              BNE   LAB_219A          ; branch if not at end
00123Br 2               
00123Br 2  C5 7F              CMP   Earryl            ; else compare with array mem end low byte
00123Dr 2  F0 75              BEQ   LAB_2216          ; tidy up and exit if at end
00123Fr 2               
00123Fr 2               LAB_219A
00123Fr 2  85 71              STA   ut1_pl            ; save pointer low byte
001241r 2  86 72              STX   ut1_ph            ; save pointer high byte
001243r 2  A0 02              LDY   #$02              ; set index
001245r 2  B1 71              LDA   (ut1_pl),Y        ; get array size low byte
001247r 2  65 A4              ADC   Nbendl            ; add start of this array low byte
001249r 2  85 A4              STA   Nbendl            ; save start of next array low byte
00124Br 2  C8                 INY                     ; increment index
00124Cr 2  B1 71              LDA   (ut1_pl),Y        ; get array size high byte
00124Er 2  65 A5              ADC   Nbendh            ; add start of this array high byte
001250r 2  85 A5              STA   Nbendh            ; save start of next array high byte
001252r 2  A0 01              LDY   #$01              ; set index
001254r 2  B1 71              LDA   (ut1_pl),Y        ; get name second byte
001256r 2  10 DB              BPL   LAB_218B          ; skip if not string array
001258r 2               
001258r 2               ; was string array so ..
001258r 2               
001258r 2  A0 04              LDY   #$04              ; set index
00125Ar 2  B1 71              LDA   (ut1_pl),Y        ; get # of dimensions
00125Cr 2  0A                 ASL                     ; *2
00125Dr 2  69 05              ADC   #$05              ; +5 (array header size)
00125Fr 2  20 rr rr           JSR   LAB_2208          ; go set up for first element
001262r 2               LAB_21C4
001262r 2  E4 A5              CPX   Nbendh            ; compare with start of next array high byte
001264r 2  D0 04              BNE   LAB_21CC          ; branch if <> (go do this array)
001266r 2               
001266r 2  C5 A4              CMP   Nbendl            ; else compare element pointer low byte with next array
001268r 2                                             ; low byte
001268r 2  F0 CD              BEQ   LAB_218F          ; if equal then go do next array
00126Ar 2               
00126Ar 2               LAB_21CC
00126Ar 2  20 rr rr           JSR   LAB_21D7          ; go defrag array strings
00126Dr 2  F0 F3              BEQ   LAB_21C4          ; go do next array string (loop always)
00126Fr 2               
00126Fr 2               ; defrag string variables
00126Fr 2               ; enter with XA = variable pointer
00126Fr 2               ; return with XA = next variable pointer
00126Fr 2               
00126Fr 2               LAB_21D1
00126Fr 2  C8                 INY                     ; increment index (Y was $00)
001270r 2  B1 71              LDA   (ut1_pl),Y        ; get var name byte 2
001272r 2  10 30              BPL   LAB_2206          ; if not string, step pointer to next var and return
001274r 2               
001274r 2  C8                 INY                     ; else increment index
001275r 2               LAB_21D7
001275r 2  B1 71              LDA   (ut1_pl),Y        ; get string length
001277r 2  F0 2B              BEQ   LAB_2206          ; if null, step pointer to next string and return
001279r 2               
001279r 2  C8                 INY                     ; else increment index
00127Ar 2  B1 71              LDA   (ut1_pl),Y        ; get string pointer low byte
00127Cr 2  AA                 TAX                     ; copy to X
00127Dr 2  C8                 INY                     ; increment index
00127Er 2  B1 71              LDA   (ut1_pl),Y        ; get string pointer high byte
001280r 2  C5 82              CMP   Sstorh            ; compare bottom of string space high byte
001282r 2  90 06              BCC   LAB_21EC          ; branch if less
001284r 2               
001284r 2  D0 1E              BNE   LAB_2206          ; if greater, step pointer to next string and return
001286r 2               
001286r 2                                             ; high bytes were = so compare low bytes
001286r 2  E4 81              CPX   Sstorl            ; compare bottom of string space low byte
001288r 2  B0 1A              BCS   LAB_2206          ; if >=, step pointer to next string and return
00128Ar 2               
00128Ar 2                                             ; string pointer is < string storage pointer (pos in mem)
00128Ar 2               LAB_21EC
00128Ar 2  C5 AB              CMP   Histrh            ; compare to highest string high byte
00128Cr 2  90 17              BCC   LAB_2207          ; if <, step pointer to next string and return
00128Er 2               
00128Er 2  D0 04              BNE   LAB_21F6          ; if > update pointers, step to next and return
001290r 2               
001290r 2                                             ; high bytes were = so compare low bytes
001290r 2  E4 AA              CPX   Histrl            ; compare to highest string low byte
001292r 2  90 11              BCC   LAB_2207          ; if <, step pointer to next string and return
001294r 2               
001294r 2                                             ; string is in string memory space
001294r 2               LAB_21F6
001294r 2  86 AA              STX   Histrl            ; save as new highest string low byte
001296r 2  85 AB              STA   Histrh            ; save as new highest string high byte
001298r 2  A5 71              LDA   ut1_pl            ; get start of vars(descriptors) low byte
00129Ar 2  A6 72              LDX   ut1_ph            ; get start of vars(descriptors) high byte
00129Cr 2  85 9C              STA   garb_l            ; save as working pointer low byte
00129Er 2  86 9D              STX   garb_h            ; save as working pointer high byte
0012A0r 2  88                 DEY                     ; decrement index DIFFERS
0012A1r 2  88                 DEY                     ; decrement index (should point to descriptor start)
0012A2r 2  84 A2              STY   g_indx            ; save index pointer
0012A4r 2               
0012A4r 2                                             ; step pointer to next string
0012A4r 2               LAB_2206
0012A4r 2  18                 CLC                     ; clear carry for add
0012A5r 2               LAB_2207
0012A5r 2  A5 A0              LDA   g_step            ; get step size
0012A7r 2               LAB_2208
0012A7r 2  65 71              ADC   ut1_pl            ; add pointer low byte
0012A9r 2  85 71              STA   ut1_pl            ; save pointer low byte
0012ABr 2  90 02              BCC   LAB_2211          ; branch if no overflow
0012ADr 2               
0012ADr 2  E6 72              INC   ut1_ph            ; else increment high byte
0012AFr 2               LAB_2211
0012AFr 2  A6 72              LDX   ut1_ph            ; get pointer high byte
0012B1r 2  A0 00              LDY   #$00              ; clear Y
0012B3r 2  60                 RTS
0012B4r 2               
0012B4r 2               ; search complete, now either exit or set-up and move string
0012B4r 2               
0012B4r 2               LAB_2216
0012B4r 2  C6 A0              DEC   g_step            ; decrement step size (now $03 for descriptor stack)
0012B6r 2               ; *** begin patch  2.22p5.5  garbage collection may overlap temporary strings
0012B6r 2               ; *** replace
0012B6r 2               ;      LDX   garb_h            ; get string to move high byte
0012B6r 2               ; *** with
0012B6r 2  A5 9D              LDA   garb_h            ; any string to move?
0012B8r 2  05 9C              ORA   garb_l
0012BAr 2               ; *** end   patch  2.22p5.5  garbage collection may overlap temporary strings
0012BAr 2  F0 F3              BEQ   LAB_2211          ; exit if nothing to move
0012BCr 2               
0012BCr 2  A4 A2              LDY   g_indx            ; get index byte back (points to descriptor)
0012BEr 2  18                 CLC                     ; clear carry for add
0012BFr 2  B1 9C              LDA   (garb_l),Y        ; get string length
0012C1r 2  65 AA              ADC   Histrl            ; add highest string low byte
0012C3r 2  85 A6              STA   Obendl            ; save old block end low pointer
0012C5r 2  A5 AB              LDA   Histrh            ; get highest string high byte
0012C7r 2  69 00              ADC   #$00              ; add any carry
0012C9r 2  85 A7              STA   Obendh            ; save old block end high byte
0012CBr 2  A5 81              LDA   Sstorl            ; get bottom of string space low byte
0012CDr 2  A6 82              LDX   Sstorh            ; get bottom of string space high byte
0012CFr 2  85 A4              STA   Nbendl            ; save new block end low byte
0012D1r 2  86 A5              STX   Nbendh            ; save new block end high byte
0012D3r 2  20 rr rr           JSR   LAB_11D6          ; open up space in memory, don't set array end
0012D6r 2  A4 A2              LDY   g_indx            ; get index byte
0012D8r 2  C8                 INY                     ; point to descriptor low byte
0012D9r 2  A5 A4              LDA   Nbendl            ; get string pointer low byte
0012DBr 2  91 9C              STA   (garb_l),Y        ; save new string pointer low byte
0012DDr 2  AA                 TAX                     ; copy string pointer low byte
0012DEr 2  E6 A5              INC   Nbendh            ; correct high byte (move sets high byte -1)
0012E0r 2  A5 A5              LDA   Nbendh            ; get new string pointer high byte
0012E2r 2  C8                 INY                     ; point to descriptor high byte
0012E3r 2  91 9C              STA   (garb_l),Y        ; save new string pointer high byte
0012E5r 2  4C rr rr           JMP   LAB_214B          ; re-run routine from last ending
0012E8r 2                                             ; (but don't collect this string)
0012E8r 2               
0012E8r 2               ; concatenate
0012E8r 2               ; add strings, string 1 is in descriptor des_pl, string 2 is in line
0012E8r 2               
0012E8r 2               LAB_224D
0012E8r 2  A5 AF              LDA   des_ph            ; get descriptor pointer high byte
0012EAr 2  48                 PHA                     ; put on stack
0012EBr 2  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
0012EDr 2  48                 PHA                     ; put on stack
0012EEr 2               ; *** begin patch  2.22p5.4  concatenate MINUS or NOT() crashes EhBASIC  ***
0012EEr 2               ; *** add extra label to verify originating function
0012EEr 2               LAB_224Da
0012EEr 2               ; *** end patch    2.22p5.4  concatenate MINUS or NOT() crashes EhBASIC  ***
0012EEr 2  20 rr rr           JSR   LAB_GVAL          ; get value from line
0012F1r 2  20 rr rr           JSR   LAB_CTST          ; check if source is string, else do type mismatch
0012F4r 2  68                 PLA                     ; get descriptor pointer low byte back
0012F5r 2  85 B8              STA   ssptr_l           ; set pointer low byte
0012F7r 2  68                 PLA                     ; get descriptor pointer high byte back
0012F8r 2  85 B9              STA   ssptr_h           ; set pointer high byte
0012FAr 2  A0 00              LDY   #$00              ; clear index
0012FCr 2  B1 B8              LDA   (ssptr_l),Y       ; get length_1 from descriptor
0012FEr 2  18                 CLC                     ; clear carry for add
0012FFr 2  71 AE              ADC   (des_pl),Y        ; add length_2
001301r 2  90 05              BCC   LAB_226D          ; branch if no overflow
001303r 2               
001303r 2  A2 1A              LDX   #$1A              ; else set error code $1A ("String too long" error)
001305r 2  4C rr rr           JMP   LAB_XERR          ; do error #X, then warm start
001308r 2               
001308r 2               LAB_226D
001308r 2  20 rr rr           JSR   LAB_209C          ; copy des_pl/h to des_2l/h and make string space A bytes
00130Br 2                                             ; long
00130Br 2  20 rr rr           JSR   LAB_228A          ; copy string from descriptor (sdescr) to (Sutill)
00130Er 2  A5 9E              LDA   des_2l            ; get descriptor pointer low byte
001310r 2  A4 9F              LDY   des_2h            ; get descriptor pointer high byte
001312r 2  20 rr rr           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
001315r 2                                             ; returns with A = length, ut1_pl = pointer low byte,
001315r 2                                             ; ut1_ph = pointer high byte
001315r 2  20 rr rr           JSR   LAB_229C          ; store string A bytes long from (ut1_pl) to (Sutill)
001318r 2  A5 B8              LDA   ssptr_l           ;.set descriptor pointer low byte
00131Ar 2  A4 B9              LDY   ssptr_h           ;.set descriptor pointer high byte
00131Cr 2  20 rr rr           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
00131Fr 2                                             ; returns with A = length, X=ut1_pl=pointer low byte,
00131Fr 2                                             ; Y=ut1_ph=pointer high byte
00131Fr 2  20 rr rr           JSR   LAB_RTST          ; check for space on descriptor stack then put string
001322r 2                                             ; address and length on descriptor stack and update stack
001322r 2                                             ; pointers
001322r 2  4C rr rr           JMP   LAB_1ADB          ;.continue evaluation
001325r 2               
001325r 2               ; copy string from descriptor (sdescr) to (Sutill)
001325r 2               
001325r 2               LAB_228A
001325r 2  A0 00              LDY   #$00              ; clear index
001327r 2  B1 B8              LDA   (sdescr),Y        ; get string length
001329r 2  48                 PHA                     ; save on stack
00132Ar 2  C8                 INY                     ; increment index
00132Br 2  B1 B8              LDA   (sdescr),Y        ; get source string pointer low byte
00132Dr 2  AA                 TAX                     ; copy to X
00132Er 2  C8                 INY                     ; increment index
00132Fr 2  B1 B8              LDA   (sdescr),Y        ; get source string pointer high byte
001331r 2  A8                 TAY                     ; copy to Y
001332r 2  68                 PLA                     ; get length back
001333r 2               
001333r 2               ; store string A bytes long from YX to (Sutill)
001333r 2               
001333r 2               LAB_2298
001333r 2  86 71              STX   ut1_pl            ; save source string pointer low byte
001335r 2  84 72              STY   ut1_ph            ; save source string pointer high byte
001337r 2               
001337r 2               ; store string A bytes long from (ut1_pl) to (Sutill)
001337r 2               
001337r 2               LAB_229C
001337r 2  AA                 TAX                     ; copy length to index (don't count with Y)
001338r 2  F0 14              BEQ   LAB_22B2          ; branch if = $0 (null string) no need to add zero length
00133Ar 2               
00133Ar 2  A0 00              LDY   #$00              ; zero pointer (copy forward)
00133Cr 2               LAB_22A0
00133Cr 2  B1 71              LDA   (ut1_pl),Y        ; get source byte
00133Er 2  91 83              STA   (Sutill),Y        ; save destination byte
001340r 2               
001340r 2  C8                 INY                     ; increment index
001341r 2  CA                 DEX                     ; decrement counter
001342r 2  D0 F8              BNE   LAB_22A0          ; loop while <> 0
001344r 2               
001344r 2  98                 TYA                     ; restore length from Y
001345r 2               LAB_22A9
001345r 2  18                 CLC                     ; clear carry for add
001346r 2  65 83              ADC   Sutill            ; add string utility ptr low byte
001348r 2  85 83              STA   Sutill            ; save string utility ptr low byte
00134Ar 2  90 02              BCC   LAB_22B2          ; branch if no carry
00134Cr 2               
00134Cr 2  E6 84              INC   Sutilh            ; else increment string utility ptr high byte
00134Er 2               LAB_22B2
00134Er 2  60                 RTS
00134Fr 2               
00134Fr 2               ; evaluate string
00134Fr 2               
00134Fr 2               LAB_EVST
00134Fr 2  20 rr rr           JSR   LAB_CTST          ; check if source is string, else do type mismatch
001352r 2               
001352r 2               ; pop string off descriptor stack, or from top of string space
001352r 2               ; returns with A = length, X=pointer low byte, Y=pointer high byte
001352r 2               
001352r 2               LAB_22B6
001352r 2  A5 AE              LDA   des_pl            ; get descriptor pointer low byte
001354r 2  A4 AF              LDY   des_ph            ; get descriptor pointer high byte
001356r 2               
001356r 2               ; pop (YA) descriptor off stack or from top of string space
001356r 2               ; returns with A = length, X=ut1_pl=pointer low byte, Y=ut1_ph=pointer high byte
001356r 2               
001356r 2               LAB_22BA
001356r 2  85 71              STA   ut1_pl            ; save descriptor pointer low byte
001358r 2  84 72              STY   ut1_ph            ; save descriptor pointer high byte
00135Ar 2  20 rr rr           JSR   LAB_22EB          ; clean descriptor stack, YA = pointer
00135Dr 2  08                 PHP                     ; save status flags
00135Er 2  A0 00              LDY   #$00              ; clear index
001360r 2  B1 71              LDA   (ut1_pl),Y        ; get length from string descriptor
001362r 2  48                 PHA                     ; put on stack
001363r 2  C8                 INY                     ; increment index
001364r 2  B1 71              LDA   (ut1_pl),Y        ; get string pointer low byte from descriptor
001366r 2  AA                 TAX                     ; copy to X
001367r 2  C8                 INY                     ; increment index
001368r 2  B1 71              LDA   (ut1_pl),Y        ; get string pointer high byte from descriptor
00136Ar 2  A8                 TAY                     ; copy to Y
00136Br 2  68                 PLA                     ; get string length back
00136Cr 2  28                 PLP                     ; restore status
00136Dr 2  D0 13              BNE   LAB_22E6          ; branch if pointer <> last_sl,last_sh
00136Fr 2               
00136Fr 2  C4 82              CPY   Sstorh            ; compare bottom of string space high byte
001371r 2  D0 0F              BNE   LAB_22E6          ; branch if <>
001373r 2               
001373r 2  E4 81              CPX   Sstorl            ; else compare bottom of string space low byte
001375r 2  D0 0B              BNE   LAB_22E6          ; branch if <>
001377r 2               
001377r 2  48                 PHA                     ; save string length
001378r 2  18                 CLC                     ; clear carry for add
001379r 2  65 81              ADC   Sstorl            ; add bottom of string space low byte
00137Br 2  85 81              STA   Sstorl            ; save bottom of string space low byte
00137Dr 2  90 02              BCC   LAB_22E5          ; skip increment if no overflow
00137Fr 2               
00137Fr 2  E6 82              INC   Sstorh            ; increment bottom of string space high byte
001381r 2               LAB_22E5
001381r 2  68                 PLA                     ; restore string length
001382r 2               LAB_22E6
001382r 2  86 71              STX   ut1_pl            ; save string pointer low byte
001384r 2  84 72              STY   ut1_ph            ; save string pointer high byte
001386r 2  60                 RTS
001387r 2               
001387r 2               ; clean descriptor stack, YA = pointer
001387r 2               ; checks if AY is on the descriptor stack, if so does a stack discard
001387r 2               
001387r 2               LAB_22EB
001387r 2  C4 67              CPY   last_sh           ; compare pointer high byte
001389r 2  D0 0C              BNE   LAB_22FB          ; exit if <>
00138Br 2               
00138Br 2  C5 66              CMP   last_sl           ; compare pointer low byte
00138Dr 2  D0 08              BNE   LAB_22FB          ; exit if <>
00138Fr 2               
00138Fr 2  85 65              STA   next_s            ; save descriptor stack pointer
001391r 2  E9 03              SBC   #$03              ; -3
001393r 2  85 66              STA   last_sl           ; save low byte -3
001395r 2  A0 00              LDY   #$00              ; clear high byte
001397r 2               LAB_22FB
001397r 2  60                 RTS
001398r 2               
001398r 2               ; perform CHR$()
001398r 2               
001398r 2               LAB_CHRS
001398r 2  20 rr rr           JSR   LAB_EVBY          ; evaluate byte expression, result in X
00139Br 2  8A                 TXA                     ; copy to A
00139Cr 2  48                 PHA                     ; save character
00139Dr 2  A9 01              LDA   #$01              ; string is single byte
00139Fr 2  20 rr rr           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
0013A2r 2                                             ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
0013A2r 2  68                 PLA                     ; get character back
0013A3r 2  A0 00              LDY   #$00              ; clear index
0013A5r 2  91 AD              STA   (str_pl),Y        ; save byte in string (byte IS string!)
0013A7r 2  4C rr rr           JMP   LAB_RTST          ; check for space on descriptor stack then put string
0013AAr 2                                             ; address and length on descriptor stack and update stack
0013AAr 2                                             ; pointers
0013AAr 2               
0013AAr 2               ; perform LEFT$()
0013AAr 2               
0013AAr 2               LAB_LEFT
0013AAr 2  48                 PHA                     ; push byte parameter
0013ABr 2  20 rr rr           JSR   LAB_236F          ; pull string data and byte parameter from stack
0013AEr 2                                             ; return pointer in des_2l/h, byte in A (and X), Y=0
0013AEr 2  D1 9E              CMP   (des_2l),Y        ; compare byte parameter with string length
0013B0r 2  98                 TYA                     ; clear A
0013B1r 2  F0 09              BEQ   LAB_2316          ; go do string copy (branch always)
0013B3r 2               
0013B3r 2               ; perform RIGHT$()
0013B3r 2               
0013B3r 2               LAB_RIGHT
0013B3r 2  48                 PHA                     ; push byte parameter
0013B4r 2  20 rr rr           JSR   LAB_236F          ; pull string data and byte parameter from stack
0013B7r 2                                             ; return pointer in des_2l/h, byte in A (and X), Y=0
0013B7r 2  18                 CLC                     ; clear carry for add-1
0013B8r 2  F1 9E              SBC   (des_2l),Y        ; subtract string length
0013BAr 2  49 FF              EOR   #$FF              ; invert it (A=LEN(expression$)-l)
0013BCr 2               
0013BCr 2               LAB_2316
0013BCr 2  90 04              BCC   LAB_231C          ; branch if string length > byte parameter
0013BEr 2               
0013BEr 2  B1 9E              LDA   (des_2l),Y        ; else make parameter = length
0013C0r 2  AA                 TAX                     ; copy to byte parameter copy
0013C1r 2  98                 TYA                     ; clear string start offset
0013C2r 2               LAB_231C
0013C2r 2  48                 PHA                     ; save string start offset
0013C3r 2               LAB_231D
0013C3r 2  8A                 TXA                     ; copy byte parameter (or string length if <)
0013C4r 2               LAB_231E
0013C4r 2  48                 PHA                     ; save string length
0013C5r 2  20 rr rr           JSR   LAB_MSSP          ; make string space A bytes long A=$AC=length,
0013C8r 2                                             ; X=$AD=Sutill=ptr low byte, Y=$AE=Sutilh=ptr high byte
0013C8r 2  A5 9E              LDA   des_2l            ; get descriptor pointer low byte
0013CAr 2  A4 9F              LDY   des_2h            ; get descriptor pointer high byte
0013CCr 2  20 rr rr           JSR   LAB_22BA          ; pop (YA) descriptor off stack or from top of string space
0013CFr 2                                             ; returns with A = length, X=ut1_pl=pointer low byte,
0013CFr 2                                             ; Y=ut1_ph=pointer high byte
0013CFr 2  68                 PLA                     ; get string length back
0013D0r 2  A8                 TAY                     ; copy length to Y
0013D1r 2  68                 PLA                     ; get string start offset back
0013D2r 2  18                 CLC                     ; clear carry for add
0013D3r 2  65 71              ADC   ut1_pl            ; add start offset to string start pointer low byte
0013D5r 2  85 71              STA   ut1_pl            ; save string start pointer low byte
0013D7r 2  90 02              BCC   LAB_2335          ; branch if no overflow
0013D9r 2               
0013D9r 2  E6 72              INC   ut1_ph            ; else increment string start pointer high byte
0013DBr 2               LAB_2335
0013DBr 2  98                 TYA                     ; copy length to A
0013DCr 2  20 rr rr           JSR   LAB_229C          ; store string A bytes long from (ut1_pl) to (Sutill)
0013DFr 2  4C rr rr           JMP   LAB_RTST          ; check for space on descriptor stack then put string
0013E2r 2                                             ; address and length on descriptor stack and update stack
0013E2r 2                                             ; pointers
0013E2r 2               
0013E2r 2               ; perform MID$()
0013E2r 2               
0013E2r 2               LAB_MIDS
0013E2r 2  48                 PHA                     ; push byte parameter
0013E3r 2  A9 FF              LDA   #$FF              ; set default length = 255
0013E5r 2  85 AF              STA   mids_l            ; save default length
0013E7r 2  20 C2 00           JSR   LAB_GBYT          ; scan memory
0013EAr 2  C9 29              CMP   #')'              ; compare with ")"
0013ECr 2  F0 06              BEQ   LAB_2358          ; branch if = ")" (skip second byte get)
0013EEr 2               
0013EEr 2  20 rr rr           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
0013F1r 2  20 rr rr           JSR   LAB_GTBY          ; get byte parameter (use copy in mids_l)
0013F4r 2               LAB_2358
0013F4r 2  20 rr rr           JSR   LAB_236F          ; pull string data and byte parameter from stack
0013F7r 2                                             ; return pointer in des_2l/h, byte in A (and X), Y=0
0013F7r 2  CA                 DEX                     ; decrement start index
0013F8r 2  8A                 TXA                     ; copy to A
0013F9r 2  48                 PHA                     ; save string start offset
0013FAr 2  18                 CLC                     ; clear carry for sub-1
0013FBr 2  A2 00              LDX   #$00              ; clear output string length
0013FDr 2  F1 9E              SBC   (des_2l),Y        ; subtract string length
0013FFr 2  B0 C2              BCS   LAB_231D          ; if start>string length go do null string
001401r 2               
001401r 2  49 FF              EOR   #$FF              ; complement -length
001403r 2  C5 AF              CMP   mids_l            ; compare byte parameter
001405r 2  90 BD              BCC   LAB_231E          ; if length>remaining string go do RIGHT$
001407r 2               
001407r 2  A5 AF              LDA   mids_l            ; get length byte
001409r 2  B0 B9              BCS   LAB_231E          ; go do string copy (branch always)
00140Br 2               
00140Br 2               ; pull string data and byte parameter from stack
00140Br 2               ; return pointer in des_2l/h, byte in A (and X), Y=0
00140Br 2               
00140Br 2               LAB_236F
00140Br 2  20 rr rr           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
00140Er 2  68                 PLA                     ; pull return address low byte (return address)
00140Fr 2  85 A2              STA   Fnxjpl            ; save functions jump vector low byte
001411r 2  68                 PLA                     ; pull return address high byte (return address)
001412r 2  85 A3              STA   Fnxjph            ; save functions jump vector high byte
001414r 2  68                 PLA                     ; pull byte parameter
001415r 2  AA                 TAX                     ; copy byte parameter to X
001416r 2  68                 PLA                     ; pull string pointer low byte
001417r 2  85 9E              STA   des_2l            ; save it
001419r 2  68                 PLA                     ; pull string pointer high byte
00141Ar 2  85 9F              STA   des_2h            ; save it
00141Cr 2  A0 00              LDY   #$00              ; clear index
00141Er 2  8A                 TXA                     ; copy byte parameter
00141Fr 2  F0 79              BEQ   LAB_23A8          ; if null do function call error then warm start
001421r 2               
001421r 2  E6 A2              INC   Fnxjpl            ; increment function jump vector low byte
001423r 2                                             ; (JSR pushes return addr-1. this is all very nice
001423r 2                                             ; but will go tits up if either call is on a page
001423r 2                                             ; boundary!)
001423r 2  6C A2 00           JMP   (Fnxjpl)          ; in effect, RTS
001426r 2               
001426r 2               ; perform LCASE$()
001426r 2               
001426r 2               LAB_LCASE
001426r 2  20 rr rr           JSR   LAB_EVST          ; evaluate string
001429r 2  85 AC              STA   str_ln            ; set string length
00142Br 2  A8                 TAY                     ; copy length to Y
00142Cr 2  F0 38              BEQ   NoString          ; branch if null string
00142Er 2               
00142Er 2  20 rr rr           JSR   LAB_MSSP          ; make string space A bytes long A=length,
001431r 2                                             ; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
001431r 2  86 AD              STX   str_pl            ; save string pointer low byte
001433r 2  84 AE              STY   str_ph            ; save string pointer high byte
001435r 2  A8                 TAY                     ; get string length back
001436r 2               
001436r 2               LC_loop
001436r 2  88                 DEY                     ; decrement index
001437r 2  B1 71              LDA   (ut1_pl),Y        ; get byte from string
001439r 2  20 rr rr           JSR   LAB_1D82          ; is character "A" to "Z"
00143Cr 2  90 02              BCC   NoUcase           ; branch if not upper case alpha
00143Er 2               
00143Er 2  09 20              ORA   #$20              ; convert upper to lower case
001440r 2               NoUcase
001440r 2  91 83              STA   (Sutill),Y        ; save byte back to string
001442r 2  98                 TYA                     ; test index
001443r 2  D0 F1              BNE   LC_loop           ; loop if not all done
001445r 2               
001445r 2  F0 1F              BEQ   NoString          ; tidy up and exit, branch always
001447r 2               
001447r 2               ; perform UCASE$()
001447r 2               
001447r 2               LAB_UCASE
001447r 2  20 rr rr           JSR   LAB_EVST          ; evaluate string
00144Ar 2  85 AC              STA   str_ln            ; set string length
00144Cr 2  A8                 TAY                     ; copy length to Y
00144Dr 2  F0 17              BEQ   NoString          ; branch if null string
00144Fr 2               
00144Fr 2  20 rr rr           JSR   LAB_MSSP          ; make string space A bytes long A=length,
001452r 2                                             ; X=Sutill=ptr low byte, Y=Sutilh=ptr high byte
001452r 2  86 AD              STX   str_pl            ; save string pointer low byte
001454r 2  84 AE              STY   str_ph            ; save string pointer high byte
001456r 2  A8                 TAY                     ; get string length back
001457r 2               
001457r 2               UC_loop
001457r 2  88                 DEY                     ; decrement index
001458r 2  B1 71              LDA   (ut1_pl),Y        ; get byte from string
00145Ar 2  20 rr rr           JSR   LAB_CASC          ; is character "a" to "z" (or "A" to "Z")
00145Dr 2  90 02              BCC   NoLcase           ; branch if not alpha
00145Fr 2               
00145Fr 2  29 DF              AND   #$DF              ; convert lower to upper case
001461r 2               NoLcase
001461r 2  91 83              STA   (Sutill),Y        ; save byte back to string
001463r 2  98                 TYA                     ; test index
001464r 2  D0 F1              BNE   UC_loop           ; loop if not all done
001466r 2               
001466r 2               NoString
001466r 2  4C rr rr           JMP   LAB_RTST          ; check for space on descriptor stack then put string
001469r 2                                             ; address and length on descriptor stack and update stack
001469r 2                                             ; pointers
001469r 2               
001469r 2               ; perform SADD()
001469r 2               
001469r 2               LAB_SADD
001469r 2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
00146Cr 2  20 rr rr           JSR   LAB_GVAR          ; get var address
00146Fr 2               
00146Fr 2  20 rr rr           JSR   LAB_1BFB          ; scan for ")", else do syntax error then warm start
001472r 2  20 rr rr           JSR   LAB_CTST          ; check if source is string, else do type mismatch
001475r 2               
001475r 2  A0 02              LDY   #$02              ; index to string pointer high byte
001477r 2  B1 95              LDA   (Cvaral),Y        ; get string pointer high byte
001479r 2  AA                 TAX                     ; copy string pointer high byte to X
00147Ar 2  88                 DEY                     ; index to string pointer low byte
00147Br 2  B1 95              LDA   (Cvaral),Y        ; get string pointer low byte
00147Dr 2  A8                 TAY                     ; copy string pointer low byte to Y
00147Er 2  8A                 TXA                     ; copy string pointer high byte to A
00147Fr 2  4C rr rr           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
001482r 2               
001482r 2               ; perform LEN()
001482r 2               
001482r 2               LAB_LENS
001482r 2  20 rr rr           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
001485r 2  4C rr rr           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
001488r 2               
001488r 2               ; evaluate string, get length in Y
001488r 2               
001488r 2               LAB_ESGL
001488r 2  20 rr rr           JSR   LAB_EVST          ; evaluate string
00148Br 2  A8                 TAY                     ; copy length to Y
00148Cr 2  60                 RTS
00148Dr 2               
00148Dr 2               ; perform ASC()
00148Dr 2               
00148Dr 2               LAB_ASC
00148Dr 2  20 rr rr           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
001490r 2  F0 08              BEQ   LAB_23A8          ; if null do function call error then warm start
001492r 2               
001492r 2  A0 00              LDY   #$00              ; set index to first character
001494r 2  B1 71              LDA   (ut1_pl),Y        ; get byte
001496r 2  A8                 TAY                     ; copy to Y
001497r 2  4C rr rr           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
00149Ar 2               
00149Ar 2               ; do function call error then warm start
00149Ar 2               
00149Ar 2               LAB_23A8
00149Ar 2  4C rr rr           JMP   LAB_FCER          ; do function call error then warm start
00149Dr 2               
00149Dr 2               ; scan and get byte parameter
00149Dr 2               
00149Dr 2               LAB_SGBY
00149Dr 2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
0014A0r 2               
0014A0r 2               ; get byte parameter
0014A0r 2               
0014A0r 2               LAB_GTBY
0014A0r 2  20 rr rr           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
0014A3r 2                                             ; else do type mismatch
0014A3r 2               
0014A3r 2               ; evaluate byte expression, result in X
0014A3r 2               
0014A3r 2               LAB_EVBY
0014A3r 2  20 rr rr           JSR   LAB_EVPI          ; evaluate integer expression (no check)
0014A6r 2               
0014A6r 2  A4 AE              LDY   FAC1_2            ; get FAC1 mantissa2
0014A8r 2  D0 F0              BNE   LAB_23A8          ; if top byte <> 0 do function call error then warm start
0014AAr 2               
0014AAr 2  A6 AF              LDX   FAC1_3            ; get FAC1 mantissa3
0014ACr 2  4C C2 00           JMP   LAB_GBYT          ; scan memory and return
0014AFr 2               
0014AFr 2               ; perform VAL()
0014AFr 2               
0014AFr 2               LAB_VAL
0014AFr 2  20 rr rr           JSR   LAB_ESGL          ; evaluate string, get length in A (and Y)
0014B2r 2  D0 03              BNE   LAB_23C5          ; branch if not null string
0014B4r 2               
0014B4r 2                                             ; string was null so set result = $00
0014B4r 2  4C rr rr           JMP   LAB_24F1          ; clear FAC1 exponent and sign and return
0014B7r 2               
0014B7r 2               LAB_23C5
0014B7r 2               ; *** begin patch  2.22p5.7  VAL() may cause string variables to be trashed
0014B7r 2               ; *** replace
0014B7r 2               ;      LDX   Bpntrl            ; get BASIC execute pointer low byte
0014B7r 2               ;      LDY   Bpntrh            ; get BASIC execute pointer high byte
0014B7r 2               ;      STX   Btmpl             ; save BASIC execute pointer low byte
0014B7r 2               ;      STY   Btmph             ; save BASIC execute pointer high byte
0014B7r 2               ;      LDX   ut1_pl            ; get string pointer low byte
0014B7r 2               ;      STX   Bpntrl            ; save as BASIC execute pointer low byte
0014B7r 2               ;      CLC                     ; clear carry
0014B7r 2               ;      ADC   ut1_pl            ; add string length
0014B7r 2               ;      STA   ut2_pl            ; save string end low byte
0014B7r 2               ;      LDA   ut1_ph            ; get string pointer high byte
0014B7r 2               ;      STA   Bpntrh            ; save as BASIC execute pointer high byte
0014B7r 2               ;      ADC   #$00              ; add carry to high byte
0014B7r 2               ;      STA   ut2_ph            ; save string end high byte
0014B7r 2               ;      LDY   #$00              ; set index to $00
0014B7r 2               ;      LDA   (ut2_pl),Y        ; get string end +1 byte
0014B7r 2               ;      PHA                     ; push it
0014B7r 2               ;      TYA                     ; clear A
0014B7r 2               ;      STA   (ut2_pl),Y        ; terminate string with $00
0014B7r 2               ;      JSR   LAB_GBYT          ; scan memory
0014B7r 2               ;      JSR   LAB_2887          ; get FAC1 from string
0014B7r 2               ;      PLA                     ; restore string end +1 byte
0014B7r 2               ;      LDY   #$00              ; set index to zero
0014B7r 2               ;      STA   (ut2_pl),Y        ; put string end byte back
0014B7r 2               ; *** with
0014B7r 2  48                 PHA                     ; save length
0014B8r 2  C8                 INY                     ; string length +1
0014B9r 2  98                 TYA
0014BAr 2  20 rr rr           JSR   LAB_MSSP          ; allocate temp string +1 bytes long
0014BDr 2  68                 PLA                     ; get length back
0014BEr 2  20 rr rr           JSR   LAB_229C          ; copy string (ut1_pl) -> (Sutill) for A bytes
0014C1r 2  A9 00              LDA   #0                ; add delimiter to end of string
0014C3r 2  A8                 TAY
0014C4r 2  91 83              STA   (Sutill),Y
0014C6r 2  A6 C3              LDX   Bpntrl            ; save BASIC execute pointer low byte
0014C8r 2  A4 C4              LDY   Bpntrh
0014CAr 2  86 BA              STX   Btmpl
0014CCr 2  84 BB              STY   Btmph
0014CEr 2  A6 AD              LDX   str_pl            ; point to temporary string
0014D0r 2  A4 AE              LDY   str_ph
0014D2r 2  86 C3              STX   Bpntrl
0014D4r 2  84 C4              STY   Bpntrh
0014D6r 2  20 C2 00           JSR   LAB_GBYT          ; scan memory
0014D9r 2  20 rr rr           JSR   LAB_2887          ; get FAC1 from string
0014DCr 2               ; *** end patch    2.22p5.7  VAL() may cause string variables to be trashed
0014DCr 2               
0014DCr 2               ; restore BASIC execute pointer from temp (Btmpl/Btmph)
0014DCr 2               
0014DCr 2               LAB_23F3
0014DCr 2  A6 BA              LDX   Btmpl             ; get BASIC execute pointer low byte back
0014DEr 2  A4 BB              LDY   Btmph             ; get BASIC execute pointer high byte back
0014E0r 2  86 C3              STX   Bpntrl            ; save BASIC execute pointer low byte
0014E2r 2  84 C4              STY   Bpntrh            ; save BASIC execute pointer high byte
0014E4r 2  60                 RTS
0014E5r 2               
0014E5r 2               ; get two parameters for POKE or WAIT
0014E5r 2               
0014E5r 2               LAB_GADB
0014E5r 2  20 rr rr           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
0014E8r 2                                             ; else do type mismatch
0014E8r 2  20 rr rr           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
0014EBr 2               
0014EBr 2               ; scan for "," and get byte, else do Syntax error then warm start
0014EBr 2               
0014EBr 2               LAB_SCGB
0014EBr 2  20 rr rr           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
0014EEr 2  A5 12              LDA   Itemph            ; save temporary integer high byte
0014F0r 2  48                 PHA                     ; on stack
0014F1r 2  A5 11              LDA   Itempl            ; save temporary integer low byte
0014F3r 2  48                 PHA                     ; on stack
0014F4r 2  20 rr rr           JSR   LAB_GTBY          ; get byte parameter
0014F7r 2  68                 PLA                     ; pull low byte
0014F8r 2  85 11              STA   Itempl            ; restore temporary integer low byte
0014FAr 2  68                 PLA                     ; pull high byte
0014FBr 2  85 12              STA   Itemph            ; restore temporary integer high byte
0014FDr 2  60                 RTS
0014FEr 2               
0014FEr 2               ; convert float to fixed routine. accepts any value that fits in 24 bits, +ve or
0014FEr 2               ; -ve and converts it into a right truncated integer in Itempl and Itemph
0014FEr 2               
0014FEr 2               ; save unsigned 16 bit integer part of FAC1 in temporary integer
0014FEr 2               
0014FEr 2               LAB_F2FX
0014FEr 2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
001500r 2  C9 98              CMP   #$98              ; compare with exponent = 2^24
001502r 2  B0 96              BCS   LAB_23A8          ; if >= do function call error then warm start
001504r 2               
001504r 2               LAB_F2FU
001504r 2  20 rr rr           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
001507r 2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
001509r 2  A4 AF              LDY   FAC1_3            ; get FAC1 mantissa3
00150Br 2  84 11              STY   Itempl            ; save temporary integer low byte
00150Dr 2  85 12              STA   Itemph            ; save temporary integer high byte
00150Fr 2  60                 RTS
001510r 2               
001510r 2               ; perform PEEK()
001510r 2               
001510r 2               LAB_PEEK
001510r 2  20 rr rr           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
001513r 2  A2 00              LDX   #$00              ; clear index
001515r 2  A1 11              LDA   (Itempl,X)        ; get byte via temporary integer (addr)
001517r 2  A8                 TAY                     ; copy byte to Y
001518r 2  4C rr rr           JMP   LAB_1FD0          ; convert Y to byte in FAC1 and return
00151Br 2               
00151Br 2               ; perform POKE
00151Br 2               
00151Br 2               LAB_POKE
00151Br 2  20 rr rr           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
00151Er 2  8A                 TXA                     ; copy byte argument to A
00151Fr 2  A2 00              LDX   #$00              ; clear index
001521r 2  81 11              STA   (Itempl,X)        ; save byte via temporary integer (addr)
001523r 2  60                 RTS
001524r 2               
001524r 2               ; perform DEEK()
001524r 2               
001524r 2               LAB_DEEK
001524r 2  20 rr rr           JSR   LAB_F2FX          ; save integer part of FAC1 in temporary integer
001527r 2  A2 00              LDX   #$00              ; clear index
001529r 2  A1 11              LDA   (Itempl,X)        ; PEEK low byte
00152Br 2  A8                 TAY                     ; copy to Y
00152Cr 2  E6 11              INC   Itempl            ; increment pointer low byte
00152Er 2  D0 02              BNE   Deekh             ; skip high increment if no rollover
001530r 2               
001530r 2  E6 12              INC   Itemph            ; increment pointer high byte
001532r 2               Deekh
001532r 2  A1 11              LDA   (Itempl,X)        ; PEEK high byte
001534r 2  4C rr rr           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
001537r 2               
001537r 2               ; perform DOKE
001537r 2               
001537r 2               LAB_DOKE
001537r 2  20 rr rr           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
00153Ar 2                                             ; else do type mismatch
00153Ar 2  20 rr rr           JSR   LAB_F2FX          ; convert floating-to-fixed
00153Dr 2               
00153Dr 2  84 97              STY   Frnxtl            ; save pointer low byte (float to fixed returns word in AY)
00153Fr 2  85 98              STA   Frnxth            ; save pointer high byte
001541r 2               
001541r 2  20 rr rr           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
001544r 2  20 rr rr           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
001547r 2                                             ; else do type mismatch
001547r 2  20 rr rr           JSR   LAB_F2FX          ; convert floating-to-fixed
00154Ar 2               
00154Ar 2  98                 TYA                     ; copy value low byte (float to fixed returns word in AY)
00154Br 2  A2 00              LDX   #$00              ; clear index
00154Dr 2  81 97              STA   (Frnxtl,X)        ; POKE low byte
00154Fr 2  E6 97              INC   Frnxtl            ; increment pointer low byte
001551r 2  D0 02              BNE   Dokeh             ; skip high increment if no rollover
001553r 2               
001553r 2  E6 98              INC   Frnxth            ; increment pointer high byte
001555r 2               Dokeh
001555r 2  A5 12              LDA   Itemph            ; get value high byte
001557r 2  81 97              STA   (Frnxtl,X)        ; POKE high byte
001559r 2  4C C2 00           JMP   LAB_GBYT          ; scan memory and return
00155Cr 2               
00155Cr 2               ; perform SWAP
00155Cr 2               
00155Cr 2               LAB_SWAP
00155Cr 2  20 rr rr           JSR   LAB_GVAR          ; get var1 address
00155Fr 2  85 97              STA   Lvarpl            ; save var1 address low byte
001561r 2  84 98              STY   Lvarph            ; save var1 address high byte
001563r 2  A5 5F              LDA   Dtypef            ; get data type flag, $FF=string, $00=numeric
001565r 2  48                 PHA                     ; save data type flag
001566r 2               
001566r 2  20 rr rr           JSR   LAB_1C01          ; scan for "," , else do syntax error then warm start
001569r 2  20 rr rr           JSR   LAB_GVAR          ; get var2 address (pointer in Cvaral/h)
00156Cr 2  68                 PLA                     ; pull var1 data type flag
00156Dr 2  45 5F              EOR   Dtypef            ; compare with var2 data type
00156Fr 2  10 10              BPL   SwapErr           ; exit if not both the same type
001571r 2               
001571r 2  A0 03              LDY   #$03              ; four bytes to swap (either value or descriptor+1)
001573r 2               SwapLp
001573r 2  B1 97              LDA   (Lvarpl),Y        ; get byte from var1
001575r 2  AA                 TAX                     ; save var1 byte
001576r 2  B1 95              LDA   (Cvaral),Y        ; get byte from var2
001578r 2  91 97              STA   (Lvarpl),Y        ; save byte to var1
00157Ar 2  8A                 TXA                     ; restore var1 byte
00157Br 2  91 95              STA   (Cvaral),Y        ; save byte to var2
00157Dr 2  88                 DEY                     ; decrement index
00157Er 2  10 F3              BPL   SwapLp            ; loop until done
001580r 2               
001580r 2  60                 RTS
001581r 2               
001581r 2               SwapErr
001581r 2  4C rr rr           JMP   LAB_1ABC          ; do "Type mismatch" error then warm start
001584r 2               
001584r 2               ; perform CALL
001584r 2               
001584r 2               LAB_CALL
001584r 2  20 rr rr           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
001587r 2                                             ; else do type mismatch
001587r 2  20 rr rr           JSR   LAB_F2FX          ; convert floating-to-fixed
00158Ar 2  A9 rr              LDA   #>CallExit        ; set return address high byte
00158Cr 2  48                 PHA                     ; put on stack
00158Dr 2  A9 rr              LDA   #<CallExit-1      ; set return address low byte
00158Fr 2  48                 PHA                     ; put on stack
001590r 2  6C 11 00           JMP   (Itempl)          ; do indirect jump to user routine
001593r 2               
001593r 2               ; if the called routine exits correctly then it will return to here. this will then get
001593r 2               ; the next byte for the interpreter and return
001593r 2               
001593r 2               CallExit
001593r 2  4C C2 00           JMP   LAB_GBYT          ; scan memory and return
001596r 2               
001596r 2               ; perform WAIT
001596r 2               
001596r 2               LAB_WAIT
001596r 2  20 rr rr           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
001599r 2  86 97              STX   Frnxtl            ; save byte
00159Br 2  A2 00              LDX   #$00              ; clear mask
00159Dr 2  20 C2 00           JSR   LAB_GBYT          ; scan memory
0015A0r 2  F0 03              BEQ   LAB_2441          ; skip if no third argument
0015A2r 2               
0015A2r 2  20 rr rr           JSR   LAB_SCGB          ; scan for "," and get byte, else SN error then warm start
0015A5r 2               LAB_2441
0015A5r 2  86 98              STX   Frnxth            ; save EOR argument
0015A7r 2               LAB_2445
0015A7r 2  B1 11              LDA   (Itempl),Y        ; get byte via temporary integer (addr)
0015A9r 2  45 98              EOR   Frnxth            ; EOR with second argument (mask)
0015ABr 2  25 97              AND   Frnxtl            ; AND with first argument (byte)
0015ADr 2  F0 F8              BEQ   LAB_2445          ; loop if result is zero
0015AFr 2               
0015AFr 2               LAB_244D
0015AFr 2  60                 RTS
0015B0r 2               
0015B0r 2               ; perform subtraction, FAC1 from (AY)
0015B0r 2               
0015B0r 2               LAB_2455
0015B0r 2  20 rr rr           JSR   LAB_264D          ; unpack memory (AY) into FAC2
0015B3r 2               
0015B3r 2               ; perform subtraction, FAC1 from FAC2
0015B3r 2               
0015B3r 2               LAB_SUBTRACT
0015B3r 2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
0015B5r 2  49 FF              EOR   #$FF              ; complement it
0015B7r 2  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
0015B9r 2  45 B7              EOR   FAC2_s            ; EOR with FAC2 sign (b7)
0015BBr 2  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
0015BDr 2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
0015BFr 2  4C rr rr           JMP   LAB_ADD           ; go add FAC2 to FAC1
0015C2r 2               
0015C2r 2               ; perform addition
0015C2r 2               
0015C2r 2               LAB_2467
0015C2r 2  20 rr rr           JSR   LAB_257B          ; shift FACX A times right (>8 shifts)
0015C5r 2  90 4D              BCC   LAB_24A8          ;.go subtract mantissas
0015C7r 2               
0015C7r 2               ; add 0.5 to FAC1
0015C7r 2               
0015C7r 2               LAB_244E
0015C7r 2  A9 rr              LDA   #<LAB_2A96        ; set 0.5 pointer low byte
0015C9r 2  A0 rr              LDY   #>LAB_2A96        ; set 0.5 pointer high byte
0015CBr 2               
0015CBr 2               ; add (AY) to FAC1
0015CBr 2               
0015CBr 2               LAB_246C
0015CBr 2  20 rr rr           JSR   LAB_264D          ; unpack memory (AY) into FAC2
0015CEr 2               
0015CEr 2               ; add FAC2 to FAC1
0015CEr 2               
0015CEr 2               LAB_ADD
0015CEr 2  D0 10              BNE   LAB_2474          ; branch if FAC1 was not zero
0015D0r 2               
0015D0r 2               ; copy FAC2 to FAC1
0015D0r 2               
0015D0r 2               LAB_279B
0015D0r 2  A5 B7              LDA   FAC2_s            ; get FAC2 sign (b7)
0015D2r 2               
0015D2r 2               ; save FAC1 sign and copy ABS(FAC2) to FAC1
0015D2r 2               
0015D2r 2               LAB_279D
0015D2r 2  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
0015D4r 2  A2 04              LDX   #$04              ; 4 bytes to copy
0015D6r 2               LAB_27A1
0015D6r 2  B5 B2              LDA   FAC1_o,X          ; get byte from FAC2,X
0015D8r 2  95 AB              STA   FAC1_e-1,X        ; save byte at FAC1,X
0015DAr 2  CA                 DEX                     ; decrement count
0015DBr 2  D0 F9              BNE   LAB_27A1          ; loop if not all done
0015DDr 2               
0015DDr 2  86 B9              STX   FAC1_r            ; clear FAC1 rounding byte
0015DFr 2  60                 RTS
0015E0r 2               
0015E0r 2                                             ; FAC1 is non zero
0015E0r 2               LAB_2474
0015E0r 2  A6 B9              LDX   FAC1_r            ; get FAC1 rounding byte
0015E2r 2  86 A3              STX   FAC2_r            ; save as FAC2 rounding byte
0015E4r 2  A2 B3              LDX   #FAC2_e           ; set index to FAC2 exponent addr
0015E6r 2  A5 B3              LDA   FAC2_e            ; get FAC2 exponent
0015E8r 2               LAB_247C
0015E8r 2  A8                 TAY                     ; copy exponent
0015E9r 2  F0 C4              BEQ   LAB_244D          ; exit if zero
0015EBr 2               
0015EBr 2  38                 SEC                     ; set carry for subtract
0015ECr 2  E5 AC              SBC   FAC1_e            ; subtract FAC1 exponent
0015EEr 2  F0 24              BEQ   LAB_24A8          ; branch if = (go add mantissa)
0015F0r 2               
0015F0r 2  90 12              BCC   LAB_2498          ; branch if <
0015F2r 2               
0015F2r 2                                             ; FAC2>FAC1
0015F2r 2  84 AC              STY   FAC1_e            ; save FAC1 exponent
0015F4r 2  A4 B7              LDY   FAC2_s            ; get FAC2 sign (b7)
0015F6r 2  84 B0              STY   FAC1_s            ; save FAC1 sign (b7)
0015F8r 2  49 FF              EOR   #$FF              ; complement A
0015FAr 2  69 00              ADC   #$00              ; +1 (twos complement, carry is set)
0015FCr 2  A0 00              LDY   #$00              ; clear Y
0015FEr 2  84 A3              STY   FAC2_r            ; clear FAC2 rounding byte
001600r 2  A2 AC              LDX   #FAC1_e           ; set index to FAC1 exponent addr
001602r 2  D0 04              BNE   LAB_249C          ; branch always
001604r 2               
001604r 2               LAB_2498
001604r 2  A0 00              LDY   #$00              ; clear Y
001606r 2  84 B9              STY   FAC1_r            ; clear FAC1 rounding byte
001608r 2               LAB_249C
001608r 2  C9 F9              CMP   #$F9              ; compare exponent diff with $F9
00160Ar 2  30 B6              BMI   LAB_2467          ; branch if range $79-$F8
00160Cr 2               
00160Cr 2  A8                 TAY                     ; copy exponent difference to Y
00160Dr 2  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
00160Fr 2  56 01              LSR   PLUS_1,X          ; shift FAC? mantissa1
001611r 2  20 rr rr           JSR   LAB_2592          ; shift FACX Y times right
001614r 2               
001614r 2                                             ; exponents are equal now do mantissa subtract
001614r 2               LAB_24A8
001614r 2  24 B8              BIT   FAC_sc            ; test sign compare (FAC1 EOR FAC2)
001616r 2  10 4C              BPL   LAB_24F8          ; if = add FAC2 mantissa to FAC1 mantissa and return
001618r 2               
001618r 2  A0 AC              LDY   #FAC1_e           ; set index to FAC1 exponent addr
00161Ar 2  E0 B3              CPX   #FAC2_e           ; compare X to FAC2 exponent addr
00161Cr 2  F0 02              BEQ   LAB_24B4          ; branch if =
00161Er 2               
00161Er 2  A0 B3              LDY   #FAC2_e           ; else set index to FAC2 exponent addr
001620r 2               
001620r 2                                             ; subtract smaller from bigger (take sign of bigger)
001620r 2               LAB_24B4
001620r 2  38                 SEC                     ; set carry for subtract
001621r 2  49 FF              EOR   #$FF              ; ones complement A
001623r 2  65 A3              ADC   FAC2_r            ; add FAC2 rounding byte
001625r 2  85 B9              STA   FAC1_r            ; save FAC1 rounding byte
001627r 2  B9 03 00           LDA   PLUS_3,Y          ; get FACY mantissa3
00162Ar 2  F5 03              SBC   PLUS_3,X          ; subtract FACX mantissa3
00162Cr 2  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
00162Er 2  B9 02 00           LDA   PLUS_2,Y          ; get FACY mantissa2
001631r 2  F5 02              SBC   PLUS_2,X          ; subtract FACX mantissa2
001633r 2  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
001635r 2  B9 01 00           LDA   PLUS_1,Y          ; get FACY mantissa1
001638r 2  F5 01              SBC   PLUS_1,X          ; subtract FACX mantissa1
00163Ar 2  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
00163Cr 2               
00163Cr 2               ; do ABS and normalise FAC1
00163Cr 2               
00163Cr 2               LAB_24D0
00163Cr 2  B0 03              BCS   LAB_24D5          ; branch if number is +ve
00163Er 2               
00163Er 2  20 rr rr           JSR   LAB_2537          ; negate FAC1
001641r 2               
001641r 2               ; normalise FAC1
001641r 2               
001641r 2               LAB_24D5
001641r 2  A0 00              LDY   #$00              ; clear Y
001643r 2  98                 TYA                     ; clear A
001644r 2  18                 CLC                     ; clear carry for add
001645r 2               LAB_24D9
001645r 2  A6 AD              LDX   FAC1_1            ; get FAC1 mantissa1
001647r 2  D0 3E              BNE   LAB_251B          ; if not zero normalise FAC1
001649r 2               
001649r 2  A6 AE              LDX   FAC1_2            ; get FAC1 mantissa2
00164Br 2  86 AD              STX   FAC1_1            ; save FAC1 mantissa1
00164Dr 2  A6 AF              LDX   FAC1_3            ; get FAC1 mantissa3
00164Fr 2  86 AE              STX   FAC1_2            ; save FAC1 mantissa2
001651r 2  A6 B9              LDX   FAC1_r            ; get FAC1 rounding byte
001653r 2  86 AF              STX   FAC1_3            ; save FAC1 mantissa3
001655r 2  84 B9              STY   FAC1_r            ; clear FAC1 rounding byte
001657r 2  69 08              ADC   #$08              ; add x to exponent offset
001659r 2  C9 18              CMP   #$18              ; compare with $18 (max offset, all bits would be =0)
00165Br 2  D0 E8              BNE   LAB_24D9          ; loop if not max
00165Dr 2               
00165Dr 2               ; clear FAC1 exponent and sign
00165Dr 2               
00165Dr 2               LAB_24F1
00165Dr 2  A9 00              LDA   #$00              ; clear A
00165Fr 2               LAB_24F3
00165Fr 2  85 AC              STA   FAC1_e            ; set FAC1 exponent
001661r 2               
001661r 2               ; save FAC1 sign
001661r 2               
001661r 2               LAB_24F5
001661r 2  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
001663r 2  60                 RTS
001664r 2               
001664r 2               ; add FAC2 mantissa to FAC1 mantissa
001664r 2               
001664r 2               LAB_24F8
001664r 2  65 A3              ADC   FAC2_r            ; add FAC2 rounding byte
001666r 2  85 B9              STA   FAC1_r            ; save FAC1 rounding byte
001668r 2  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
00166Ar 2  65 B6              ADC   FAC2_3            ; add FAC2 mantissa3
00166Cr 2  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
00166Er 2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
001670r 2  65 B5              ADC   FAC2_2            ; add FAC2 mantissa2
001672r 2  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
001674r 2  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
001676r 2  65 B4              ADC   FAC2_1            ; add FAC2 mantissa1
001678r 2  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
00167Ar 2  B0 1A              BCS   LAB_252A          ; if carry then normalise FAC1 for C=1
00167Cr 2               
00167Cr 2  60                 RTS                     ; else just exit
00167Dr 2               
00167Dr 2               LAB_2511
00167Dr 2  69 01              ADC   #$01              ; add 1 to exponent offset
00167Fr 2  06 B9              ASL   FAC1_r            ; shift FAC1 rounding byte
001681r 2  26 AF              ROL   FAC1_3            ; shift FAC1 mantissa3
001683r 2  26 AE              ROL   FAC1_2            ; shift FAC1 mantissa2
001685r 2  26 AD              ROL   FAC1_1            ; shift FAC1 mantissa1
001687r 2               
001687r 2               ; normalise FAC1
001687r 2               
001687r 2               LAB_251B
001687r 2  10 F4              BPL   LAB_2511          ; loop if not normalised
001689r 2               
001689r 2  38                 SEC                     ; set carry for subtract
00168Ar 2  E5 AC              SBC   FAC1_e            ; subtract FAC1 exponent
00168Cr 2  B0 CF              BCS   LAB_24F1          ; branch if underflow (set result = $0)
00168Er 2               
00168Er 2  49 FF              EOR   #$FF              ; complement exponent
001690r 2  69 01              ADC   #$01              ; +1 (twos complement)
001692r 2  85 AC              STA   FAC1_e            ; save FAC1 exponent
001694r 2               
001694r 2               ; test and normalise FAC1 for C=0/1
001694r 2               
001694r 2               LAB_2528
001694r 2  90 0C              BCC   LAB_2536          ; exit if no overflow
001696r 2               
001696r 2               ; normalise FAC1 for C=1
001696r 2               
001696r 2               LAB_252A
001696r 2  E6 AC              INC   FAC1_e            ; increment FAC1 exponent
001698r 2  F0 36              BEQ   LAB_2564          ; if zero do overflow error and warm start
00169Ar 2               
00169Ar 2  66 AD              ROR   FAC1_1            ; shift FAC1 mantissa1
00169Cr 2  66 AE              ROR   FAC1_2            ; shift FAC1 mantissa2
00169Er 2  66 AF              ROR   FAC1_3            ; shift FAC1 mantissa3
0016A0r 2  66 B9              ROR   FAC1_r            ; shift FAC1 rounding byte
0016A2r 2               LAB_2536
0016A2r 2  60                 RTS
0016A3r 2               
0016A3r 2               ; negate FAC1
0016A3r 2               
0016A3r 2               LAB_2537
0016A3r 2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
0016A5r 2  49 FF              EOR   #$FF              ; complement it
0016A7r 2  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
0016A9r 2               
0016A9r 2               ; twos complement FAC1 mantissa
0016A9r 2               
0016A9r 2               LAB_253D
0016A9r 2  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
0016ABr 2  49 FF              EOR   #$FF              ; complement it
0016ADr 2  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
0016AFr 2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
0016B1r 2  49 FF              EOR   #$FF              ; complement it
0016B3r 2  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
0016B5r 2  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
0016B7r 2  49 FF              EOR   #$FF              ; complement it
0016B9r 2  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
0016BBr 2  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
0016BDr 2  49 FF              EOR   #$FF              ; complement it
0016BFr 2  85 B9              STA   FAC1_r            ; save FAC1 rounding byte
0016C1r 2  E6 B9              INC   FAC1_r            ; increment FAC1 rounding byte
0016C3r 2  D0 0A              BNE   LAB_2563          ; exit if no overflow
0016C5r 2               
0016C5r 2               ; increment FAC1 mantissa
0016C5r 2               
0016C5r 2               LAB_2559
0016C5r 2  E6 AF              INC   FAC1_3            ; increment FAC1 mantissa3
0016C7r 2  D0 06              BNE   LAB_2563          ; finished if no rollover
0016C9r 2               
0016C9r 2  E6 AE              INC   FAC1_2            ; increment FAC1 mantissa2
0016CBr 2  D0 02              BNE   LAB_2563          ; finished if no rollover
0016CDr 2               
0016CDr 2  E6 AD              INC   FAC1_1            ; increment FAC1 mantissa1
0016CFr 2               LAB_2563
0016CFr 2  60                 RTS
0016D0r 2               
0016D0r 2               ; do overflow error (overflow exit)
0016D0r 2               
0016D0r 2               LAB_2564
0016D0r 2  A2 0A              LDX   #$0A              ; error code $0A ("Overflow" error)
0016D2r 2  4C rr rr           JMP   LAB_XERR          ; do error #X, then warm start
0016D5r 2               
0016D5r 2               ; shift FCAtemp << A+8 times
0016D5r 2               
0016D5r 2               LAB_2569
0016D5r 2  A2 74              LDX   #FACt_1-1         ; set offset to FACtemp
0016D7r 2               LAB_256B
0016D7r 2  B4 03              LDY   PLUS_3,X          ; get FACX mantissa3
0016D9r 2  84 B9              STY   FAC1_r            ; save as FAC1 rounding byte
0016DBr 2  B4 02              LDY   PLUS_2,X          ; get FACX mantissa2
0016DDr 2  94 03              STY   PLUS_3,X          ; save FACX mantissa3
0016DFr 2  B4 01              LDY   PLUS_1,X          ; get FACX mantissa1
0016E1r 2  94 02              STY   PLUS_2,X          ; save FACX mantissa2
0016E3r 2  A4 B2              LDY   FAC1_o            ; get FAC1 overflow byte
0016E5r 2  94 01              STY   PLUS_1,X          ; save FACX mantissa1
0016E7r 2               
0016E7r 2               ; shift FACX -A times right (> 8 shifts)
0016E7r 2               
0016E7r 2               LAB_257B
0016E7r 2  69 08              ADC   #$08              ; add 8 to shift count
0016E9r 2  30 EC              BMI   LAB_256B          ; go do 8 shift if still -ve
0016EBr 2               
0016EBr 2  F0 EA              BEQ   LAB_256B          ; go do 8 shift if zero
0016EDr 2               
0016EDr 2  E9 08              SBC   #$08              ; else subtract 8 again
0016EFr 2  A8                 TAY                     ; save count to Y
0016F0r 2  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
0016F2r 2  B0 12              BCS   LAB_259A          ;.
0016F4r 2               
0016F4r 2               LAB_2588
0016F4r 2  16 01              ASL   PLUS_1,X          ; shift FACX mantissa1
0016F6r 2  90 02              BCC   LAB_258E          ; branch if +ve
0016F8r 2               
0016F8r 2  F6 01              INC   PLUS_1,X          ; this sets b7 eventually
0016FAr 2               LAB_258E
0016FAr 2  76 01              ROR   PLUS_1,X          ; shift FACX mantissa1 (correct for ASL)
0016FCr 2  76 01              ROR   PLUS_1,X          ; shift FACX mantissa1 (put carry in b7)
0016FEr 2               
0016FEr 2               ; shift FACX Y times right
0016FEr 2               
0016FEr 2               LAB_2592
0016FEr 2  76 02              ROR   PLUS_2,X          ; shift FACX mantissa2
001700r 2  76 03              ROR   PLUS_3,X          ; shift FACX mantissa3
001702r 2  6A                 ROR                     ; shift FACX rounding byte
001703r 2  C8                 INY                     ; increment exponent diff
001704r 2  D0 EE              BNE   LAB_2588          ; branch if range adjust not complete
001706r 2               
001706r 2               LAB_259A
001706r 2  18                 CLC                     ; just clear it
001707r 2  60                 RTS
001708r 2               
001708r 2               ; perform LOG()
001708r 2               
001708r 2               LAB_LOG
001708r 2  20 rr rr           JSR   LAB_27CA          ; test sign and zero
00170Br 2  F0 02              BEQ   LAB_25C4          ; if zero do function call error then warm start
00170Dr 2               
00170Dr 2  10 03              BPL   LAB_25C7          ; skip error if +ve
00170Fr 2               
00170Fr 2               LAB_25C4
00170Fr 2  4C rr rr           JMP   LAB_FCER          ; do function call error then warm start (-ve)
001712r 2               
001712r 2               LAB_25C7
001712r 2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
001714r 2  E9 7F              SBC   #$7F              ; normalise it
001716r 2  48                 PHA                     ; save it
001717r 2  A9 80              LDA   #$80              ; set exponent to zero
001719r 2  85 AC              STA   FAC1_e            ; save FAC1 exponent
00171Br 2  A9 rr              LDA   #<LAB_25AD        ; set 1/root2 pointer low byte
00171Dr 2  A0 rr              LDY   #>LAB_25AD        ; set 1/root2 pointer high byte
00171Fr 2  20 rr rr           JSR   LAB_246C          ; add (AY) to FAC1 (1/root2)
001722r 2  A9 rr              LDA   #<LAB_25B1        ; set root2 pointer low byte
001724r 2  A0 rr              LDY   #>LAB_25B1        ; set root2 pointer high byte
001726r 2  20 rr rr           JSR   LAB_26CA          ; convert AY and do (AY)/FAC1 (root2/(x+(1/root2)))
001729r 2  A9 rr              LDA   #<LAB_259C        ; set 1 pointer low byte
00172Br 2  A0 rr              LDY   #>LAB_259C        ; set 1 pointer high byte
00172Dr 2  20 rr rr           JSR   LAB_2455          ; subtract (AY) from FAC1 ((root2/(x+(1/root2)))-1)
001730r 2  A9 rr              LDA   #<LAB_25A0        ; set pointer low byte to counter
001732r 2  A0 rr              LDY   #>LAB_25A0        ; set pointer high byte to counter
001734r 2  20 rr rr           JSR   LAB_2B6E          ; ^2 then series evaluation
001737r 2  A9 rr              LDA   #<LAB_25B5        ; set -0.5 pointer low byte
001739r 2  A0 rr              LDY   #>LAB_25B5        ; set -0.5 pointer high byte
00173Br 2  20 rr rr           JSR   LAB_246C          ; add (AY) to FAC1
00173Er 2  68                 PLA                     ; restore FAC1 exponent
00173Fr 2  20 rr rr           JSR   LAB_2912          ; evaluate new ASCII digit
001742r 2  A9 rr              LDA   #<LAB_25B9        ; set LOG(2) pointer low byte
001744r 2  A0 rr              LDY   #>LAB_25B9        ; set LOG(2) pointer high byte
001746r 2               
001746r 2               ; do convert AY, FCA1*(AY)
001746r 2               
001746r 2               LAB_25FB
001746r 2  20 rr rr           JSR   LAB_264D          ; unpack memory (AY) into FAC2
001749r 2               LAB_MULTIPLY
001749r 2  F0 4C              BEQ   LAB_264C          ; exit if zero
00174Br 2               
00174Br 2  20 rr rr           JSR   LAB_2673          ; test and adjust accumulators
00174Er 2  A9 00              LDA   #$00              ; clear A
001750r 2  85 75              STA   FACt_1            ; clear temp mantissa1
001752r 2  85 76              STA   FACt_2            ; clear temp mantissa2
001754r 2  85 77              STA   FACt_3            ; clear temp mantissa3
001756r 2  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
001758r 2  20 rr rr           JSR   LAB_2622          ; go do shift/add FAC2
00175Br 2  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
00175Dr 2  20 rr rr           JSR   LAB_2622          ; go do shift/add FAC2
001760r 2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
001762r 2  20 rr rr           JSR   LAB_2622          ; go do shift/add FAC2
001765r 2  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
001767r 2  20 rr rr           JSR   LAB_2627          ; go do shift/add FAC2
00176Ar 2  4C rr rr           JMP   LAB_273C          ; copy temp to FAC1, normalise and return
00176Dr 2               
00176Dr 2               LAB_2622
00176Dr 2  D0 04              BNE   LAB_2627          ; branch if byte <> zero
00176Fr 2               ; *** begin patch  2.22p5.6  floating point multiply rounding bug
00176Fr 2               ; *** replace
00176Fr 2               ;      JMP   LAB_2569          ; shift FCAtemp << A+8 times
00176Fr 2               ;
00176Fr 2               ;                              ; else do shift and add
00176Fr 2               ;LAB_2627
00176Fr 2               ;      LSR                     ; shift byte
00176Fr 2               ;      ORA   #$80              ; set top bit (mark for 8 times)
00176Fr 2               ; *** with
00176Fr 2  38                 SEC
001770r 2  4C rr rr           JMP   LAB_2569          ; shift FACtemp << A+8 times
001773r 2               
001773r 2                                             ; else do shift and add
001773r 2               LAB_2627
001773r 2  38                 SEC                     ; set top bit (mark for 8 times)
001774r 2  6A                 ROR
001775r 2               ; *** end patch    2.22p5.6  floating point multiply rounding bug
001775r 2               LAB_262A
001775r 2  A8                 TAY                     ; copy result
001776r 2  90 13              BCC   LAB_2640          ; skip next if bit was zero
001778r 2               
001778r 2  18                 CLC                     ; clear carry for add
001779r 2  A5 77              LDA   FACt_3            ; get temp mantissa3
00177Br 2  65 B6              ADC   FAC2_3            ; add FAC2 mantissa3
00177Dr 2  85 77              STA   FACt_3            ; save temp mantissa3
00177Fr 2  A5 76              LDA   FACt_2            ; get temp mantissa2
001781r 2  65 B5              ADC   FAC2_2            ; add FAC2 mantissa2
001783r 2  85 76              STA   FACt_2            ; save temp mantissa2
001785r 2  A5 75              LDA   FACt_1            ; get temp mantissa1
001787r 2  65 B4              ADC   FAC2_1            ; add FAC2 mantissa1
001789r 2  85 75              STA   FACt_1            ; save temp mantissa1
00178Br 2               LAB_2640
00178Br 2  66 75              ROR   FACt_1            ; shift temp mantissa1
00178Dr 2  66 76              ROR   FACt_2            ; shift temp mantissa2
00178Fr 2  66 77              ROR   FACt_3            ; shift temp mantissa3
001791r 2  66 B9              ROR   FAC1_r            ; shift temp rounding byte
001793r 2  98                 TYA                     ; get byte back
001794r 2  4A                 LSR                     ; shift byte
001795r 2  D0 DE              BNE   LAB_262A          ; loop if all bits not done
001797r 2               
001797r 2               LAB_264C
001797r 2  60                 RTS
001798r 2               
001798r 2               ; unpack memory (AY) into FAC2
001798r 2               
001798r 2               LAB_264D
001798r 2  85 71              STA   ut1_pl            ; save pointer low byte
00179Ar 2  84 72              STY   ut1_ph            ; save pointer high byte
00179Cr 2  A0 03              LDY   #$03              ; 4 bytes to get (0-3)
00179Er 2  B1 71              LDA   (ut1_pl),Y        ; get mantissa3
0017A0r 2  85 B6              STA   FAC2_3            ; save FAC2 mantissa3
0017A2r 2  88                 DEY                     ; decrement index
0017A3r 2  B1 71              LDA   (ut1_pl),Y        ; get mantissa2
0017A5r 2  85 B5              STA   FAC2_2            ; save FAC2 mantissa2
0017A7r 2  88                 DEY                     ; decrement index
0017A8r 2  B1 71              LDA   (ut1_pl),Y        ; get mantissa1+sign
0017AAr 2  85 B7              STA   FAC2_s            ; save FAC2 sign (b7)
0017ACr 2  45 B0              EOR   FAC1_s            ; EOR with FAC1 sign (b7)
0017AEr 2  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
0017B0r 2  A5 B7              LDA   FAC2_s            ; recover FAC2 sign (b7)
0017B2r 2  09 80              ORA   #$80              ; set 1xxx xxx (set normal bit)
0017B4r 2  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
0017B6r 2  88                 DEY                     ; decrement index
0017B7r 2  B1 71              LDA   (ut1_pl),Y        ; get exponent byte
0017B9r 2  85 B3              STA   FAC2_e            ; save FAC2 exponent
0017BBr 2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
0017BDr 2  60                 RTS
0017BEr 2               
0017BEr 2               ; test and adjust accumulators
0017BEr 2               
0017BEr 2               LAB_2673
0017BEr 2  A5 B3              LDA   FAC2_e            ; get FAC2 exponent
0017C0r 2               LAB_2675
0017C0r 2  F0 1D              BEQ   LAB_2696          ; branch if FAC2 = $00 (handle underflow)
0017C2r 2               
0017C2r 2  18                 CLC                     ; clear carry for add
0017C3r 2  65 AC              ADC   FAC1_e            ; add FAC1 exponent
0017C5r 2  90 04              BCC   LAB_2680          ; branch if sum of exponents <$0100
0017C7r 2               
0017C7r 2  30 31              BMI   LAB_269B          ; do overflow error
0017C9r 2               
0017C9r 2  18                 CLC                     ; clear carry for the add
0017CAr 2  2C                 .byte $2C               ; makes next line BIT $1410
0017CBr 2               LAB_2680
0017CBr 2  10 12              BPL   LAB_2696          ; if +ve go handle underflow
0017CDr 2               
0017CDr 2  69 80              ADC   #$80              ; adjust exponent
0017CFr 2  85 AC              STA   FAC1_e            ; save FAC1 exponent
0017D1r 2  D0 03              BNE   LAB_268B          ; branch if not zero
0017D3r 2               
0017D3r 2  4C rr rr           JMP   LAB_24F5          ; save FAC1 sign and return
0017D6r 2               
0017D6r 2               LAB_268B
0017D6r 2  A5 B8              LDA   FAC_sc            ; get sign compare (FAC1 EOR FAC2)
0017D8r 2  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
0017DAr 2               LAB_268F
0017DAr 2  60                 RTS
0017DBr 2               
0017DBr 2               ; handle overflow and underflow
0017DBr 2               
0017DBr 2               LAB_2690
0017DBr 2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
0017DDr 2  10 1B              BPL   LAB_269B          ; do overflow error
0017DFr 2               
0017DFr 2                                             ; handle underflow
0017DFr 2               LAB_2696
0017DFr 2  68                 PLA                     ; pop return address low byte
0017E0r 2  68                 PLA                     ; pop return address high byte
0017E1r 2  4C rr rr           JMP   LAB_24F1          ; clear FAC1 exponent and sign and return
0017E4r 2               
0017E4r 2               ; multiply by 10
0017E4r 2               
0017E4r 2               LAB_269E
0017E4r 2  20 rr rr           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
0017E7r 2  AA                 TAX                     ; copy exponent (set the flags)
0017E8r 2  F0 F0              BEQ   LAB_268F          ; exit if zero
0017EAr 2               
0017EAr 2  18                 CLC                     ; clear carry for add
0017EBr 2  69 02              ADC   #$02              ; add two to exponent (*4)
0017EDr 2  B0 0B              BCS   LAB_269B          ; do overflow error if > $FF
0017EFr 2               
0017EFr 2  A2 00              LDX   #$00              ; clear byte
0017F1r 2  86 B8              STX   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
0017F3r 2  20 rr rr           JSR   LAB_247C          ; add FAC2 to FAC1 (*5)
0017F6r 2  E6 AC              INC   FAC1_e            ; increment FAC1 exponent (*10)
0017F8r 2  D0 E0              BNE   LAB_268F          ; if non zero just do RTS
0017FAr 2               
0017FAr 2               LAB_269B
0017FAr 2  4C rr rr           JMP   LAB_2564          ; do overflow error and warm start
0017FDr 2               
0017FDr 2               ; divide by 10
0017FDr 2               
0017FDr 2               LAB_26B9
0017FDr 2  20 rr rr           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
001800r 2  A9 rr              LDA   #<LAB_26B5        ; set pointer to 10d low addr
001802r 2  A0 rr              LDY   #>LAB_26B5        ; set pointer to 10d high addr
001804r 2  A2 00              LDX   #$00              ; clear sign
001806r 2               
001806r 2               ; divide by (AY) (X=sign)
001806r 2               
001806r 2               LAB_26C2
001806r 2  86 B8              STX   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
001808r 2  20 rr rr           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
00180Br 2  4C rr rr           JMP   LAB_DIVIDE        ; do FAC2/FAC1
00180Er 2               
00180Er 2                                             ; Perform divide-by
00180Er 2               ; convert AY and do (AY)/FAC1
00180Er 2               
00180Er 2               LAB_26CA
00180Er 2  20 rr rr           JSR   LAB_264D          ; unpack memory (AY) into FAC2
001811r 2               
001811r 2                                             ; Perform divide-into
001811r 2               LAB_DIVIDE
001811r 2  F0 63              BEQ   LAB_2737          ; if zero go do /0 error
001813r 2               
001813r 2  20 rr rr           JSR   LAB_27BA          ; round FAC1
001816r 2  A9 00              LDA   #$00              ; clear A
001818r 2  38                 SEC                     ; set carry for subtract
001819r 2  E5 AC              SBC   FAC1_e            ; subtract FAC1 exponent (2s complement)
00181Br 2  85 AC              STA   FAC1_e            ; save FAC1 exponent
00181Dr 2  20 rr rr           JSR   LAB_2673          ; test and adjust accumulators
001820r 2  E6 AC              INC   FAC1_e            ; increment FAC1 exponent
001822r 2  F0 D6              BEQ   LAB_269B          ; if zero do overflow error
001824r 2               
001824r 2  A2 FF              LDX   #$FF              ; set index for pre increment
001826r 2  A9 01              LDA   #$01              ; set bit to flag byte save
001828r 2               LAB_26E4
001828r 2  A4 B4              LDY   FAC2_1            ; get FAC2 mantissa1
00182Ar 2  C4 AD              CPY   FAC1_1            ; compare FAC1 mantissa1
00182Cr 2  D0 0A              BNE   LAB_26F4          ; branch if <>
00182Er 2               
00182Er 2  A4 B5              LDY   FAC2_2            ; get FAC2 mantissa2
001830r 2  C4 AE              CPY   FAC1_2            ; compare FAC1 mantissa2
001832r 2  D0 04              BNE   LAB_26F4          ; branch if <>
001834r 2               
001834r 2  A4 B6              LDY   FAC2_3            ; get FAC2 mantissa3
001836r 2  C4 AF              CPY   FAC1_3            ; compare FAC1 mantissa3
001838r 2               LAB_26F4
001838r 2  08                 PHP                     ; save FAC2-FAC1 compare status
001839r 2  2A                 ROL                     ; shift the result byte
00183Ar 2  90 0E              BCC   LAB_2702          ; if no carry skip the byte save
00183Cr 2               
00183Cr 2  A0 01              LDY   #$01              ; set bit to flag byte save
00183Er 2  E8                 INX                     ; else increment the index to FACt
00183Fr 2  E0 02              CPX   #$02              ; compare with the index to FACt_3
001841r 2  30 04              BMI   LAB_2701          ; if not last byte just go save it
001843r 2               
001843r 2  D0 28              BNE   LAB_272B          ; if all done go save FAC1 rounding byte, normalise and
001845r 2                                             ; return
001845r 2               
001845r 2  A0 40              LDY   #$40              ; set bit to flag byte save for the rounding byte
001847r 2               LAB_2701
001847r 2  95 75              STA   FACt_1,X          ; write result byte to FACt_1 + index
001849r 2  98                 TYA                     ; copy the next save byte flag
00184Ar 2               LAB_2702
00184Ar 2  28                 PLP                     ; restore FAC2-FAC1 compare status
00184Br 2  90 14              BCC   LAB_2704          ; if FAC2 < FAC1 then skip the subtract
00184Dr 2               
00184Dr 2  A8                 TAY                     ; save FAC2-FAC1 compare status
00184Er 2  A5 B6              LDA   FAC2_3            ; get FAC2 mantissa3
001850r 2  E5 AF              SBC   FAC1_3            ; subtract FAC1 mantissa3
001852r 2  85 B6              STA   FAC2_3            ; save FAC2 mantissa3
001854r 2  A5 B5              LDA   FAC2_2            ; get FAC2 mantissa2
001856r 2  E5 AE              SBC   FAC1_2            ; subtract FAC1 mantissa2
001858r 2  85 B5              STA   FAC2_2            ; save FAC2 mantissa2
00185Ar 2  A5 B4              LDA   FAC2_1            ; get FAC2 mantissa1
00185Cr 2  E5 AD              SBC   FAC1_1            ; subtract FAC1 mantissa1
00185Er 2  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
001860r 2  98                 TYA                     ; restore FAC2-FAC1 compare status
001861r 2               
001861r 2                                             ; FAC2 = FAC2*2
001861r 2               LAB_2704
001861r 2  06 B6              ASL   FAC2_3            ; shift FAC2 mantissa3
001863r 2  26 B5              ROL   FAC2_2            ; shift FAC2 mantissa2
001865r 2  26 B4              ROL   FAC2_1            ; shift FAC2 mantissa1
001867r 2  B0 CF              BCS   LAB_26F4          ; loop with no compare
001869r 2               
001869r 2  30 BD              BMI   LAB_26E4          ; loop with compare
00186Br 2               
00186Br 2  10 CB              BPL   LAB_26F4          ; loop always with no compare
00186Dr 2               
00186Dr 2               ; do A<<6, save as FAC1 rounding byte, normalise and return
00186Dr 2               
00186Dr 2               LAB_272B
00186Dr 2  4A                 LSR                     ; shift b1 - b0 ..
00186Er 2  6A                 ROR                     ; ..
00186Fr 2  6A                 ROR                     ; .. to b7 - b6
001870r 2  85 B9              STA   FAC1_r            ; save FAC1 rounding byte
001872r 2  28                 PLP                     ; dump FAC2-FAC1 compare status
001873r 2  4C rr rr           JMP   LAB_273C          ; copy temp to FAC1, normalise and return
001876r 2               
001876r 2               ; do "Divide by zero" error
001876r 2               
001876r 2               LAB_2737
001876r 2  A2 14              LDX   #$14              ; error code $14 ("Divide by zero" error)
001878r 2  4C rr rr           JMP   LAB_XERR          ; do error #X, then warm start
00187Br 2               
00187Br 2               ; copy temp to FAC1 and normalise
00187Br 2               
00187Br 2               LAB_273C
00187Br 2  A5 75              LDA   FACt_1            ; get temp mantissa1
00187Dr 2  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
00187Fr 2  A5 76              LDA   FACt_2            ; get temp mantissa2
001881r 2  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
001883r 2  A5 77              LDA   FACt_3            ; get temp mantissa3
001885r 2  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
001887r 2  4C rr rr           JMP   LAB_24D5          ; normalise FAC1 and return
00188Ar 2               
00188Ar 2               ; unpack memory (AY) into FAC1
00188Ar 2               
00188Ar 2               LAB_UFAC
00188Ar 2  85 71              STA   ut1_pl            ; save pointer low byte
00188Cr 2  84 72              STY   ut1_ph            ; save pointer high byte
00188Er 2  A0 03              LDY   #$03              ; 4 bytes to do
001890r 2  B1 71              LDA   (ut1_pl),Y        ; get last byte
001892r 2  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
001894r 2  88                 DEY                     ; decrement index
001895r 2  B1 71              LDA   (ut1_pl),Y        ; get last-1 byte
001897r 2  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
001899r 2  88                 DEY                     ; decrement index
00189Ar 2  B1 71              LDA   (ut1_pl),Y        ; get second byte
00189Cr 2  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
00189Er 2  09 80              ORA   #$80              ; set 1xxx xxxx (add normal bit)
0018A0r 2  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
0018A2r 2  88                 DEY                     ; decrement index
0018A3r 2  B1 71              LDA   (ut1_pl),Y        ; get first byte (exponent)
0018A5r 2  85 AC              STA   FAC1_e            ; save FAC1 exponent
0018A7r 2  84 B9              STY   FAC1_r            ; clear FAC1 rounding byte
0018A9r 2  60                 RTS
0018AAr 2               
0018AAr 2               ; pack FAC1 into Adatal
0018AAr 2               
0018AAr 2               LAB_276E
0018AAr 2  A2 A4              LDX   #<Adatal          ; set pointer low byte
0018ACr 2               LAB_2770
0018ACr 2  A0 00              LDY   #>Adatal          ; set pointer high byte
0018AEr 2  F0 04              BEQ   LAB_2778          ; pack FAC1 into (XY) and return
0018B0r 2               
0018B0r 2               ; pack FAC1 into (Lvarpl)
0018B0r 2               
0018B0r 2               LAB_PFAC
0018B0r 2  A6 97              LDX   Lvarpl            ; get destination pointer low byte
0018B2r 2  A4 98              LDY   Lvarph            ; get destination pointer high byte
0018B4r 2               
0018B4r 2               ; pack FAC1 into (XY)
0018B4r 2               
0018B4r 2               LAB_2778
0018B4r 2  20 rr rr           JSR   LAB_27BA          ; round FAC1
0018B7r 2  86 71              STX   ut1_pl            ; save pointer low byte
0018B9r 2  84 72              STY   ut1_ph            ; save pointer high byte
0018BBr 2  A0 03              LDY   #$03              ; set index
0018BDr 2  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
0018BFr 2  91 71              STA   (ut1_pl),Y        ; store in destination
0018C1r 2  88                 DEY                     ; decrement index
0018C2r 2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
0018C4r 2  91 71              STA   (ut1_pl),Y        ; store in destination
0018C6r 2  88                 DEY                     ; decrement index
0018C7r 2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
0018C9r 2  09 7F              ORA   #$7F              ; set bits x111 1111
0018CBr 2  25 AD              AND   FAC1_1            ; AND in FAC1 mantissa1
0018CDr 2  91 71              STA   (ut1_pl),Y        ; store in destination
0018CFr 2  88                 DEY                     ; decrement index
0018D0r 2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
0018D2r 2  91 71              STA   (ut1_pl),Y        ; store in destination
0018D4r 2  84 B9              STY   FAC1_r            ; clear FAC1 rounding byte
0018D6r 2  60                 RTS
0018D7r 2               
0018D7r 2               ; round and copy FAC1 to FAC2
0018D7r 2               
0018D7r 2               LAB_27AB
0018D7r 2  20 rr rr           JSR   LAB_27BA          ; round FAC1
0018DAr 2               
0018DAr 2               ; copy FAC1 to FAC2
0018DAr 2               
0018DAr 2               LAB_27AE
0018DAr 2  A2 05              LDX   #$05              ; 5 bytes to copy
0018DCr 2               LAB_27B0
0018DCr 2  B5 AB              LDA   FAC1_e-1,X        ; get byte from FAC1,X
0018DEr 2  95 B2              STA   FAC1_o,X          ; save byte at FAC2,X
0018E0r 2  CA                 DEX                     ; decrement count
0018E1r 2  D0 F9              BNE   LAB_27B0          ; loop if not all done
0018E3r 2               
0018E3r 2  86 B9              STX   FAC1_r            ; clear FAC1 rounding byte
0018E5r 2               LAB_27B9
0018E5r 2  60                 RTS
0018E6r 2               
0018E6r 2               ; round FAC1
0018E6r 2               
0018E6r 2               LAB_27BA
0018E6r 2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
0018E8r 2  F0 FB              BEQ   LAB_27B9          ; exit if zero
0018EAr 2               
0018EAr 2  06 B9              ASL   FAC1_r            ; shift FAC1 rounding byte
0018ECr 2  90 F7              BCC   LAB_27B9          ; exit if no overflow
0018EEr 2               
0018EEr 2               ; round FAC1 (no check)
0018EEr 2               
0018EEr 2               LAB_27C2
0018EEr 2  20 rr rr           JSR   LAB_2559          ; increment FAC1 mantissa
0018F1r 2  D0 F2              BNE   LAB_27B9          ; branch if no overflow
0018F3r 2               
0018F3r 2  4C rr rr           JMP   LAB_252A          ; normalise FAC1 for C=1 and return
0018F6r 2               
0018F6r 2               ; get FAC1 sign
0018F6r 2               ; return A=FF,C=1/-ve A=01,C=0/+ve
0018F6r 2               
0018F6r 2               LAB_27CA
0018F6r 2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
0018F8r 2  F0 09              BEQ   LAB_27D7          ; exit if zero (already correct SGN(0)=0)
0018FAr 2               
0018FAr 2               ; return A=FF,C=1/-ve A=01,C=0/+ve
0018FAr 2               ; no = 0 check
0018FAr 2               
0018FAr 2               LAB_27CE
0018FAr 2  A5 B0              LDA   FAC1_s            ; else get FAC1 sign (b7)
0018FCr 2               
0018FCr 2               ; return A=FF,C=1/-ve A=01,C=0/+ve
0018FCr 2               ; no = 0 check, sign in A
0018FCr 2               
0018FCr 2               LAB_27D0
0018FCr 2  2A                 ROL                     ; move sign bit to carry
0018FDr 2  A9 FF              LDA   #$FF              ; set byte for -ve result
0018FFr 2  B0 02              BCS   LAB_27D7          ; return if sign was set (-ve)
001901r 2               
001901r 2  A9 01              LDA   #$01              ; else set byte for +ve result
001903r 2               LAB_27D7
001903r 2  60                 RTS
001904r 2               
001904r 2               ; perform SGN()
001904r 2               
001904r 2               LAB_SGN
001904r 2  20 rr rr           JSR   LAB_27CA          ; get FAC1 sign
001907r 2                                             ; return A=$FF/-ve A=$01/+ve
001907r 2               ; save A as integer byte
001907r 2               
001907r 2               LAB_27DB
001907r 2  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
001909r 2  A9 00              LDA   #$00              ; clear A
00190Br 2  85 AE              STA   FAC1_2            ; clear FAC1 mantissa2
00190Dr 2  A2 88              LDX   #$88              ; set exponent
00190Fr 2               
00190Fr 2               ; set exp=X, clearFAC1 mantissa3 and normalise
00190Fr 2               
00190Fr 2               LAB_27E3
00190Fr 2  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
001911r 2  49 FF              EOR   #$FF              ; complement it
001913r 2  2A                 ROL                     ; sign bit into carry
001914r 2               
001914r 2               ; set exp=X, clearFAC1 mantissa3 and normalise
001914r 2               
001914r 2               LAB_STFA
001914r 2  A9 00              LDA   #$00              ; clear A
001916r 2  85 AF              STA   FAC1_3            ; clear FAC1 mantissa3
001918r 2  86 AC              STX   FAC1_e            ; set FAC1 exponent
00191Ar 2  85 B9              STA   FAC1_r            ; clear FAC1 rounding byte
00191Cr 2  85 B0              STA   FAC1_s            ; clear FAC1 sign (b7)
00191Er 2  4C rr rr           JMP   LAB_24D0          ; do ABS and normalise FAC1
001921r 2               
001921r 2               ; perform ABS()
001921r 2               
001921r 2               LAB_ABS
001921r 2  46 B0              LSR   FAC1_s            ; clear FAC1 sign (put zero in b7)
001923r 2  60                 RTS
001924r 2               
001924r 2               ; compare FAC1 with (AY)
001924r 2               ; returns A=$00 if FAC1 = (AY)
001924r 2               ; returns A=$01 if FAC1 > (AY)
001924r 2               ; returns A=$FF if FAC1 < (AY)
001924r 2               
001924r 2               LAB_27F8
001924r 2  85 73              STA   ut2_pl            ; save pointer low byte
001926r 2               LAB_27FA
001926r 2  84 74              STY   ut2_ph            ; save pointer high byte
001928r 2  A0 00              LDY   #$00              ; clear index
00192Ar 2  B1 73              LDA   (ut2_pl),Y        ; get exponent
00192Cr 2  C8                 INY                     ; increment index
00192Dr 2  AA                 TAX                     ; copy (AY) exponent to X
00192Er 2  F0 C6              BEQ   LAB_27CA          ; branch if (AY) exponent=0 and get FAC1 sign
001930r 2                                             ; A=FF,C=1/-ve A=01,C=0/+ve
001930r 2               
001930r 2  B1 73              LDA   (ut2_pl),Y        ; get (AY) mantissa1 (with sign)
001932r 2  45 B0              EOR   FAC1_s            ; EOR FAC1 sign (b7)
001934r 2  30 C4              BMI   LAB_27CE          ; if signs <> do return A=FF,C=1/-ve
001936r 2                                             ; A=01,C=0/+ve and return
001936r 2               
001936r 2  E4 AC              CPX   FAC1_e            ; compare (AY) exponent with FAC1 exponent
001938r 2  D0 1A              BNE   LAB_2828          ; branch if different
00193Ar 2               
00193Ar 2  B1 73              LDA   (ut2_pl),Y        ; get (AY) mantissa1 (with sign)
00193Cr 2  09 80              ORA   #$80              ; normalise top bit
00193Er 2  C5 AD              CMP   FAC1_1            ; compare with FAC1 mantissa1
001940r 2  D0 12              BNE   LAB_2828          ; branch if different
001942r 2               
001942r 2  C8                 INY                     ; increment index
001943r 2  B1 73              LDA   (ut2_pl),Y        ; get mantissa2
001945r 2  C5 AE              CMP   FAC1_2            ; compare with FAC1 mantissa2
001947r 2  D0 0B              BNE   LAB_2828          ; branch if different
001949r 2               
001949r 2  C8                 INY                     ; increment index
00194Ar 2  A9 7F              LDA   #$7F              ; set for 1/2 value rounding byte
00194Cr 2  C5 B9              CMP   FAC1_r            ; compare with FAC1 rounding byte (set carry)
00194Er 2  B1 73              LDA   (ut2_pl),Y        ; get mantissa3
001950r 2  E5 AF              SBC   FAC1_3            ; subtract FAC1 mantissa3
001952r 2  F0 28              BEQ   LAB_2850          ; exit if mantissa3 equal
001954r 2               
001954r 2               ; gets here if number <> FAC1
001954r 2               
001954r 2               LAB_2828
001954r 2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
001956r 2  90 02              BCC   LAB_282E          ; branch if FAC1 > (AY)
001958r 2               
001958r 2  49 FF              EOR   #$FF              ; else toggle FAC1 sign
00195Ar 2               LAB_282E
00195Ar 2  4C rr rr           JMP   LAB_27D0          ; return A=FF,C=1/-ve A=01,C=0/+ve
00195Dr 2               
00195Dr 2               ; convert FAC1 floating-to-fixed
00195Dr 2               
00195Dr 2               LAB_2831
00195Dr 2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
00195Fr 2  F0 4A              BEQ   LAB_287F          ; if zero go clear FAC1 and return
001961r 2               
001961r 2  38                 SEC                     ; set carry for subtract
001962r 2  E9 98              SBC   #$98              ; subtract maximum integer range exponent
001964r 2  24 B0              BIT   FAC1_s            ; test FAC1 sign (b7)
001966r 2  10 09              BPL   LAB_2845          ; branch if FAC1 +ve
001968r 2               
001968r 2                                             ; FAC1 was -ve
001968r 2  AA                 TAX                     ; copy subtracted exponent
001969r 2  A9 FF              LDA   #$FF              ; overflow for -ve number
00196Br 2  85 B2              STA   FAC1_o            ; set FAC1 overflow byte
00196Dr 2  20 rr rr           JSR   LAB_253D          ; twos complement FAC1 mantissa
001970r 2  8A                 TXA                     ; restore subtracted exponent
001971r 2               LAB_2845
001971r 2  A2 AC              LDX   #FAC1_e           ; set index to FAC1
001973r 2  C9 F9              CMP   #$F9              ; compare exponent result
001975r 2  10 06              BPL   LAB_2851          ; if < 8 shifts shift FAC1 A times right and return
001977r 2               
001977r 2  20 rr rr           JSR   LAB_257B          ; shift FAC1 A times right (> 8 shifts)
00197Ar 2  84 B2              STY   FAC1_o            ; clear FAC1 overflow byte
00197Cr 2               LAB_2850
00197Cr 2  60                 RTS
00197Dr 2               
00197Dr 2               ; shift FAC1 A times right
00197Dr 2               
00197Dr 2               LAB_2851
00197Dr 2  A8                 TAY                     ; copy shift count
00197Er 2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
001980r 2  29 80              AND   #$80              ; mask sign bit only (x000 0000)
001982r 2  46 AD              LSR   FAC1_1            ; shift FAC1 mantissa1
001984r 2  05 AD              ORA   FAC1_1            ; OR sign in b7 FAC1 mantissa1
001986r 2  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
001988r 2  20 rr rr           JSR   LAB_2592          ; shift FAC1 Y times right
00198Br 2  84 B2              STY   FAC1_o            ; clear FAC1 overflow byte
00198Dr 2  60                 RTS
00198Er 2               
00198Er 2               ; perform INT()
00198Er 2               
00198Er 2               LAB_INT
00198Er 2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
001990r 2  C9 98              CMP   #$98              ; compare with max int
001992r 2  B0 1E              BCS   LAB_2886          ; exit if >= (already int, too big for fractional part!)
001994r 2               
001994r 2  20 rr rr           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
001997r 2  84 B9              STY   FAC1_r            ; save FAC1 rounding byte
001999r 2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
00199Br 2  84 B0              STY   FAC1_s            ; save FAC1 sign (b7)
00199Dr 2  49 80              EOR   #$80              ; toggle FAC1 sign
00199Fr 2  2A                 ROL                     ; shift into carry
0019A0r 2  A9 98              LDA   #$98              ; set new exponent
0019A2r 2  85 AC              STA   FAC1_e            ; save FAC1 exponent
0019A4r 2  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
0019A6r 2  85 5B              STA   Temp3             ; save for EXP() function
0019A8r 2  4C rr rr           JMP   LAB_24D0          ; do ABS and normalise FAC1
0019ABr 2               
0019ABr 2               ; clear FAC1 and return
0019ABr 2               
0019ABr 2               LAB_287F
0019ABr 2  85 AD              STA   FAC1_1            ; clear FAC1 mantissa1
0019ADr 2  85 AE              STA   FAC1_2            ; clear FAC1 mantissa2
0019AFr 2  85 AF              STA   FAC1_3            ; clear FAC1 mantissa3
0019B1r 2  A8                 TAY                     ; clear Y
0019B2r 2               LAB_2886
0019B2r 2  60                 RTS
0019B3r 2               
0019B3r 2               ; get FAC1 from string
0019B3r 2               ; this routine now handles hex and binary values from strings
0019B3r 2               ; starting with "$" and "%" respectively
0019B3r 2               
0019B3r 2               LAB_2887
0019B3r 2  A0 00              LDY   #$00              ; clear Y
0019B5r 2  84 5F              STY   Dtypef            ; clear data type flag, $FF=string, $00=numeric
0019B7r 2  A2 09              LDX   #$09              ; set index
0019B9r 2               LAB_288B
0019B9r 2  94 A8              STY   numexp,X          ; clear byte
0019BBr 2  CA                 DEX                     ; decrement index
0019BCr 2  10 FB              BPL   LAB_288B          ; loop until numexp to negnum (and FAC1) = $00
0019BEr 2               
0019BEr 2  90 7F              BCC   LAB_28FE          ; branch if 1st character numeric
0019C0r 2               
0019C0r 2               ; get FAC1 from string .. first character wasn't numeric
0019C0r 2               
0019C0r 2  C9 2D              CMP   #'-'              ; else compare with "-"
0019C2r 2  D0 04              BNE   LAB_289A          ; branch if not "-"
0019C4r 2               
0019C4r 2  86 B1              STX   negnum            ; set flag for -ve number (X = $FF)
0019C6r 2  F0 04              BEQ   LAB_289C          ; branch always (go scan and check for hex/bin)
0019C8r 2               
0019C8r 2               ; get FAC1 from string .. first character wasn't numeric or -
0019C8r 2               
0019C8r 2               LAB_289A
0019C8r 2  C9 2B              CMP   #'+'              ; else compare with "+"
0019CAr 2  D0 05              BNE   LAB_289D          ; branch if not "+" (go check for hex/bin)
0019CCr 2               
0019CCr 2               ; was "+" or "-" to start, so get next character
0019CCr 2               
0019CCr 2               LAB_289C
0019CCr 2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
0019CFr 2  90 6E              BCC   LAB_28FE          ; branch if numeric character
0019D1r 2               
0019D1r 2               ; code here for hex and binary numbers
0019D1r 2               
0019D1r 2               LAB_289D
0019D1r 2  C9 24              CMP   #'$'              ; else compare with "$"
0019D3r 2  D0 03              BNE   LAB_NHEX          ; branch if not "$"
0019D5r 2               
0019D5r 2  4C rr rr           JMP   LAB_CHEX          ; branch if "$"
0019D8r 2               
0019D8r 2               LAB_NHEX
0019D8r 2  C9 25              CMP   #'%'              ; else compare with "%"
0019DAr 2  D0 08              BNE   LAB_28A3          ; branch if not "%" (continue original code)
0019DCr 2               
0019DCr 2  4C rr rr           JMP   LAB_CBIN          ; branch if "%"
0019DFr 2               
0019DFr 2               LAB_289E
0019DFr 2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory (ignore + or get next number)
0019E2r 2               LAB_28A1
0019E2r 2  90 5B              BCC   LAB_28FE          ; branch if numeric character
0019E4r 2               
0019E4r 2               ; get FAC1 from string .. character wasn't numeric, -, +, hex or binary
0019E4r 2               
0019E4r 2               LAB_28A3
0019E4r 2  C9 2E              CMP   #'.'              ; else compare with "."
0019E6r 2  F0 2E              BEQ   LAB_28D5          ; branch if "."
0019E8r 2               
0019E8r 2               ; get FAC1 from string .. character wasn't numeric, -, + or .
0019E8r 2               
0019E8r 2  C9 45              CMP   #'E'              ; else compare with "E"
0019EAr 2  D0 30              BNE   LAB_28DB          ; branch if not "E"
0019ECr 2               
0019ECr 2                                             ; was "E" so evaluate exponential part
0019ECr 2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
0019EFr 2  90 17              BCC   LAB_28C7          ; branch if numeric character
0019F1r 2               
0019F1r 2  C9 B7              CMP   #TK_MINUS         ; else compare with token for -
0019F3r 2  F0 0E              BEQ   LAB_28C2          ; branch if token for -
0019F5r 2               
0019F5r 2  C9 2D              CMP   #'-'              ; else compare with "-"
0019F7r 2  F0 0A              BEQ   LAB_28C2          ; branch if "-"
0019F9r 2               
0019F9r 2  C9 B6              CMP   #TK_PLUS          ; else compare with token for +
0019FBr 2  F0 08              BEQ   LAB_28C4          ; branch if token for +
0019FDr 2               
0019FDr 2  C9 2B              CMP   #'+'              ; else compare with "+"
0019FFr 2  F0 04              BEQ   LAB_28C4          ; branch if "+"
001A01r 2               
001A01r 2  D0 07              BNE   LAB_28C9          ; branch always
001A03r 2               
001A03r 2               LAB_28C2
001A03r 2  66 AB              ROR   expneg            ; set exponent -ve flag (C, which=1, into b7)
001A05r 2               LAB_28C4
001A05r 2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
001A08r 2               LAB_28C7
001A08r 2  90 5B              BCC   LAB_2925          ; branch if numeric character
001A0Ar 2               
001A0Ar 2               LAB_28C9
001A0Ar 2  24 AB              BIT   expneg            ; test exponent -ve flag
001A0Cr 2  10 0E              BPL   LAB_28DB          ; if +ve go evaluate exponent
001A0Er 2               
001A0Er 2                                             ; else do exponent = -exponent
001A0Er 2  A9 00              LDA   #$00              ; clear result
001A10r 2  38                 SEC                     ; set carry for subtract
001A11r 2  E5 A9              SBC   expcnt            ; subtract exponent byte
001A13r 2  4C rr rr           JMP   LAB_28DD          ; go evaluate exponent
001A16r 2               
001A16r 2               LAB_28D5
001A16r 2  66 AA              ROR   numdpf            ; set decimal point flag
001A18r 2  24 AA              BIT   numdpf            ; test decimal point flag
001A1Ar 2  50 C3              BVC   LAB_289E          ; branch if only one decimal point so far
001A1Cr 2               
001A1Cr 2                                             ; evaluate exponent
001A1Cr 2               LAB_28DB
001A1Cr 2  A5 A9              LDA   expcnt            ; get exponent count byte
001A1Er 2               LAB_28DD
001A1Er 2  38                 SEC                     ; set carry for subtract
001A1Fr 2  E5 A8              SBC   numexp            ; subtract numerator exponent
001A21r 2  85 A9              STA   expcnt            ; save exponent count byte
001A23r 2  F0 12              BEQ   LAB_28F6          ; branch if no adjustment
001A25r 2               
001A25r 2  10 09              BPL   LAB_28EF          ; else if +ve go do FAC1*10^expcnt
001A27r 2               
001A27r 2                                             ; else go do FAC1/10^(0-expcnt)
001A27r 2               LAB_28E6
001A27r 2  20 rr rr           JSR   LAB_26B9          ; divide by 10
001A2Ar 2  E6 A9              INC   expcnt            ; increment exponent count byte
001A2Cr 2  D0 F9              BNE   LAB_28E6          ; loop until all done
001A2Er 2               
001A2Er 2  F0 07              BEQ   LAB_28F6          ; branch always
001A30r 2               
001A30r 2               LAB_28EF
001A30r 2  20 rr rr           JSR   LAB_269E          ; multiply by 10
001A33r 2  C6 A9              DEC   expcnt            ; decrement exponent count byte
001A35r 2  D0 F9              BNE   LAB_28EF          ; loop until all done
001A37r 2               
001A37r 2               LAB_28F6
001A37r 2  A5 B1              LDA   negnum            ; get -ve flag
001A39r 2  30 01              BMI   LAB_28FB          ; if -ve do - FAC1 and return
001A3Br 2               
001A3Br 2  60                 RTS
001A3Cr 2               
001A3Cr 2               ; do - FAC1 and return
001A3Cr 2               
001A3Cr 2               LAB_28FB
001A3Cr 2  4C rr rr           JMP   LAB_GTHAN         ; do - FAC1 and return
001A3Fr 2               
001A3Fr 2               ; do unsigned FAC1*10+number
001A3Fr 2               
001A3Fr 2               LAB_28FE
001A3Fr 2  48                 PHA                     ; save character
001A40r 2  24 AA              BIT   numdpf            ; test decimal point flag
001A42r 2  10 02              BPL   LAB_2905          ; skip exponent increment if not set
001A44r 2               
001A44r 2  E6 A8              INC   numexp            ; else increment number exponent
001A46r 2               LAB_2905
001A46r 2  20 rr rr           JSR   LAB_269E          ; multiply FAC1 by 10
001A49r 2  68                 PLA                     ; restore character
001A4Ar 2  29 0F              AND   #$0F              ; convert to binary
001A4Cr 2  20 rr rr           JSR   LAB_2912          ; evaluate new ASCII digit
001A4Fr 2  4C rr rr           JMP   LAB_289E          ; go do next character
001A52r 2               
001A52r 2               ; evaluate new ASCII digit
001A52r 2               
001A52r 2               LAB_2912
001A52r 2  48                 PHA                     ; save digit
001A53r 2  20 rr rr           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
001A56r 2  68                 PLA                     ; restore digit
001A57r 2  20 rr rr           JSR   LAB_27DB          ; save A as integer byte
001A5Ar 2  A5 B7              LDA   FAC2_s            ; get FAC2 sign (b7)
001A5Cr 2  45 B0              EOR   FAC1_s            ; toggle with FAC1 sign (b7)
001A5Er 2  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
001A60r 2  A6 AC              LDX   FAC1_e            ; get FAC1 exponent
001A62r 2  4C rr rr           JMP   LAB_ADD           ; add FAC2 to FAC1 and return
001A65r 2               
001A65r 2               ; evaluate next character of exponential part of number
001A65r 2               
001A65r 2               LAB_2925
001A65r 2  A5 A9              LDA   expcnt            ; get exponent count byte
001A67r 2  C9 0A              CMP   #$0A              ; compare with 10 decimal
001A69r 2  90 09              BCC   LAB_2934          ; branch if less
001A6Br 2               
001A6Br 2  A9 64              LDA   #$64              ; make all -ve exponents = -100 decimal (causes underflow)
001A6Dr 2  24 AB              BIT   expneg            ; test exponent -ve flag
001A6Fr 2  30 0E              BMI   LAB_2942          ; branch if -ve
001A71r 2               
001A71r 2  4C rr rr           JMP   LAB_2564          ; else do overflow error
001A74r 2               
001A74r 2               LAB_2934
001A74r 2  0A                 ASL                     ; * 2
001A75r 2  0A                 ASL                     ; * 4
001A76r 2  65 A9              ADC   expcnt            ; * 5
001A78r 2  0A                 ASL                     ; * 10
001A79r 2  A0 00              LDY   #$00              ; set index
001A7Br 2  71 C3              ADC   (Bpntrl),Y        ; add character (will be $30 too much!)
001A7Dr 2  E9 2F              SBC   #'0'-1            ; convert character to binary
001A7Fr 2               LAB_2942
001A7Fr 2  85 A9              STA   expcnt            ; save exponent count byte
001A81r 2  4C rr rr           JMP   LAB_28C4          ; go get next character
001A84r 2               
001A84r 2               ; print " in line [LINE #]"
001A84r 2               
001A84r 2               LAB_2953
001A84r 2  A9 rr              LDA   #<LAB_LMSG        ; point to " in line " message low byte
001A86r 2  A0 rr              LDY   #>LAB_LMSG        ; point to " in line " message high byte
001A88r 2  20 rr rr           JSR   LAB_18C3          ; print null terminated string from memory
001A8Br 2               
001A8Br 2                                             ; print Basic line #
001A8Br 2  A5 88              LDA   Clineh            ; get current line high byte
001A8Dr 2  A6 87              LDX   Clinel            ; get current line low byte
001A8Fr 2               
001A8Fr 2               ; print XA as unsigned integer
001A8Fr 2               
001A8Fr 2               LAB_295E
001A8Fr 2  85 AD              STA   FAC1_1            ; save low byte as FAC1 mantissa1
001A91r 2  86 AE              STX   FAC1_2            ; save high byte as FAC1 mantissa2
001A93r 2  A2 90              LDX   #$90              ; set exponent to 16d bits
001A95r 2  38                 SEC                     ; set integer is +ve flag
001A96r 2  20 rr rr           JSR   LAB_STFA          ; set exp=X, clearFAC1 mantissa3 and normalise
001A99r 2  A0 00              LDY   #$00              ; clear index
001A9Br 2  98                 TYA                     ; clear A
001A9Cr 2  20 rr rr           JSR   LAB_297B          ; convert FAC1 to string, skip sign character save
001A9Fr 2  4C rr rr           JMP   LAB_18C3          ; print null terminated string from memory and return
001AA2r 2               
001AA2r 2               ; convert FAC1 to ASCII string result in (AY)
001AA2r 2               ; not any more, moved scratchpad to page 0
001AA2r 2               
001AA2r 2               LAB_296E
001AA2r 2  A0 01              LDY   #$01              ; set index = 1
001AA4r 2  A9 20              LDA   #$20              ; character = " " (assume +ve)
001AA6r 2  24 B0              BIT   FAC1_s            ; test FAC1 sign (b7)
001AA8r 2  10 02              BPL   LAB_2978          ; branch if +ve
001AAAr 2               
001AAAr 2  A9 2D              LDA   #$2D              ; else character = "-"
001AACr 2               LAB_2978
001AACr 2  99 EF 00           STA   Decss,Y           ; save leading character (" " or "-")
001AAFr 2               LAB_297B
001AAFr 2  85 B0              STA   FAC1_s            ; clear FAC1 sign (b7)
001AB1r 2  84 BA              STY   Sendl             ; save index
001AB3r 2  C8                 INY                     ; increment index
001AB4r 2  A6 AC              LDX   FAC1_e            ; get FAC1 exponent
001AB6r 2  D0 05              BNE   LAB_2989          ; branch if FAC1<>0
001AB8r 2               
001AB8r 2                                             ; exponent was $00 so FAC1 is 0
001AB8r 2  A9 30              LDA   #'0'              ; set character = "0"
001ABAr 2  4C rr rr           JMP   LAB_2A89          ; save last character, [EOT] and exit
001ABDr 2               
001ABDr 2                                             ; FAC1 is some non zero value
001ABDr 2               LAB_2989
001ABDr 2  A9 00              LDA   #$00              ; clear (number exponent count)
001ABFr 2  E0 81              CPX   #$81              ; compare FAC1 exponent with $81 (>1.00000)
001AC1r 2               
001AC1r 2  B0 09              BCS   LAB_299A          ; branch if FAC1=>1
001AC3r 2               
001AC3r 2                                             ; FAC1<1
001AC3r 2  A9 rr              LDA   #<LAB_294F        ; set pointer low byte to 1,000,000
001AC5r 2  A0 rr              LDY   #>LAB_294F        ; set pointer high byte to 1,000,000
001AC7r 2  20 rr rr           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
001ACAr 2  A9 FA              LDA   #$FA              ; set number exponent count (-6)
001ACCr 2               LAB_299A
001ACCr 2  85 A8              STA   numexp            ; save number exponent count
001ACEr 2               LAB_299C
001ACEr 2  A9 rr              LDA   #<LAB_294B        ; set pointer low byte to 999999.4375 (max before sci note)
001AD0r 2  A0 rr              LDY   #>LAB_294B        ; set pointer high byte to 999999.4375
001AD2r 2  20 rr rr           JSR   LAB_27F8          ; compare FAC1 with (AY)
001AD5r 2  F0 1E              BEQ   LAB_29C3          ; exit if FAC1 = (AY)
001AD7r 2               
001AD7r 2  10 12              BPL   LAB_29B9          ; go do /10 if FAC1 > (AY)
001AD9r 2               
001AD9r 2                                             ; FAC1 < (AY)
001AD9r 2               LAB_29A7
001AD9r 2  A9 rr              LDA   #<LAB_2947        ; set pointer low byte to 99999.9375
001ADBr 2  A0 rr              LDY   #>LAB_2947        ; set pointer high byte to 99999.9375
001ADDr 2  20 rr rr           JSR   LAB_27F8          ; compare FAC1 with (AY)
001AE0r 2  F0 02              BEQ   LAB_29B2          ; branch if FAC1 = (AY) (allow decimal places)
001AE2r 2               
001AE2r 2  10 0E              BPL   LAB_29C0          ; branch if FAC1 > (AY) (no decimal places)
001AE4r 2               
001AE4r 2                                             ; FAC1 <= (AY)
001AE4r 2               LAB_29B2
001AE4r 2  20 rr rr           JSR   LAB_269E          ; multiply by 10
001AE7r 2  C6 A8              DEC   numexp            ; decrement number exponent count
001AE9r 2  D0 EE              BNE   LAB_29A7          ; go test again (branch always)
001AEBr 2               
001AEBr 2               LAB_29B9
001AEBr 2  20 rr rr           JSR   LAB_26B9          ; divide by 10
001AEEr 2  E6 A8              INC   numexp            ; increment number exponent count
001AF0r 2  D0 DC              BNE   LAB_299C          ; go test again (branch always)
001AF2r 2               
001AF2r 2               ; now we have just the digits to do
001AF2r 2               
001AF2r 2               LAB_29C0
001AF2r 2  20 rr rr           JSR   LAB_244E          ; add 0.5 to FAC1 (round FAC1)
001AF5r 2               LAB_29C3
001AF5r 2  20 rr rr           JSR   LAB_2831          ; convert FAC1 floating-to-fixed
001AF8r 2  A2 01              LDX   #$01              ; set default digits before dp = 1
001AFAr 2  A5 A8              LDA   numexp            ; get number exponent count
001AFCr 2  18                 CLC                     ; clear carry for add
001AFDr 2  69 07              ADC   #$07              ; up to 6 digits before point
001AFFr 2  30 09              BMI   LAB_29D8          ; if -ve then 1 digit before dp
001B01r 2               
001B01r 2  C9 08              CMP   #$08              ; A>=8 if n>=1E6
001B03r 2  B0 06              BCS   LAB_29D9          ; branch if >= $08
001B05r 2               
001B05r 2                                             ; carry is clear
001B05r 2  69 FF              ADC   #$FF              ; take 1 from digit count
001B07r 2  AA                 TAX                     ; copy to A
001B08r 2  A9 02              LDA   #$02              ;.set exponent adjust
001B0Ar 2               LAB_29D8
001B0Ar 2  38                 SEC                     ; set carry for subtract
001B0Br 2               LAB_29D9
001B0Br 2  E9 02              SBC   #$02              ; -2
001B0Dr 2  85 A9              STA   expcnt            ;.save exponent adjust
001B0Fr 2  86 A8              STX   numexp            ; save digits before dp count
001B11r 2  8A                 TXA                     ; copy to A
001B12r 2  F0 02              BEQ   LAB_29E4          ; branch if no digits before dp
001B14r 2               
001B14r 2  10 13              BPL   LAB_29F7          ; branch if digits before dp
001B16r 2               
001B16r 2               LAB_29E4
001B16r 2  A4 BA              LDY   Sendl             ; get output string index
001B18r 2  A9 2E              LDA   #$2E              ; character "."
001B1Ar 2  C8                 INY                     ; increment index
001B1Br 2  99 EF 00           STA   Decss,Y           ; save to output string
001B1Er 2  8A                 TXA                     ;.
001B1Fr 2  F0 06              BEQ   LAB_29F5          ;.
001B21r 2               
001B21r 2  A9 30              LDA   #'0'              ; character "0"
001B23r 2  C8                 INY                     ; increment index
001B24r 2  99 EF 00           STA   Decss,Y           ; save to output string
001B27r 2               LAB_29F5
001B27r 2  84 BA              STY   Sendl             ; save output string index
001B29r 2               LAB_29F7
001B29r 2  A0 00              LDY   #$00              ; clear index (point to 100,000)
001B2Br 2  A2 80              LDX   #$80              ;
001B2Dr 2               LAB_29FB
001B2Dr 2  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
001B2Fr 2  18                 CLC                     ; clear carry for add
001B30r 2  79 rr rr           ADC   LAB_2A9C,Y        ; add -ve LSB
001B33r 2  85 AF              STA   FAC1_3            ; save FAC1 mantissa3
001B35r 2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
001B37r 2  79 rr rr           ADC   LAB_2A9B,Y        ; add -ve NMSB
001B3Ar 2  85 AE              STA   FAC1_2            ; save FAC1 mantissa2
001B3Cr 2  A5 AD              LDA   FAC1_1            ; get FAC1 mantissa1
001B3Er 2  79 rr rr           ADC   LAB_2A9A,Y        ; add -ve MSB
001B41r 2  85 AD              STA   FAC1_1            ; save FAC1 mantissa1
001B43r 2  E8                 INX                     ;
001B44r 2  B0 04              BCS   LAB_2A18          ;
001B46r 2               
001B46r 2  10 E5              BPL   LAB_29FB          ; not -ve so try again
001B48r 2               
001B48r 2  30 02              BMI   LAB_2A1A          ;
001B4Ar 2               
001B4Ar 2               LAB_2A18
001B4Ar 2  30 E1              BMI   LAB_29FB          ;
001B4Cr 2               
001B4Cr 2               LAB_2A1A
001B4Cr 2  8A                 TXA                     ;
001B4Dr 2  90 04              BCC   LAB_2A21          ;
001B4Fr 2               
001B4Fr 2  49 FF              EOR   #$FF              ;
001B51r 2  69 0A              ADC   #$0A              ;
001B53r 2               LAB_2A21
001B53r 2  69 2F              ADC   #'0'-1            ; add "0"-1 to result
001B55r 2  C8                 INY                     ; increment index ..
001B56r 2  C8                 INY                     ; .. to next less ..
001B57r 2  C8                 INY                     ; .. power of ten
001B58r 2  84 95              STY   Cvaral            ; save as current var address low byte
001B5Ar 2  A4 BA              LDY   Sendl             ; get output string index
001B5Cr 2  C8                 INY                     ; increment output string index
001B5Dr 2  AA                 TAX                     ; copy character to X
001B5Er 2  29 7F              AND   #$7F              ; mask out top bit
001B60r 2  99 EF 00           STA   Decss,Y           ; save to output string
001B63r 2  C6 A8              DEC   numexp            ; decrement # of characters before the dp
001B65r 2  D0 06              BNE   LAB_2A3B          ; branch if still characters to do
001B67r 2               
001B67r 2                                             ; else output the point
001B67r 2  A9 2E              LDA   #$2E              ; character "."
001B69r 2  C8                 INY                     ; increment output string index
001B6Ar 2  99 EF 00           STA   Decss,Y           ; save to output string
001B6Dr 2               LAB_2A3B
001B6Dr 2  84 BA              STY   Sendl             ; save output string index
001B6Fr 2  A4 95              LDY   Cvaral            ; get current var address low byte
001B71r 2  8A                 TXA                     ; get character back
001B72r 2  49 FF              EOR   #$FF              ;
001B74r 2  29 80              AND   #$80              ;
001B76r 2  AA                 TAX                     ;
001B77r 2  C0 12              CPY   #$12              ; compare index with max
001B79r 2  D0 B2              BNE   LAB_29FB          ; loop if not max
001B7Br 2               
001B7Br 2                                             ; now remove trailing zeroes
001B7Br 2  A4 BA              LDY   Sendl             ; get output string index
001B7Dr 2               LAB_2A4B
001B7Dr 2  B9 EF 00           LDA   Decss,Y           ; get character from output string
001B80r 2  88                 DEY                     ; decrement output string index
001B81r 2  C9 30              CMP   #'0'              ; compare with "0"
001B83r 2  F0 F8              BEQ   LAB_2A4B          ; loop until non "0" character found
001B85r 2               
001B85r 2  C9 2E              CMP   #'.'              ; compare with "."
001B87r 2  F0 01              BEQ   LAB_2A58          ; branch if was dp
001B89r 2               
001B89r 2                                             ; restore last character
001B89r 2  C8                 INY                     ; increment output string index
001B8Ar 2               LAB_2A58
001B8Ar 2  A9 2B              LDA   #$2B              ; character "+"
001B8Cr 2  A6 A9              LDX   expcnt            ; get exponent count
001B8Er 2  F0 2E              BEQ   LAB_2A8C          ; if zero go set null terminator and exit
001B90r 2               
001B90r 2                                             ; exponent isn't zero so write exponent
001B90r 2  10 08              BPL   LAB_2A68          ; branch if exponent count +ve
001B92r 2               
001B92r 2  A9 00              LDA   #$00              ; clear A
001B94r 2  38                 SEC                     ; set carry for subtract
001B95r 2  E5 A9              SBC   expcnt            ; subtract exponent count adjust (convert -ve to +ve)
001B97r 2  AA                 TAX                     ; copy exponent count to X
001B98r 2  A9 2D              LDA   #'-'              ; character "-"
001B9Ar 2               LAB_2A68
001B9Ar 2  99 F1 00           STA   Decss+2,Y         ; save to output string
001B9Dr 2  A9 45              LDA   #$45              ; character "E"
001B9Fr 2  99 F0 00           STA   Decss+1,Y         ; save exponent sign to output string
001BA2r 2  8A                 TXA                     ; get exponent count back
001BA3r 2  A2 2F              LDX   #'0'-1            ; one less than "0" character
001BA5r 2  38                 SEC                     ; set carry for subtract
001BA6r 2               LAB_2A74
001BA6r 2  E8                 INX                     ; increment 10's character
001BA7r 2  E9 0A              SBC   #$0A              ;.subtract 10 from exponent count
001BA9r 2  B0 FB              BCS   LAB_2A74          ; loop while still >= 0
001BABr 2               
001BABr 2  69 3A              ADC   #':'              ; add character ":" ($30+$0A, result is 10 less that value)
001BADr 2  99 F3 00           STA   Decss+4,Y         ; save to output string
001BB0r 2  8A                 TXA                     ; copy 10's character
001BB1r 2  99 F2 00           STA   Decss+3,Y         ; save to output string
001BB4r 2  A9 00              LDA   #$00              ; set null terminator
001BB6r 2  99 F4 00           STA   Decss+5,Y         ; save to output string
001BB9r 2  F0 08              BEQ   LAB_2A91          ; go set string pointer (AY) and exit (branch always)
001BBBr 2               
001BBBr 2                                             ; save last character, [EOT] and exit
001BBBr 2               LAB_2A89
001BBBr 2  99 EF 00           STA   Decss,Y           ; save last character to output string
001BBEr 2               
001BBEr 2                                             ; set null terminator and exit
001BBEr 2               LAB_2A8C
001BBEr 2  A9 00              LDA   #$00              ; set null terminator
001BC0r 2  99 F0 00           STA   Decss+1,Y         ; save after last character
001BC3r 2               
001BC3r 2                                             ; set string pointer (AY) and exit
001BC3r 2               LAB_2A91
001BC3r 2  A9 F0              LDA   #<Decssp1         ; set result string low pointer
001BC5r 2  A0 00              LDY   #>Decssp1         ; set result string high pointer
001BC7r 2  60                 RTS
001BC8r 2               
001BC8r 2               ; perform power function
001BC8r 2               
001BC8r 2               LAB_POWER
001BC8r 2  F0 42              BEQ   LAB_EXP           ; go do  EXP()
001BCAr 2               
001BCAr 2  A5 B3              LDA   FAC2_e            ; get FAC2 exponent
001BCCr 2  D0 03              BNE   LAB_2ABF          ; branch if FAC2<>0
001BCEr 2               
001BCEr 2  4C rr rr           JMP   LAB_24F3          ; clear FAC1 exponent and sign and return
001BD1r 2               
001BD1r 2               LAB_2ABF
001BD1r 2  A2 9C              LDX   #<func_l          ; set destination pointer low byte
001BD3r 2  A0 00              LDY   #>func_l          ; set destination pointer high byte
001BD5r 2  20 rr rr           JSR   LAB_2778          ; pack FAC1 into (XY)
001BD8r 2  A5 B7              LDA   FAC2_s            ; get FAC2 sign (b7)
001BDAr 2  10 0F              BPL   LAB_2AD9          ; branch if FAC2>0
001BDCr 2               
001BDCr 2                                             ; else FAC2 is -ve and can only be raised to an
001BDCr 2                                             ; integer power which gives an x +j0 result
001BDCr 2  20 rr rr           JSR   LAB_INT           ; perform INT
001BDFr 2  A9 9C              LDA   #<func_l          ; set source pointer low byte
001BE1r 2  A0 00              LDY   #>func_l          ; set source pointer high byte
001BE3r 2  20 rr rr           JSR   LAB_27F8          ; compare FAC1 with (AY)
001BE6r 2  D0 03              BNE   LAB_2AD9          ; branch if FAC1 <> (AY) to allow Function Call error
001BE8r 2                                             ; this will leave FAC1 -ve and cause a Function Call
001BE8r 2                                             ; error when LOG() is called
001BE8r 2               
001BE8r 2  98                 TYA                     ; clear sign b7
001BE9r 2  A4 5B              LDY   Temp3             ; save mantissa 3 from INT() function as sign in Y
001BEBr 2                                             ; for possible later negation, b0
001BEBr 2               LAB_2AD9
001BEBr 2  20 rr rr           JSR   LAB_279D          ; save FAC1 sign and copy ABS(FAC2) to FAC1
001BEEr 2  98                 TYA                     ; copy sign back ..
001BEFr 2  48                 PHA                     ; .. and save it
001BF0r 2  20 rr rr           JSR   LAB_LOG           ; do LOG(n)
001BF3r 2  A9 9C              LDA   #<garb_l          ; set pointer low byte
001BF5r 2  A0 00              LDY   #>garb_l          ; set pointer high byte
001BF7r 2  20 rr rr           JSR   LAB_25FB          ; do convert AY, FCA1*(AY) (square the value)
001BFAr 2  20 rr rr           JSR   LAB_EXP           ; go do EXP(n)
001BFDr 2  68                 PLA                     ; pull sign from stack
001BFEr 2  4A                 LSR                     ; b0 is to be tested, shift to Cb
001BFFr 2  90 0A              BCC   LAB_2AF9          ; if no bit then exit
001C01r 2               
001C01r 2                                             ; Perform negation
001C01r 2               ; do - FAC1
001C01r 2               
001C01r 2               LAB_GTHAN
001C01r 2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
001C03r 2  F0 06              BEQ   LAB_2AF9          ; exit if FAC1_e = $00
001C05r 2               
001C05r 2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
001C07r 2  49 FF              EOR   #$FF              ; complement it
001C09r 2  85 B0              STA   FAC1_s            ; save FAC1 sign (b7)
001C0Br 2               LAB_2AF9
001C0Br 2  60                 RTS
001C0Cr 2               
001C0Cr 2               ; perform EXP()   (x^e)
001C0Cr 2               
001C0Cr 2               LAB_EXP
001C0Cr 2  A9 rr              LDA   #<LAB_2AFA        ; set 1.443 pointer low byte
001C0Er 2  A0 rr              LDY   #>LAB_2AFA        ; set 1.443 pointer high byte
001C10r 2  20 rr rr           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
001C13r 2  A5 B9              LDA   FAC1_r            ; get FAC1 rounding byte
001C15r 2  69 50              ADC   #$50              ; +$50/$100
001C17r 2  90 03              BCC   LAB_2B2B          ; skip rounding if no carry
001C19r 2               
001C19r 2  20 rr rr           JSR   LAB_27C2          ; round FAC1 (no check)
001C1Cr 2               LAB_2B2B
001C1Cr 2  85 A3              STA   FAC2_r            ; save FAC2 rounding byte
001C1Er 2  20 rr rr           JSR   LAB_27AE          ; copy FAC1 to FAC2
001C21r 2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
001C23r 2  C9 88              CMP   #$88              ; compare with EXP limit (256d)
001C25r 2  90 03              BCC   LAB_2B39          ; branch if less
001C27r 2               
001C27r 2               LAB_2B36
001C27r 2  20 rr rr           JSR   LAB_2690          ; handle overflow and underflow
001C2Ar 2               LAB_2B39
001C2Ar 2  20 rr rr           JSR   LAB_INT           ; perform INT
001C2Dr 2  A5 5B              LDA   Temp3             ; get mantissa 3 from INT() function
001C2Fr 2  18                 CLC                     ; clear carry for add
001C30r 2  69 81              ADC   #$81              ; normalise +1
001C32r 2  F0 F3              BEQ   LAB_2B36          ; if $00 go handle overflow
001C34r 2               
001C34r 2  38                 SEC                     ; set carry for subtract
001C35r 2  E9 01              SBC   #$01              ; now correct for exponent
001C37r 2  48                 PHA                     ; save FAC2 exponent
001C38r 2               
001C38r 2                                             ; swap FAC1 and FAC2
001C38r 2  A2 04              LDX   #$04              ; 4 bytes to do
001C3Ar 2               LAB_2B49
001C3Ar 2  B5 B3              LDA   FAC2_e,X          ; get FAC2,X
001C3Cr 2  B4 AC              LDY   FAC1_e,X          ; get FAC1,X
001C3Er 2  95 AC              STA   FAC1_e,X          ; save FAC1,X
001C40r 2  94 B3              STY   FAC2_e,X          ; save FAC2,X
001C42r 2  CA                 DEX                     ; decrement count/index
001C43r 2  10 F5              BPL   LAB_2B49          ; loop if not all done
001C45r 2               
001C45r 2  A5 A3              LDA   FAC2_r            ; get FAC2 rounding byte
001C47r 2  85 B9              STA   FAC1_r            ; save as FAC1 rounding byte
001C49r 2  20 rr rr           JSR   LAB_SUBTRACT      ; perform subtraction, FAC2 from FAC1
001C4Cr 2  20 rr rr           JSR   LAB_GTHAN         ; do - FAC1
001C4Fr 2  A9 rr              LDA   #<LAB_2AFE        ; set counter pointer low byte
001C51r 2  A0 rr              LDY   #>LAB_2AFE        ; set counter pointer high byte
001C53r 2  20 rr rr           JSR   LAB_2B84          ; go do series evaluation
001C56r 2  A9 00              LDA   #$00              ; clear A
001C58r 2  85 B8              STA   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
001C5Ar 2  68                 PLA                     ;.get saved FAC2 exponent
001C5Br 2  4C rr rr           JMP   LAB_2675          ; test and adjust accumulators and return
001C5Er 2               
001C5Er 2               ; ^2 then series evaluation
001C5Er 2               
001C5Er 2               LAB_2B6E
001C5Er 2  85 BA              STA   Cptrl             ; save count pointer low byte
001C60r 2  84 BB              STY   Cptrh             ; save count pointer high byte
001C62r 2  20 rr rr           JSR   LAB_276E          ; pack FAC1 into Adatal
001C65r 2  A9 A4              LDA   #<Adatal          ; set pointer low byte (Y already $00)
001C67r 2  20 rr rr           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
001C6Ar 2  20 rr rr           JSR   LAB_2B88          ; go do series evaluation
001C6Dr 2  A9 A4              LDA   #<Adatal          ; pointer to original # low byte
001C6Fr 2  A0 00              LDY   #>Adatal          ; pointer to original # high byte
001C71r 2  4C rr rr           JMP   LAB_25FB          ; do convert AY, FCA1*(AY) and return
001C74r 2               
001C74r 2               ; series evaluation
001C74r 2               
001C74r 2               LAB_2B84
001C74r 2  85 BA              STA   Cptrl             ; save count pointer low byte
001C76r 2  84 BB              STY   Cptrh             ; save count pointer high byte
001C78r 2               LAB_2B88
001C78r 2  A2 A8              LDX   #<numexp          ; set pointer low byte
001C7Ar 2  20 rr rr           JSR   LAB_2770          ; set pointer high byte and pack FAC1 into numexp
001C7Dr 2  B1 BA              LDA   (Cptrl),Y         ; get constants count
001C7Fr 2  85 B1              STA   numcon            ; save constants count
001C81r 2  A4 BA              LDY   Cptrl             ; get count pointer low byte
001C83r 2  C8                 INY                     ; increment it (now constants pointer)
001C84r 2  98                 TYA                     ; copy it
001C85r 2  D0 02              BNE   LAB_2B97          ; skip next if no overflow
001C87r 2               
001C87r 2  E6 BB              INC   Cptrh             ; else increment high byte
001C89r 2               LAB_2B97
001C89r 2  85 BA              STA   Cptrl             ; save low byte
001C8Br 2  A4 BB              LDY   Cptrh             ; get high byte
001C8Dr 2               LAB_2B9B
001C8Dr 2  20 rr rr           JSR   LAB_25FB          ; do convert AY, FCA1*(AY)
001C90r 2  A5 BA              LDA   Cptrl             ; get constants pointer low byte
001C92r 2  A4 BB              LDY   Cptrh             ; get constants pointer high byte
001C94r 2  18                 CLC                     ; clear carry for add
001C95r 2  69 04              ADC   #$04              ; +4 to  low pointer (4 bytes per constant)
001C97r 2  90 01              BCC   LAB_2BA8          ; skip next if no overflow
001C99r 2               
001C99r 2  C8                 INY                     ; increment high byte
001C9Ar 2               LAB_2BA8
001C9Ar 2  85 BA              STA   Cptrl             ; save pointer low byte
001C9Cr 2  84 BB              STY   Cptrh             ; save pointer high byte
001C9Er 2  20 rr rr           JSR   LAB_246C          ; add (AY) to FAC1
001CA1r 2  A9 A8              LDA   #<numexp          ; set pointer low byte to partial @ numexp
001CA3r 2  A0 00              LDY   #>numexp          ; set pointer high byte to partial @ numexp
001CA5r 2  C6 B1              DEC   numcon            ; decrement constants count
001CA7r 2  D0 E4              BNE   LAB_2B9B          ; loop until all done
001CA9r 2               
001CA9r 2  60                 RTS
001CAAr 2               
001CAAr 2               ; RND(n), 32 bit Galoise version. make n=0 for 19th next number in sequence or n<>0
001CAAr 2               ; to get 19th next number in sequence after seed n. This version of the PRNG uses
001CAAr 2               ; the Galois method and a sample of 65536 bytes produced gives the following values.
001CAAr 2               
001CAAr 2               ; Entropy = 7.997442 bits per byte
001CAAr 2               ; Optimum compression would reduce these 65536 bytes by 0 percent
001CAAr 2               
001CAAr 2               ; Chi square distribution for 65536 samples is 232.01, and
001CAAr 2               ; randomly would exceed this value 75.00 percent of the time
001CAAr 2               
001CAAr 2               ; Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
001CAAr 2               ; Monte Carlo value for Pi is 3.122871269, error 0.60 percent
001CAAr 2               ; Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
001CAAr 2               
001CAAr 2               LAB_RND
001CAAr 2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
001CACr 2  F0 07              BEQ   NextPRN           ; do next random # if zero
001CAEr 2               
001CAEr 2                                             ; else get seed into random number store
001CAEr 2  A2 D8              LDX   #Rbyte4           ; set PRNG pointer low byte
001CB0r 2  A0 00              LDY   #$00              ; set PRNG pointer high byte
001CB2r 2  20 rr rr           JSR   LAB_2778          ; pack FAC1 into (XY)
001CB5r 2               NextPRN
001CB5r 2  A2 AF              LDX   #$AF              ; set EOR byte
001CB7r 2  A0 13              LDY   #$13              ; do this nineteen times
001CB9r 2               LoopPRN
001CB9r 2  06 D9              ASL   Rbyte1            ; shift PRNG most significant byte
001CBBr 2  26 DA              ROL   Rbyte2            ; shift PRNG middle byte
001CBDr 2  26 DB              ROL   Rbyte3            ; shift PRNG least significant byte
001CBFr 2  26 D8              ROL   Rbyte4            ; shift PRNG extra byte
001CC1r 2  90 05              BCC   Ninc1             ; branch if bit 32 clear
001CC3r 2               
001CC3r 2  8A                 TXA                     ; set EOR byte
001CC4r 2  45 D9              EOR   Rbyte1            ; EOR PRNG extra byte
001CC6r 2  85 D9              STA   Rbyte1            ; save new PRNG extra byte
001CC8r 2               Ninc1
001CC8r 2  88                 DEY                     ; decrement loop count
001CC9r 2  D0 EE              BNE   LoopPRN           ; loop if not all done
001CCBr 2               
001CCBr 2  A2 02              LDX   #$02              ; three bytes to copy
001CCDr 2               CopyPRNG
001CCDr 2  B5 D9              LDA   Rbyte1,X          ; get PRNG byte
001CCFr 2  95 AD              STA   FAC1_1,X          ; save FAC1 byte
001CD1r 2  CA                 DEX
001CD2r 2  10 F9              BPL   CopyPRNG          ; loop if not complete
001CD4r 2               
001CD4r 2  A9 80              LDA   #$80              ; set the exponent
001CD6r 2  85 AC              STA   FAC1_e            ; save FAC1 exponent
001CD8r 2               
001CD8r 2  0A                 ASL                     ; clear A
001CD9r 2  85 B0              STA   FAC1_s            ; save FAC1 sign
001CDBr 2               
001CDBr 2  4C rr rr           JMP   LAB_24D5          ; normalise FAC1 and return
001CDEr 2               
001CDEr 2               ; perform COS()
001CDEr 2               
001CDEr 2               LAB_COS
001CDEr 2  A9 rr              LDA   #<LAB_2C78        ; set (pi/2) pointer low byte
001CE0r 2  A0 rr              LDY   #>LAB_2C78        ; set (pi/2) pointer high byte
001CE2r 2  20 rr rr           JSR   LAB_246C          ; add (AY) to FAC1
001CE5r 2               
001CE5r 2               ; perform SIN()
001CE5r 2               
001CE5r 2               LAB_SIN
001CE5r 2  20 rr rr           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
001CE8r 2  A9 rr              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
001CEAr 2  A0 rr              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
001CECr 2  A6 B7              LDX   FAC2_s            ; get FAC2 sign (b7)
001CEEr 2  20 rr rr           JSR   LAB_26C2          ; divide by (AY) (X=sign)
001CF1r 2  20 rr rr           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
001CF4r 2  20 rr rr           JSR   LAB_INT           ; perform INT
001CF7r 2  A9 00              LDA   #$00              ; clear byte
001CF9r 2  85 B8              STA   FAC_sc            ; clear sign compare (FAC1 EOR FAC2)
001CFBr 2  20 rr rr           JSR   LAB_SUBTRACT      ; perform subtraction, FAC2 from FAC1
001CFEr 2  A9 rr              LDA   #<LAB_2C80        ; set 0.25 pointer low byte
001D00r 2  A0 rr              LDY   #>LAB_2C80        ; set 0.25 pointer high byte
001D02r 2  20 rr rr           JSR   LAB_2455          ; perform subtraction, (AY) from FAC1
001D05r 2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
001D07r 2  48                 PHA                     ; save FAC1 sign
001D08r 2  10 0D              BPL   LAB_2C35          ; branch if +ve
001D0Ar 2               
001D0Ar 2                                             ; FAC1 sign was -ve
001D0Ar 2  20 rr rr           JSR   LAB_244E          ; add 0.5 to FAC1
001D0Dr 2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
001D0Fr 2  30 09              BMI   LAB_2C38          ; branch if -ve
001D11r 2               
001D11r 2  A5 63              LDA   Cflag             ; get comparison evaluation flag
001D13r 2  49 FF              EOR   #$FF              ; toggle flag
001D15r 2  85 63              STA   Cflag             ; save comparison evaluation flag
001D17r 2               LAB_2C35
001D17r 2  20 rr rr           JSR   LAB_GTHAN         ; do - FAC1
001D1Ar 2               LAB_2C38
001D1Ar 2  A9 rr              LDA   #<LAB_2C80        ; set 0.25 pointer low byte
001D1Cr 2  A0 rr              LDY   #>LAB_2C80        ; set 0.25 pointer high byte
001D1Er 2  20 rr rr           JSR   LAB_246C          ; add (AY) to FAC1
001D21r 2  68                 PLA                     ; restore FAC1 sign
001D22r 2  10 03              BPL   LAB_2C45          ; branch if was +ve
001D24r 2               
001D24r 2                                             ; else correct FAC1
001D24r 2  20 rr rr           JSR   LAB_GTHAN         ; do - FAC1
001D27r 2               LAB_2C45
001D27r 2  A9 rr              LDA   #<LAB_2C84        ; set pointer low byte to counter
001D29r 2  A0 rr              LDY   #>LAB_2C84        ; set pointer high byte to counter
001D2Br 2  4C rr rr           JMP   LAB_2B6E          ; ^2 then series evaluation and return
001D2Er 2               
001D2Er 2               ; perform TAN()
001D2Er 2               
001D2Er 2               LAB_TAN
001D2Er 2  20 rr rr           JSR   LAB_276E          ; pack FAC1 into Adatal
001D31r 2  A9 00              LDA   #$00              ; clear byte
001D33r 2  85 63              STA   Cflag             ; clear comparison evaluation flag
001D35r 2  20 rr rr           JSR   LAB_SIN           ; go do SIN(n)
001D38r 2  A2 9C              LDX   #<func_l          ; set sin(n) pointer low byte
001D3Ar 2  A0 00              LDY   #>func_l          ; set sin(n) pointer high byte
001D3Cr 2  20 rr rr           JSR   LAB_2778          ; pack FAC1 into (XY)
001D3Fr 2  A9 A4              LDA   #<Adatal          ; set n pointer low addr
001D41r 2  A0 00              LDY   #>Adatal          ; set n pointer high addr
001D43r 2  20 rr rr           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
001D46r 2  A9 00              LDA   #$00              ; clear byte
001D48r 2  85 B0              STA   FAC1_s            ; clear FAC1 sign (b7)
001D4Ar 2  A5 63              LDA   Cflag             ; get comparison evaluation flag
001D4Cr 2  20 rr rr           JSR   LAB_2C74          ; save flag and go do series evaluation
001D4Fr 2               
001D4Fr 2  A9 9C              LDA   #<func_l          ; set sin(n) pointer low byte
001D51r 2  A0 00              LDY   #>func_l          ; set sin(n) pointer high byte
001D53r 2  4C rr rr           JMP   LAB_26CA          ; convert AY and do (AY)/FAC1
001D56r 2               
001D56r 2               LAB_2C74
001D56r 2  48                 PHA                     ; save comparison evaluation flag
001D57r 2  4C rr rr           JMP   LAB_2C35          ; go do series evaluation
001D5Ar 2               
001D5Ar 2               ; perform USR()
001D5Ar 2               
001D5Ar 2               LAB_USR
001D5Ar 2  20 0A 00           JSR   Usrjmp            ; call user code
001D5Dr 2  4C rr rr           JMP   LAB_1BFB          ; scan for ")", else do syntax error then warm start
001D60r 2               
001D60r 2               ; perform ATN()
001D60r 2               
001D60r 2               LAB_ATN
001D60r 2  A5 B0              LDA   FAC1_s            ; get FAC1 sign (b7)
001D62r 2  48                 PHA                     ; save sign
001D63r 2  10 03              BPL   LAB_2CA1          ; branch if +ve
001D65r 2               
001D65r 2  20 rr rr           JSR   LAB_GTHAN         ; else do - FAC1
001D68r 2               LAB_2CA1
001D68r 2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
001D6Ar 2  48                 PHA                     ; push exponent
001D6Br 2  C9 81              CMP   #$81              ; compare with 1
001D6Dr 2  90 07              BCC   LAB_2CAF          ; branch if FAC1<1
001D6Fr 2               
001D6Fr 2  A9 rr              LDA   #<LAB_259C        ; set 1 pointer low byte
001D71r 2  A0 rr              LDY   #>LAB_259C        ; set 1 pointer high byte
001D73r 2  20 rr rr           JSR   LAB_26CA          ; convert AY and do (AY)/FAC1
001D76r 2               LAB_2CAF
001D76r 2  A9 rr              LDA   #<LAB_2CC9        ; set pointer low byte to counter
001D78r 2  A0 rr              LDY   #>LAB_2CC9        ; set pointer high byte to counter
001D7Ar 2  20 rr rr           JSR   LAB_2B6E          ; ^2 then series evaluation
001D7Dr 2  68                 PLA                     ; restore old FAC1 exponent
001D7Er 2  C9 81              CMP   #$81              ; compare with 1
001D80r 2  90 07              BCC   LAB_2CC2          ; branch if FAC1<1
001D82r 2               
001D82r 2  A9 rr              LDA   #<LAB_2C78        ; set (pi/2) pointer low byte
001D84r 2  A0 rr              LDY   #>LAB_2C78        ; set (pi/2) pointer high byte
001D86r 2  20 rr rr           JSR   LAB_2455          ; perform subtraction, (AY) from FAC1
001D89r 2               LAB_2CC2
001D89r 2  68                 PLA                     ; restore FAC1 sign
001D8Ar 2  10 16              BPL   LAB_2D04          ; exit if was +ve
001D8Cr 2               
001D8Cr 2  4C rr rr           JMP   LAB_GTHAN         ; else do - FAC1 and return
001D8Fr 2               
001D8Fr 2               ; perform BITSET
001D8Fr 2               
001D8Fr 2               LAB_BITSET
001D8Fr 2  20 rr rr           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
001D92r 2  E0 08              CPX   #$08              ; only 0 to 7 are allowed
001D94r 2  B0 20              BCS   FCError           ; branch if > 7
001D96r 2               
001D96r 2  A9 00              LDA   #$00              ; clear A
001D98r 2  38                 SEC                     ; set the carry
001D99r 2               S_Bits
001D99r 2  2A                 ROL                     ; shift bit
001D9Ar 2  CA                 DEX                     ; decrement bit number
001D9Br 2  10 FC              BPL   S_Bits            ; loop if still +ve
001D9Dr 2               
001D9Dr 2  E8                 INX                     ; make X = $00
001D9Er 2  01 11              ORA   (Itempl,X)        ; or with byte via temporary integer (addr)
001DA0r 2  81 11              STA   (Itempl,X)        ; save byte via temporary integer (addr)
001DA2r 2               LAB_2D04
001DA2r 2  60                 RTS
001DA3r 2               
001DA3r 2               ; perform BITCLR
001DA3r 2               
001DA3r 2               LAB_BITCLR
001DA3r 2  20 rr rr           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
001DA6r 2  E0 08              CPX   #$08              ; only 0 to 7 are allowed
001DA8r 2  B0 0C              BCS   FCError           ; branch if > 7
001DAAr 2               
001DAAr 2  A9 FF              LDA   #$FF              ; set A
001DACr 2               S_Bitc
001DACr 2  2A                 ROL                     ; shift bit
001DADr 2  CA                 DEX                     ; decrement bit number
001DAEr 2  10 FC              BPL   S_Bitc            ; loop if still +ve
001DB0r 2               
001DB0r 2  E8                 INX                     ; make X = $00
001DB1r 2  21 11              AND   (Itempl,X)        ; and with byte via temporary integer (addr)
001DB3r 2  81 11              STA   (Itempl,X)        ; save byte via temporary integer (addr)
001DB5r 2  60                 RTS
001DB6r 2               
001DB6r 2               FCError
001DB6r 2  4C rr rr           JMP   LAB_FCER          ; do function call error then warm start
001DB9r 2               
001DB9r 2               ; perform BITTST()
001DB9r 2               
001DB9r 2               LAB_BTST
001DB9r 2  20 BC 00           JSR   LAB_IGBY          ; increment BASIC pointer
001DBCr 2  20 rr rr           JSR   LAB_GADB          ; get two parameters for POKE or WAIT
001DBFr 2  E0 08              CPX   #$08              ; only 0 to 7 are allowed
001DC1r 2  B0 F3              BCS   FCError           ; branch if > 7
001DC3r 2               
001DC3r 2  20 C2 00           JSR   LAB_GBYT          ; get next BASIC byte
001DC6r 2  C9 29              CMP   #')'              ; is next character ")"
001DC8r 2  F0 03              BEQ   TST_OK            ; if ")" go do rest of function
001DCAr 2               
001DCAr 2  4C rr rr           JMP   LAB_SNER          ; do syntax error then warm start
001DCDr 2               
001DCDr 2               TST_OK
001DCDr 2  20 BC 00           JSR   LAB_IGBY          ; update BASIC execute pointer (to character past ")")
001DD0r 2  A9 00              LDA   #$00              ; clear A
001DD2r 2  38                 SEC                     ; set the carry
001DD3r 2               T_Bits
001DD3r 2  2A                 ROL                     ; shift bit
001DD4r 2  CA                 DEX                     ; decrement bit number
001DD5r 2  10 FC              BPL   T_Bits            ; loop if still +ve
001DD7r 2               
001DD7r 2  E8                 INX                     ; make X = $00
001DD8r 2  21 11              AND   (Itempl,X)        ; AND with byte via temporary integer (addr)
001DDAr 2  F0 02              BEQ   LAB_NOTT          ; branch if zero (already correct)
001DDCr 2               
001DDCr 2  A9 FF              LDA   #$FF              ; set for -1 result
001DDEr 2               LAB_NOTT
001DDEr 2  4C rr rr           JMP   LAB_27DB          ; go do SGN tail
001DE1r 2               
001DE1r 2               ; perform BIN$()
001DE1r 2               
001DE1r 2               LAB_BINS
001DE1r 2  E0 19              CPX   #$19              ; max + 1
001DE3r 2  B0 48              BCS   BinFErr           ; exit if too big ( > or = )
001DE5r 2               
001DE5r 2  86 78              STX   TempB             ; save # of characters ($00 = leading zero remove)
001DE7r 2  A9 18              LDA   #$18              ; need A byte long space
001DE9r 2  20 rr rr           JSR   LAB_MSSP          ; make string space A bytes long
001DECr 2  A0 17              LDY   #$17              ; set index
001DEEr 2  A2 18              LDX   #$18              ; character count
001DF0r 2               NextB1
001DF0r 2  46 11              LSR   nums_1            ; shift highest byte
001DF2r 2  66 12              ROR   nums_2            ; shift middle byte
001DF4r 2  66 13              ROR   nums_3            ; shift lowest byte bit 0 to carry
001DF6r 2  8A                 TXA                     ; load with "0"/2
001DF7r 2  2A                 ROL                     ; shift in carry
001DF8r 2  91 AD              STA   (str_pl),Y        ; save to temp string + index
001DFAr 2  88                 DEY                     ; decrement index
001DFBr 2  10 F3              BPL   NextB1            ; loop if not done
001DFDr 2               
001DFDr 2  A5 78              LDA   TempB             ; get # of characters
001DFFr 2  F0 0A              BEQ   EndBHS            ; branch if truncate
001E01r 2               
001E01r 2  AA                 TAX                     ; copy length to X
001E02r 2  38                 SEC                     ; set carry for add !
001E03r 2  49 FF              EOR   #$FF              ; 1's complement
001E05r 2  69 18              ADC   #$18              ; add 24d
001E07r 2  F0 1C              BEQ   GoPr2             ; if zero print whole string
001E09r 2               
001E09r 2  D0 0F              BNE   GoPr1             ; else go make output string
001E0Br 2               
001E0Br 2               ; this is the exit code and is also used by HEX$()
001E0Br 2               ; truncate string to remove leading "0"s
001E0Br 2               
001E0Br 2               EndBHS
001E0Br 2  A8                 TAY                     ; clear index (A=0, X=length here)
001E0Cr 2               NextB2
001E0Cr 2  B1 AD              LDA   (str_pl),Y        ; get character from string
001E0Er 2  C9 30              CMP   #'0'              ; compare with "0"
001E10r 2  D0 07              BNE   GoPr              ; if not "0" then go print string from here
001E12r 2               
001E12r 2  CA                 DEX                     ; decrement character count
001E13r 2  F0 03              BEQ   GoPr3             ; if zero then end of string so go print it
001E15r 2               
001E15r 2  C8                 INY                     ; else increment index
001E16r 2  10 F4              BPL   NextB2            ; loop always
001E18r 2               
001E18r 2               ; make fixed length output string - ignore overflows!
001E18r 2               
001E18r 2               GoPr3
001E18r 2  E8                 INX                     ; need at least 1 character
001E19r 2               GoPr
001E19r 2  98                 TYA                     ; copy result
001E1Ar 2               GoPr1
001E1Ar 2  18                 CLC                     ; clear carry for add
001E1Br 2  65 AD              ADC   str_pl            ; add low address
001E1Dr 2  85 AD              STA   str_pl            ; save low address
001E1Fr 2  A9 00              LDA   #$00              ; do high byte
001E21r 2  65 AE              ADC   str_ph            ; add high address
001E23r 2  85 AE              STA   str_ph            ; save high address
001E25r 2               GoPr2
001E25r 2  86 AC              STX   str_ln            ; X holds string length
001E27r 2  20 BC 00           JSR   LAB_IGBY          ; update BASIC execute pointer (to character past ")")
001E2Ar 2  4C rr rr           JMP   LAB_RTST          ; check for space on descriptor stack then put address
001E2Dr 2                                             ; and length on descriptor stack and update stack pointers
001E2Dr 2               
001E2Dr 2               BinFErr
001E2Dr 2  4C rr rr           JMP   LAB_FCER          ; do function call error then warm start
001E30r 2               
001E30r 2               ; perform HEX$()
001E30r 2               
001E30r 2               LAB_HEXS
001E30r 2  E0 07              CPX   #$07              ; max + 1
001E32r 2  B0 F9              BCS   BinFErr           ; exit if too big ( > or = )
001E34r 2               
001E34r 2  86 78              STX   TempB             ; save # of characters
001E36r 2               
001E36r 2  A9 06              LDA   #$06              ; need 6 bytes for string
001E38r 2  20 rr rr           JSR   LAB_MSSP          ; make string space A bytes long
001E3Br 2  A0 05              LDY   #$05              ; set string index
001E3Dr 2               
001E3Dr 2               ; *** disable decimal mode patch - comment next line ***
001E3Dr 2               ;      SED                     ; need decimal mode for nibble convert
001E3Dr 2  A5 13              LDA   nums_3            ; get lowest byte
001E3Fr 2  20 rr rr           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
001E42r 2  A5 12              LDA   nums_2            ; get middle byte
001E44r 2  20 rr rr           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
001E47r 2  A5 11              LDA   nums_1            ; get highest byte
001E49r 2  20 rr rr           JSR   LAB_A2HX          ; convert A to ASCII hex byte and output
001E4Cr 2               ; *** disable decimal mode patch - comment next line ***
001E4Cr 2               ;      CLD                     ; back to binary
001E4Cr 2               
001E4Cr 2  A2 06              LDX   #$06              ; character count
001E4Er 2  A5 78              LDA   TempB             ; get # of characters
001E50r 2  F0 B9              BEQ   EndBHS            ; branch if truncate
001E52r 2               
001E52r 2  AA                 TAX                     ; copy length to X
001E53r 2  38                 SEC                     ; set carry for add !
001E54r 2  49 FF              EOR   #$FF              ; 1's complement
001E56r 2  69 06              ADC   #$06              ; add 6d
001E58r 2  F0 CB              BEQ   GoPr2             ; if zero print whole string
001E5Ar 2               
001E5Ar 2  D0 BE              BNE   GoPr1             ; else go make output string (branch always)
001E5Cr 2               
001E5Cr 2               ; convert A to ASCII hex byte and output .. note set decimal mode before calling
001E5Cr 2               
001E5Cr 2               LAB_A2HX
001E5Cr 2  AA                 TAX                     ; save byte
001E5Dr 2  29 0F              AND   #$0F              ; mask off top bits
001E5Fr 2  20 rr rr           JSR   LAB_AL2X          ; convert low nibble to ASCII and output
001E62r 2  8A                 TXA                     ; get byte back
001E63r 2  4A                 LSR                     ; /2  shift high nibble to low nibble
001E64r 2  4A                 LSR                     ; /4
001E65r 2  4A                 LSR                     ; /8
001E66r 2  4A                 LSR                     ; /16
001E67r 2               LAB_AL2X
001E67r 2  C9 0A              CMP   #$0A              ; set carry for +1 if >9
001E69r 2               ; *** begin disable decimal mode patch ***
001E69r 2               ; *** insert
001E69r 2  90 02              BCC   LAB_AL20          ; skip adjust if <= 9
001E6Br 2  69 06              ADC   #$06              ; adjust for A to F
001E6Dr 2               LAB_AL20
001E6Dr 2               ; *** end   disable decimal mode patch ***
001E6Dr 2  69 30              ADC   #'0'              ; add ASCII "0"
001E6Fr 2  91 AD              STA   (str_pl),Y        ; save to temp string
001E71r 2  88                 DEY                     ; decrement counter
001E72r 2  60                 RTS
001E73r 2               
001E73r 2               LAB_NLTO
001E73r 2  85 AC              STA   FAC1_e            ; save FAC1 exponent
001E75r 2  A9 00              LDA   #$00              ; clear sign compare
001E77r 2               LAB_MLTE
001E77r 2  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
001E79r 2  8A                 TXA                     ; restore character
001E7Ar 2  20 rr rr           JSR   LAB_2912          ; evaluate new ASCII digit
001E7Dr 2               
001E7Dr 2               ; gets here if the first character was "$" for hex
001E7Dr 2               ; get hex number
001E7Dr 2               
001E7Dr 2               LAB_CHEX
001E7Dr 2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
001E80r 2  90 0A              BCC   LAB_ISHN          ; branch if numeric character
001E82r 2               
001E82r 2  09 20              ORA   #$20              ; case convert, allow "A" to "F" and "a" to "f"
001E84r 2  E9 61              SBC   #'a'              ; subtract "a" (carry set here)
001E86r 2  C9 06              CMP   #$06              ; compare normalised with $06 (max+1)
001E88r 2  B0 2A              BCS   LAB_EXCH          ; exit if >"f" or <"0"
001E8Ar 2               
001E8Ar 2  69 0A              ADC   #$0A              ; convert to nibble
001E8Cr 2               LAB_ISHN
001E8Cr 2  29 0F              AND   #$0F              ; convert to binary
001E8Er 2  AA                 TAX                     ; save nibble
001E8Fr 2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
001E91r 2  F0 E4              BEQ   LAB_MLTE          ; skip multiply if zero
001E93r 2               
001E93r 2  69 04              ADC   #$04              ; add four to exponent (*16 - carry clear here)
001E95r 2  90 DC              BCC   LAB_NLTO          ; if no overflow do evaluate digit
001E97r 2               
001E97r 2               LAB_MLTO
001E97r 2  4C rr rr           JMP   LAB_2564          ; do overflow error and warm start
001E9Ar 2               
001E9Ar 2               LAB_NXCH
001E9Ar 2  AA                 TAX                     ; save bit
001E9Br 2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
001E9Dr 2  F0 06              BEQ   LAB_MLBT          ; skip multiply if zero
001E9Fr 2               
001E9Fr 2  E6 AC              INC   FAC1_e            ; increment FAC1 exponent (*2)
001EA1r 2  F0 F4              BEQ   LAB_MLTO          ; do overflow error if = $00
001EA3r 2               
001EA3r 2  A9 00              LDA   #$00              ; clear sign compare
001EA5r 2               LAB_MLBT
001EA5r 2  85 B8              STA   FAC_sc            ; save sign compare (FAC1 EOR FAC2)
001EA7r 2  8A                 TXA                     ; restore bit
001EA8r 2  20 rr rr           JSR   LAB_2912          ; evaluate new ASCII digit
001EABr 2               
001EABr 2               ; gets here if the first character was  "%" for binary
001EABr 2               ; get binary number
001EABr 2               
001EABr 2               LAB_CBIN
001EABr 2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
001EAEr 2  49 30              EOR   #'0'              ; convert "0" to 0 etc.
001EB0r 2  C9 02              CMP   #$02              ; compare with max+1
001EB2r 2  90 E6              BCC   LAB_NXCH          ; branch exit if < 2
001EB4r 2               
001EB4r 2               LAB_EXCH
001EB4r 2  4C rr rr           JMP   LAB_28F6          ; evaluate -ve flag and return
001EB7r 2               
001EB7r 2               ; ctrl-c check routine. includes limited "life" byte save for INGET routine
001EB7r 2               ; now also the code that checks to see if an interrupt has occurred
001EB7r 2               
001EB7r 2               CTRLC
001EB7r 2  AD 00 02           LDA   ccflag            ; get [CTRL-C] check flag
001EBAr 2  D0 18              BNE   LAB_FBA2          ; exit if inhibited
001EBCr 2               
001EBCr 2  20 rr rr           JSR   V_INPT            ; scan input device
001EBFr 2  90 0B              BCC   LAB_FBA0          ; exit if buffer empty
001EC1r 2               
001EC1r 2  8D 01 02           STA   ccbyte            ; save received byte
001EC4r 2  A2 20              LDX   #$20              ; "life" timer for bytes
001EC6r 2  8E 02 02           STX   ccnull            ; set countdown
001EC9r 2  4C rr rr           JMP   LAB_1636          ; return to BASIC
001ECCr 2               
001ECCr 2               LAB_FBA0
001ECCr 2  AE 02 02           LDX   ccnull            ; get countdown byte
001ECFr 2  F0 03              BEQ   LAB_FBA2          ; exit if finished
001ED1r 2               
001ED1r 2  CE 02 02           DEC   ccnull            ; else decrement countdown
001ED4r 2               LAB_FBA2
001ED4r 2  A2 DC              LDX   #NmiBase          ; set pointer to NMI values
001ED6r 2  20 rr rr           JSR   LAB_CKIN          ; go check interrupt
001ED9r 2  A2 DF              LDX   #IrqBase          ; set pointer to IRQ values
001EDBr 2  20 rr rr           JSR   LAB_CKIN          ; go check interrupt
001EDEr 2               LAB_CRTS
001EDEr 2  60                 RTS
001EDFr 2               
001EDFr 2               ; check whichever interrupt is indexed by X
001EDFr 2               
001EDFr 2               LAB_CKIN
001EDFr 2  B5 00              LDA   PLUS_0,X          ; get interrupt flag byte
001EE1r 2  10 FB              BPL   LAB_CRTS          ; branch if interrupt not enabled
001EE3r 2               
001EE3r 2               ; we disable the interrupt here and make two new commands RETIRQ and RETNMI to
001EE3r 2               ; automatically enable the interrupt when we exit
001EE3r 2               
001EE3r 2  0A                 ASL                     ; move happened bit to setup bit
001EE4r 2  29 40              AND   #$40              ; mask happened bits
001EE6r 2  F0 F6              BEQ   LAB_CRTS          ; if no interrupt then exit
001EE8r 2               
001EE8r 2  95 00              STA   PLUS_0,X          ; save interrupt flag byte
001EEAr 2               
001EEAr 2  8A                 TXA                     ; copy index ..
001EEBr 2  A8                 TAY                     ; .. to Y
001EECr 2               
001EECr 2  68                 PLA                     ; dump return address low byte, call from CTRL-C
001EEDr 2  68                 PLA                     ; dump return address high byte
001EEEr 2               
001EEEr 2  A9 05              LDA   #$05              ; need 5 bytes for GOSUB
001EF0r 2  20 rr rr           JSR   LAB_1212          ; check room on stack for A bytes
001EF3r 2  A5 C4              LDA   Bpntrh            ; get BASIC execute pointer high byte
001EF5r 2  48                 PHA                     ; push on stack
001EF6r 2  A5 C3              LDA   Bpntrl            ; get BASIC execute pointer low byte
001EF8r 2  48                 PHA                     ; push on stack
001EF9r 2  A5 88              LDA   Clineh            ; get current line high byte
001EFBr 2  48                 PHA                     ; push on stack
001EFCr 2  A5 87              LDA   Clinel            ; get current line low byte
001EFEr 2  48                 PHA                     ; push on stack
001EFFr 2  A9 8D              LDA   #TK_GOSUB         ; token for GOSUB
001F01r 2  48                 PHA                     ; push on stack
001F02r 2               
001F02r 2  B9 01 00           LDA   PLUS_1,Y          ; get interrupt code pointer low byte
001F05r 2  85 C3              STA   Bpntrl            ; save as BASIC execute pointer low byte
001F07r 2  B9 02 00           LDA   PLUS_2,Y          ; get interrupt code pointer high byte
001F0Ar 2  85 C4              STA   Bpntrh            ; save as BASIC execute pointer high byte
001F0Cr 2               
001F0Cr 2  4C rr rr           JMP   LAB_15C2          ; go do interpreter inner loop
001F0Fr 2                                             ; can't RTS, we used the stack! the RTS from the ctrl-c
001F0Fr 2                                             ; check will be taken when the RETIRQ/RETNMI/RETURN is
001F0Fr 2                                             ; executed at the end of the subroutine
001F0Fr 2               
001F0Fr 2               ; get byte from input device, no waiting
001F0Fr 2               ; returns with carry set if byte in A
001F0Fr 2               
001F0Fr 2               INGET
001F0Fr 2  20 rr rr           JSR   V_INPT            ; call scan input device
001F12r 2  B0 09              BCS   LAB_FB95          ; if byte go reset timer
001F14r 2               
001F14r 2  AD 02 02           LDA   ccnull            ; get countdown
001F17r 2  F0 09              BEQ   LAB_FB96          ; exit if empty
001F19r 2               
001F19r 2  AD 01 02           LDA   ccbyte            ; get last received byte
001F1Cr 2  38                 SEC                     ; flag we got a byte
001F1Dr 2               LAB_FB95
001F1Dr 2  A2 00              LDX   #$00              ; clear X
001F1Fr 2  8E 02 02           STX   ccnull            ; clear timer because we got a byte
001F22r 2               LAB_FB96
001F22r 2  60                 RTS
001F23r 2               
001F23r 2               ; these routines only enable the interrupts if the set-up flag is set
001F23r 2               ; if not they have no effect
001F23r 2               
001F23r 2               ; perform IRQ {ON|OFF|CLEAR}
001F23r 2               
001F23r 2               LAB_IRQ
001F23r 2  A2 DF              LDX   #IrqBase          ; set pointer to IRQ values
001F25r 2  2C                 .byte $2C               ; make next line BIT abs.
001F26r 2               
001F26r 2               ; perform NMI {ON|OFF|CLEAR}
001F26r 2               
001F26r 2               LAB_NMI
001F26r 2  A2 DC              LDX   #NmiBase          ; set pointer to NMI values
001F28r 2  C9 93              CMP   #TK_ON            ; compare with token for ON
001F2Ar 2  F0 11              BEQ   LAB_INON          ; go turn on interrupt
001F2Cr 2               
001F2Cr 2  C9 B5              CMP   #TK_OFF           ; compare with token for OFF
001F2Er 2  F0 07              BEQ   LAB_IOFF          ; go turn off interrupt
001F30r 2               
001F30r 2  49 A2              EOR   #TK_CLEAR         ; compare with token for CLEAR, A = $00 if = TK_CLEAR
001F32r 2  F0 0E              BEQ   LAB_INEX          ; go clear interrupt flags and return
001F34r 2               
001F34r 2  4C rr rr           JMP   LAB_SNER          ; do syntax error then warm start
001F37r 2               
001F37r 2               LAB_IOFF
001F37r 2  A9 7F              LDA   #$7F              ; clear A
001F39r 2  35 00              AND   PLUS_0,X          ; AND with interrupt setup flag
001F3Br 2  10 05              BPL   LAB_INEX          ; go clear interrupt enabled flag and return
001F3Dr 2               
001F3Dr 2               LAB_INON
001F3Dr 2  B5 00              LDA   PLUS_0,X          ; get interrupt setup flag
001F3Fr 2  0A                 ASL                     ; Shift bit to enabled flag
001F40r 2  15 00              ORA   PLUS_0,X          ; OR with flag byte
001F42r 2               LAB_INEX
001F42r 2  95 00              STA   PLUS_0,X          ; save interrupt flag byte
001F44r 2  4C BC 00           JMP   LAB_IGBY          ; update BASIC execute pointer and return
001F47r 2               
001F47r 2               ; these routines set up the pointers and flags for the interrupt routines
001F47r 2               ; note that the interrupts are also enabled by these commands
001F47r 2               
001F47r 2               ; perform ON IRQ
001F47r 2               
001F47r 2               LAB_SIRQ
001F47r 2  58                 CLI                     ; enable interrupts
001F48r 2  A2 DF              LDX   #IrqBase          ; set pointer to IRQ values
001F4Ar 2  2C                 .byte $2C               ; make next line BIT abs.
001F4Br 2               
001F4Br 2               ; perform ON NMI
001F4Br 2               
001F4Br 2               LAB_SNMI
001F4Br 2  A2 DC              LDX   #NmiBase          ; set pointer to NMI values
001F4Dr 2               
001F4Dr 2  86 78              STX   TempB             ; save interrupt pointer
001F4Fr 2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory (past token)
001F52r 2  20 rr rr           JSR   LAB_GFPN          ; get fixed-point number into temp integer
001F55r 2  A5 79              LDA   Smeml             ; get start of mem low byte
001F57r 2  A6 7A              LDX   Smemh             ; get start of mem high byte
001F59r 2  20 rr rr           JSR   LAB_SHLN          ; search Basic for temp integer line number from AX
001F5Cr 2  B0 03              BCS   LAB_LFND          ; if carry set go set-up interrupt
001F5Er 2               
001F5Er 2  4C rr rr           JMP   LAB_16F7          ; else go do "Undefined statement" error and warm start
001F61r 2               
001F61r 2               LAB_LFND
001F61r 2  A6 78              LDX   TempB             ; get interrupt pointer
001F63r 2  A5 AA              LDA   Baslnl            ; get pointer low byte
001F65r 2  E9 01              SBC   #$01              ; -1 (carry already set for subtract)
001F67r 2  95 01              STA   PLUS_1,X          ; save as interrupt pointer low byte
001F69r 2  A5 AB              LDA   Baslnh            ; get pointer high byte
001F6Br 2  E9 00              SBC   #$00              ; subtract carry
001F6Dr 2  95 02              STA   PLUS_2,X          ; save as interrupt pointer high byte
001F6Fr 2               
001F6Fr 2  A9 C0              LDA   #$C0              ; set interrupt enabled/setup bits
001F71r 2  95 00              STA   PLUS_0,X          ; set interrupt flags
001F73r 2               LAB_IRTS
001F73r 2  60                 RTS
001F74r 2               
001F74r 2               ; return from IRQ service, restores the enabled flag.
001F74r 2               
001F74r 2               ; perform RETIRQ
001F74r 2               
001F74r 2               LAB_RETIRQ
001F74r 2  D0 FD              BNE   LAB_IRTS          ; exit if following token (to allow syntax error)
001F76r 2               
001F76r 2  A5 DF              LDA   IrqBase           ; get interrupt flags
001F78r 2  0A                 ASL                     ; copy setup to enabled (b7)
001F79r 2  05 DF              ORA   IrqBase           ; OR in setup flag
001F7Br 2  85 DF              STA   IrqBase           ; save enabled flag
001F7Dr 2  4C rr rr           JMP   LAB_16E8          ; go do rest of RETURN
001F80r 2               
001F80r 2               ; return from NMI service, restores the enabled flag.
001F80r 2               
001F80r 2               ; perform RETNMI
001F80r 2               
001F80r 2               LAB_RETNMI
001F80r 2  D0 F1              BNE   LAB_IRTS          ; exit if following token (to allow syntax error)
001F82r 2               
001F82r 2  A5 DC              LDA   NmiBase           ; get set-up flag
001F84r 2  0A                 ASL                     ; copy setup to enabled (b7)
001F85r 2  05 DC              ORA   NmiBase           ; OR in setup flag
001F87r 2  85 DC              STA   NmiBase           ; save enabled flag
001F89r 2  4C rr rr           JMP   LAB_16E8          ; go do rest of RETURN
001F8Cr 2               
001F8Cr 2               ; MAX() MIN() pre process
001F8Cr 2               
001F8Cr 2               LAB_MMPP
001F8Cr 2  20 rr rr           JSR   LAB_EVEZ          ; process expression
001F8Fr 2  4C rr rr           JMP   LAB_CTNM          ; check if source is numeric, else do type mismatch
001F92r 2               
001F92r 2               ; perform MAX()
001F92r 2               
001F92r 2               LAB_MAX
001F92r 2  20 rr rr           JSR   LAB_PHFA          ; push FAC1, evaluate expression,
001F95r 2                                             ; pull FAC2 and compare with FAC1
001F95r 2  10 FB              BPL   LAB_MAX           ; branch if no swap to do
001F97r 2               
001F97r 2  A5 B4              LDA   FAC2_1            ; get FAC2 mantissa1
001F99r 2  09 80              ORA   #$80              ; set top bit (clear sign from compare)
001F9Br 2  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
001F9Dr 2  20 rr rr           JSR   LAB_279B          ; copy FAC2 to FAC1
001FA0r 2  F0 F0              BEQ   LAB_MAX           ; go do next (branch always)
001FA2r 2               
001FA2r 2               ; perform MIN()
001FA2r 2               
001FA2r 2               LAB_MIN
001FA2r 2  20 rr rr           JSR   LAB_PHFA          ; push FAC1, evaluate expression,
001FA5r 2                                             ; pull FAC2 and compare with FAC1
001FA5r 2  30 FB              BMI   LAB_MIN           ; branch if no swap to do
001FA7r 2               
001FA7r 2  F0 F9              BEQ   LAB_MIN           ; branch if no swap to do
001FA9r 2               
001FA9r 2  A5 B4              LDA   FAC2_1            ; get FAC2 mantissa1
001FABr 2  09 80              ORA   #$80              ; set top bit (clear sign from compare)
001FADr 2  85 B4              STA   FAC2_1            ; save FAC2 mantissa1
001FAFr 2  20 rr rr           JSR   LAB_279B          ; copy FAC2 to FAC1
001FB2r 2  F0 EE              BEQ   LAB_MIN           ; go do next (branch always)
001FB4r 2               
001FB4r 2               ; exit routine. don't bother returning to the loop code
001FB4r 2               ; check for correct exit, else so syntax error
001FB4r 2               
001FB4r 2               LAB_MMEC
001FB4r 2  C9 29              CMP   #')'              ; is it end of function?
001FB6r 2  D0 05              BNE   LAB_MMSE          ; if not do MAX MIN syntax error
001FB8r 2               
001FB8r 2  68                 PLA                     ; dump return address low byte
001FB9r 2  68                 PLA                     ; dump return address high byte
001FBAr 2  4C BC 00           JMP   LAB_IGBY          ; update BASIC execute pointer (to chr past ")")
001FBDr 2               
001FBDr 2               LAB_MMSE
001FBDr 2  4C rr rr           JMP   LAB_SNER          ; do syntax error then warm start
001FC0r 2               
001FC0r 2               ; check for next, evaluate and return or exit
001FC0r 2               ; this is the routine that does most of the work
001FC0r 2               
001FC0r 2               LAB_PHFA
001FC0r 2  20 C2 00           JSR   LAB_GBYT          ; get next BASIC byte
001FC3r 2  C9 2C              CMP   #','              ; is there more ?
001FC5r 2  D0 ED              BNE   LAB_MMEC          ; if not go do end check
001FC7r 2               
001FC7r 2                                             ; push FAC1
001FC7r 2  20 rr rr           JSR   LAB_27BA          ; round FAC1
001FCAr 2  A5 B0              LDA   FAC1_s            ; get FAC1 sign
001FCCr 2  09 7F              ORA   #$7F              ; set all non sign bits
001FCEr 2  25 AD              AND   FAC1_1            ; AND FAC1 mantissa1 (AND in sign bit)
001FD0r 2  48                 PHA                     ; push on stack
001FD1r 2  A5 AE              LDA   FAC1_2            ; get FAC1 mantissa2
001FD3r 2  48                 PHA                     ; push on stack
001FD4r 2  A5 AF              LDA   FAC1_3            ; get FAC1 mantissa3
001FD6r 2  48                 PHA                     ; push on stack
001FD7r 2  A5 AC              LDA   FAC1_e            ; get FAC1 exponent
001FD9r 2  48                 PHA                     ; push on stack
001FDAr 2               
001FDAr 2  20 BC 00           JSR   LAB_IGBY          ; scan and get next BASIC byte (after ",")
001FDDr 2  20 rr rr           JSR   LAB_EVNM          ; evaluate expression and check is numeric,
001FE0r 2                                             ; else do type mismatch
001FE0r 2               
001FE0r 2                                             ; pop FAC2 (MAX/MIN expression so far)
001FE0r 2  68                 PLA                     ; pop exponent
001FE1r 2  85 B3              STA   FAC2_e            ; save FAC2 exponent
001FE3r 2  68                 PLA                     ; pop mantissa3
001FE4r 2  85 B6              STA   FAC2_3            ; save FAC2 mantissa3
001FE6r 2  68                 PLA                     ; pop mantissa1
001FE7r 2  85 B5              STA   FAC2_2            ; save FAC2 mantissa2
001FE9r 2  68                 PLA                     ; pop sign/mantissa1
001FEAr 2  85 B4              STA   FAC2_1            ; save FAC2 sign/mantissa1
001FECr 2  85 B7              STA   FAC2_s            ; save FAC2 sign
001FEEr 2               
001FEEr 2                                             ; compare FAC1 with (packed) FAC2
001FEEr 2  A9 B3              LDA   #<FAC2_e          ; set pointer low byte to FAC2
001FF0r 2  A0 00              LDY   #>FAC2_e          ; set pointer high byte to FAC2
001FF2r 2  4C rr rr           JMP   LAB_27F8          ; compare FAC1 with FAC2 (AY) and return
001FF5r 2                                             ; returns A=$00 if FAC1 = (AY)
001FF5r 2                                             ; returns A=$01 if FAC1 > (AY)
001FF5r 2                                             ; returns A=$FF if FAC1 < (AY)
001FF5r 2               
001FF5r 2               ; perform WIDTH
001FF5r 2               
001FF5r 2               LAB_WDTH
001FF5r 2  C9 2C              CMP   #','              ; is next byte ","
001FF7r 2  F0 1B              BEQ   LAB_TBSZ          ; if so do tab size
001FF9r 2               
001FF9r 2  20 rr rr           JSR   LAB_GTBY          ; get byte parameter
001FFCr 2  8A                 TXA                     ; copy width to A
001FFDr 2  F0 0A              BEQ   LAB_NSTT          ; branch if set for infinite line
001FFFr 2               
001FFFr 2  E0 10              CPX   #$10              ; else make min width = 16d
002001r 2  90 45              BCC   TabErr            ; if less do function call error and exit
002003r 2               
002003r 2               ; this next compare ensures that we can't exit WIDTH via an error leaving the
002003r 2               ; tab size greater than the line length.
002003r 2               
002003r 2  E4 64              CPX   TabSiz            ; compare with tab size
002005r 2  B0 02              BCS   LAB_NSTT          ; branch if >= tab size
002007r 2               
002007r 2  86 64              STX   TabSiz            ; else make tab size = terminal width
002009r 2               LAB_NSTT
002009r 2  86 0F              STX   TWidth            ; set the terminal width
00200Br 2  20 C2 00           JSR   LAB_GBYT          ; get BASIC byte back
00200Er 2  F0 1A              BEQ   WExit             ; exit if no following
002010r 2               
002010r 2  C9 2C              CMP   #','              ; else is it ","
002012r 2  D0 A9              BNE   LAB_MMSE          ; if not do syntax error
002014r 2               
002014r 2               LAB_TBSZ
002014r 2  20 rr rr           JSR   LAB_SGBY          ; scan and get byte parameter
002017r 2  8A                 TXA                     ; copy TAB size
002018r 2  30 2E              BMI   TabErr            ; if >127 do function call error and exit
00201Ar 2               
00201Ar 2  E0 01              CPX   #$01              ; compare with min-1
00201Cr 2  90 2A              BCC   TabErr            ; if <=1 do function call error and exit
00201Er 2               
00201Er 2  A5 0F              LDA   TWidth            ; set flags for width
002020r 2  F0 06              BEQ   LAB_SVTB          ; skip check if infinite line
002022r 2               
002022r 2  E4 0F              CPX   TWidth            ; compare TAB with width
002024r 2  F0 02              BEQ   LAB_SVTB          ; ok if =
002026r 2               
002026r 2  B0 20              BCS   TabErr            ; branch if too big
002028r 2               
002028r 2               LAB_SVTB
002028r 2  86 64              STX   TabSiz            ; save TAB size
00202Ar 2               
00202Ar 2               ; calculate tab column limit from TAB size. The Iclim is set to the last tab
00202Ar 2               ; position on a line that still has at least one whole tab width between it
00202Ar 2               ; and the end of the line.
00202Ar 2               
00202Ar 2               WExit
00202Ar 2  A5 0F              LDA   TWidth            ; get width
00202Cr 2  F0 06              BEQ   LAB_SULP          ; branch if infinite line
00202Er 2               
00202Er 2  C5 64              CMP   TabSiz            ; compare with tab size
002030r 2  B0 03              BCS   LAB_WDLP          ; branch if >= tab size
002032r 2               
002032r 2  85 64              STA   TabSiz            ; else make tab size = terminal width
002034r 2               LAB_SULP
002034r 2  38                 SEC                     ; set carry for subtract
002035r 2               LAB_WDLP
002035r 2  E5 64              SBC   TabSiz            ; subtract tab size
002037r 2  B0 FC              BCS   LAB_WDLP          ; loop while no borrow
002039r 2               
002039r 2  65 64              ADC   TabSiz            ; add tab size back
00203Br 2  18                 CLC                     ; clear carry for add
00203Cr 2  65 64              ADC   TabSiz            ; add tab size back again
00203Er 2  85 10              STA   Iclim             ; save for now
002040r 2  A5 0F              LDA   TWidth            ; get width back
002042r 2  38                 SEC                     ; set carry for subtract
002043r 2  E5 10              SBC   Iclim             ; subtract remainder
002045r 2  85 10              STA   Iclim             ; save tab column limit
002047r 2               LAB_NOSQ
002047r 2  60                 RTS
002048r 2               
002048r 2               TabErr
002048r 2  4C rr rr           JMP   LAB_FCER          ; do function call error then warm start
00204Br 2               
00204Br 2               ; perform SQR()
00204Br 2               
00204Br 2               LAB_SQR
00204Br 2  A5 B0              LDA   FAC1_s            ; get FAC1 sign
00204Dr 2  30 F9              BMI   TabErr            ; if -ve do function call error
00204Fr 2               
00204Fr 2  A5 AC              LDA   FAC1_e            ; get exponent
002051r 2  F0 F4              BEQ   LAB_NOSQ          ; if zero just return
002053r 2               
002053r 2                                             ; else do root
002053r 2  20 rr rr           JSR   LAB_27AB          ; round and copy FAC1 to FAC2
002056r 2  A9 00              LDA   #$00              ; clear A
002058r 2               
002058r 2  85 77              STA   FACt_3            ; clear remainder
00205Ar 2  85 76              STA   FACt_2            ; ..
00205Cr 2  85 75              STA   FACt_1            ; ..
00205Er 2  85 78              STA   TempB             ; ..
002060r 2               
002060r 2  85 AF              STA   FAC1_3            ; clear root
002062r 2  85 AE              STA   FAC1_2            ; ..
002064r 2  85 AD              STA   FAC1_1            ; ..
002066r 2               
002066r 2  A2 18              LDX   #$18              ; 24 pairs of bits to do
002068r 2  A5 B3              LDA   FAC2_e            ; get exponent
00206Ar 2  4A                 LSR                     ; check odd/even
00206Br 2  B0 0E              BCS   LAB_SQE2          ; if odd only 1 shift first time
00206Dr 2               
00206Dr 2               LAB_SQE1
00206Dr 2  06 B6              ASL   FAC2_3            ; shift highest bit of number ..
00206Fr 2  26 B5              ROL   FAC2_2            ; ..
002071r 2  26 B4              ROL   FAC2_1            ; ..
002073r 2  26 77              ROL   FACt_3            ; .. into remainder
002075r 2  26 76              ROL   FACt_2            ; ..
002077r 2  26 75              ROL   FACt_1            ; ..
002079r 2  26 78              ROL   TempB             ; .. never overflows
00207Br 2               LAB_SQE2
00207Br 2  06 B6              ASL   FAC2_3            ; shift highest bit of number ..
00207Dr 2  26 B5              ROL   FAC2_2            ; ..
00207Fr 2  26 B4              ROL   FAC2_1            ; ..
002081r 2  26 77              ROL   FACt_3            ; .. into remainder
002083r 2  26 76              ROL   FACt_2            ; ..
002085r 2  26 75              ROL   FACt_1            ; ..
002087r 2  26 78              ROL   TempB             ; .. never overflows
002089r 2               
002089r 2  06 AF              ASL   FAC1_3            ; root = root * 2
00208Br 2  26 AE              ROL   FAC1_2            ; ..
00208Dr 2  26 AD              ROL   FAC1_1            ; .. never overflows
00208Fr 2               
00208Fr 2  A5 AF              LDA   FAC1_3            ; get root low byte
002091r 2  2A                 ROL                     ; *2
002092r 2  85 5B              STA   Temp3             ; save partial low byte
002094r 2  A5 AE              LDA   FAC1_2            ; get root low mid byte
002096r 2  2A                 ROL                     ; *2
002097r 2  85 5C              STA   Temp3+1           ; save partial low mid byte
002099r 2  A5 AD              LDA   FAC1_1            ; get root high mid byte
00209Br 2  2A                 ROL                     ; *2
00209Cr 2  85 5D              STA   Temp3+2           ; save partial high mid byte
00209Er 2  A9 00              LDA   #$00              ; get root high byte (always $00)
0020A0r 2  2A                 ROL                     ; *2
0020A1r 2  85 5E              STA   Temp3+3           ; save partial high byte
0020A3r 2               
0020A3r 2                                             ; carry clear for subtract +1
0020A3r 2  A5 77              LDA   FACt_3            ; get remainder low byte
0020A5r 2  E5 5B              SBC   Temp3             ; subtract partial low byte
0020A7r 2  85 5B              STA   Temp3             ; save partial low byte
0020A9r 2               
0020A9r 2  A5 76              LDA   FACt_2            ; get remainder low mid byte
0020ABr 2  E5 5C              SBC   Temp3+1           ; subtract partial low mid byte
0020ADr 2  85 5C              STA   Temp3+1           ; save partial low mid byte
0020AFr 2               
0020AFr 2  A5 75              LDA   FACt_1            ; get remainder high mid byte
0020B1r 2  E5 5D              SBC   Temp3+2           ; subtract partial high mid byte
0020B3r 2  A8                 TAY                     ; copy partial high mid byte
0020B4r 2               
0020B4r 2  A5 78              LDA   TempB             ; get remainder high byte
0020B6r 2  E5 5E              SBC   Temp3+3           ; subtract partial high byte
0020B8r 2  90 0E              BCC   LAB_SQNS          ; skip sub if remainder smaller
0020BAr 2               
0020BAr 2  85 78              STA   TempB             ; save remainder high byte
0020BCr 2               
0020BCr 2  84 75              STY   FACt_1            ; save remainder high mid byte
0020BEr 2               
0020BEr 2  A5 5C              LDA   Temp3+1           ; get remainder low mid byte
0020C0r 2  85 76              STA   FACt_2            ; save remainder low mid byte
0020C2r 2               
0020C2r 2  A5 5B              LDA   Temp3             ; get partial low byte
0020C4r 2  85 77              STA   FACt_3            ; save remainder low byte
0020C6r 2               
0020C6r 2  E6 AF              INC   FAC1_3            ; increment root low byte (never any rollover)
0020C8r 2               LAB_SQNS
0020C8r 2  CA                 DEX                     ; decrement bit pair count
0020C9r 2  D0 A2              BNE   LAB_SQE1          ; loop if not all done
0020CBr 2               
0020CBr 2  38                 SEC                     ; set carry for subtract
0020CCr 2  A5 B3              LDA   FAC2_e            ; get exponent
0020CEr 2  E9 80              SBC   #$80              ; normalise
0020D0r 2  6A                 ROR                     ; /2 and re-bias to $80
0020D1r 2  69 00              ADC   #$00              ; add bit zero back in (allow for half shift)
0020D3r 2  85 AC              STA   FAC1_e            ; save it
0020D5r 2  4C rr rr           JMP   LAB_24D5          ; normalise FAC1 and return
0020D8r 2               
0020D8r 2               ; perform VARPTR()
0020D8r 2               
0020D8r 2               LAB_VARPTR
0020D8r 2  20 BC 00           JSR   LAB_IGBY          ; increment and scan memory
0020DBr 2  20 rr rr           JSR   LAB_GVAR          ; get var address
0020DEr 2  20 rr rr           JSR   LAB_1BFB          ; scan for ")" , else do syntax error then warm start
0020E1r 2  A4 95              LDY   Cvaral            ; get var address low byte
0020E3r 2  A5 96              LDA   Cvarah            ; get var address high byte
0020E5r 2  4C rr rr           JMP   LAB_AYFC          ; save and convert integer AY to FAC1 and return
0020E8r 2               
0020E8r 2               ; perform PI
0020E8r 2               
0020E8r 2               LAB_PI
0020E8r 2  A9 rr              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
0020EAr 2  A0 rr              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
0020ECr 2  20 rr rr           JSR   LAB_UFAC          ; unpack memory (AY) into FAC1
0020EFr 2  C6 AC              DEC   FAC1_e            ; make result = PI
0020F1r 2  60                 RTS
0020F2r 2               
0020F2r 2               ; perform TWOPI
0020F2r 2               
0020F2r 2               LAB_TWOPI
0020F2r 2  A9 rr              LDA   #<LAB_2C7C        ; set (2*pi) pointer low byte
0020F4r 2  A0 rr              LDY   #>LAB_2C7C        ; set (2*pi) pointer high byte
0020F6r 2  4C rr rr           JMP   LAB_UFAC          ; unpack memory (AY) into FAC1 and return
0020F9r 2               
0020F9r 2               ; system dependant i/o vectors
0020F9r 2               ; these are in RAM and are set by the monitor at start-up
0020F9r 2               
0020F9r 2               V_INPT
0020F9r 2  6C 05 02           JMP   (VEC_IN)          ; non halting scan input device
0020FCr 2               V_OUTP
0020FCr 2  6C 07 02           JMP   (VEC_OUT)         ; send byte to output device
0020FFr 2               V_LOAD
0020FFr 2  6C 09 02           JMP   (VEC_LD)          ; load BASIC program
002102r 2               V_SAVE
002102r 2  6C 0B 02           JMP   (VEC_SV)          ; save BASIC program
002105r 2               
002105r 2               ; The rest are tables messages and code for RAM
002105r 2               
002105r 2               ; the rest of the code is tables and BASIC start-up code
002105r 2               
002105r 2               PG2_TABS
002105r 2  00                 .byte $00               ; ctrl-c flag           -     $00 = enabled
002106r 2  00                 .byte $00               ; ctrl-c byte           -     GET needs this
002107r 2  00                 .byte $00               ; ctrl-c byte timeout   -     GET needs this
002108r 2  rr rr              .word CTRLC             ; ctrl c check vector
00210Ar 2               ;     .word xxxx              ; non halting key input -     monitor to set this
00210Ar 2               ;     .word xxxx              ; output vector         -     monitor to set this
00210Ar 2               ;     .word xxxx              ; load vector           -     monitor to set this
00210Ar 2               ;     .word xxxx              ; save vector           -     monitor to set this
00210Ar 2               PG2_TABE
00210Ar 2               
00210Ar 2               ; character get subroutine for zero page
00210Ar 2               
00210Ar 2               ; For a 1.8432MHz 6502 including the JSR and RTS
00210Ar 2               ; fastest (>=":") =  29 cycles =  15.7uS
00210Ar 2               ; slowest (<":")  =  40 cycles =  21.7uS
00210Ar 2               ; space skip      = +21 cycles = +11.4uS
00210Ar 2               ; inc across page =  +4 cycles =  +2.2uS
00210Ar 2               
00210Ar 2               ; the target address for the LDA at LAB_2CF4 becomes the BASIC execute pointer once the
00210Ar 2               ; block is copied to it's destination, any non zero page address will do at assembly
00210Ar 2               ; time, to assemble a three byte instruction.
00210Ar 2               
00210Ar 2               ; page 0 initialisation table from $BC
00210Ar 2               ; increment and scan memory
00210Ar 2               
00210Ar 2               LAB_2CEE
00210Ar 2  E6 C3              INC   Bpntrl            ; increment BASIC execute pointer low byte
00210Cr 2  D0 02              BNE   LAB_2CF4          ; branch if no carry
00210Er 2                                             ; else
00210Er 2  E6 C4              INC   Bpntrh            ; increment BASIC execute pointer high byte
002110r 2               
002110r 2               ; page 0 initialisation table from $C2
002110r 2               ; scan memory
002110r 2               
002110r 2               LAB_2CF4
002110r 2  AD FF FF           LDA   $FFFF             ; get byte to scan (addr set by call routine)
002113r 2  C9 AC              CMP   #TK_ELSE          ; compare with the token for ELSE
002115r 2  F0 0E              BEQ   LAB_2D05          ; exit if ELSE, not numeric, carry set
002117r 2               
002117r 2  C9 3A              CMP   #':'              ; compare with ":"
002119r 2  B0 0A              BCS   LAB_2D05          ; exit if >= ":", not numeric, carry set
00211Br 2               
00211Br 2  C9 20              CMP   #' '              ; compare with " "
00211Dr 2  F0 EB              BEQ   LAB_2CEE          ; if " " go do next
00211Fr 2               
00211Fr 2  38                 SEC                     ; set carry for SBC
002120r 2  E9 30              SBC   #'0'              ; subtract "0"
002122r 2  38                 SEC                     ; set carry for SBC
002123r 2  E9 D0              SBC   #$D0              ; subtract -"0"
002125r 2                                             ; clear carry if byte = "0"-"9"
002125r 2               LAB_2D05
002125r 2  60                 RTS
002126r 2               
002126r 2               ; page zero initialisation table $00-$12 inclusive
002126r 2               
002126r 2               StrTab
002126r 2  4C                 .byte $4C               ; JMP opcode
002127r 2  rr rr              .word LAB_COLD          ; initial warm start vector (cold start)
002129r 2               
002129r 2  00                 .byte $00               ; these bytes are not used by BASIC
00212Ar 2  00 00              .word $0000             ;
00212Cr 2  00 00              .word $0000             ;
00212Er 2  00 00              .word $0000             ;
002130r 2               
002130r 2  4C                 .byte $4C               ; JMP opcode
002131r 2  rr rr              .word LAB_FCER          ; initial user function vector ("Function call" error)
002133r 2  00                 .byte $00               ; default NULL count
002134r 2  00                 .byte $00               ; clear terminal position
002135r 2  00                 .byte $00               ; default terminal width byte
002136r 2  F2                 .byte $F2               ; default limit for TAB = 14
002137r 2  00 03              .word Ram_base          ; start of user RAM
002139r 2               EndTab
002139r 2               
002139r 2               LAB_MSZM
002139r 2  0D 0A 4D 65        .byte $0D,$0A,"Memory size ",$00
00213Dr 2  6D 6F 72 79  
002141r 2  20 73 69 7A  
002148r 2               
002148r 2               LAB_SMSG
002148r 2  20 42 79 74        .byte " Bytes free",$0D,$0A,$0A
00214Cr 2  65 73 20 66  
002150r 2  72 65 65 0D  
002156r 2  45 6E 68 61        .byte "Enhanced BASIC 2.22p5",$0A,$00
00215Ar 2  6E 63 65 64  
00215Er 2  20 42 41 53  
00216Dr 2               
00216Dr 2               ; numeric constants and series
00216Dr 2               
00216Dr 2                                             ; constants and series for LOG(n)
00216Dr 2               LAB_25A0
00216Dr 2  02                 .byte $02               ; counter
00216Er 2  80 19 56 62        .byte $80,$19,$56,$62   ; 0.59898
002172r 2  80 76 22 F3        .byte $80,$76,$22,$F3   ; 0.96147
002176r 2               ;##   .byte $80,$76,$22,$F1   ; 0.96147
002176r 2  82 38 AA 40        .byte $82,$38,$AA,$40   ; 2.88539
00217Ar 2               ;##   .byte $82,$38,$AA,$45   ; 2.88539
00217Ar 2               
00217Ar 2               LAB_25AD
00217Ar 2  80 35 04 F3        .byte $80,$35,$04,$F3   ; 0.70711   1/root 2
00217Er 2               LAB_25B1
00217Er 2  81 35 04 F3        .byte $81,$35,$04,$F3   ; 1.41421   root 2
002182r 2               LAB_25B5
002182r 2  80 80 00 00        .byte $80,$80,$00,$00   ; -0.5
002186r 2               LAB_25B9
002186r 2  80 31 72 18        .byte $80,$31,$72,$18   ; 0.69315   LOG(2)
00218Ar 2               
00218Ar 2                                             ; numeric PRINT constants
00218Ar 2               LAB_2947
00218Ar 2  91 43 4F F8        .byte $91,$43,$4F,$F8   ; 99999.9375 (max value with at least one decimal)
00218Er 2               LAB_294B
00218Er 2  94 74 23 F7        .byte $94,$74,$23,$F7   ; 999999.4375 (max value before scientific notation)
002192r 2               LAB_294F
002192r 2  94 74 24 00        .byte $94,$74,$24,$00   ; 1000000
002196r 2               
002196r 2                                             ; EXP(n) constants and series
002196r 2               LAB_2AFA
002196r 2  81 38 AA 3B        .byte $81,$38,$AA,$3B   ; 1.4427    (1/LOG base 2 e)
00219Ar 2               LAB_2AFE
00219Ar 2  06                 .byte $06               ; counter
00219Br 2  74 63 90 8C        .byte $74,$63,$90,$8C   ; 2.17023e-4
00219Fr 2  77 23 0C AB        .byte $77,$23,$0C,$AB   ; 0.00124
0021A3r 2  7A 1E 94 00        .byte $7A,$1E,$94,$00   ; 0.00968
0021A7r 2  7C 63 42 80        .byte $7C,$63,$42,$80   ; 0.05548
0021ABr 2  7E 75 FE D0        .byte $7E,$75,$FE,$D0   ; 0.24023
0021AFr 2  80 31 72 15        .byte $80,$31,$72,$15   ; 0.69315
0021B3r 2  81 00 00 00        .byte $81,$00,$00,$00   ; 1.00000
0021B7r 2               
0021B7r 2               ;##   .byte $07               ; counter
0021B7r 2               ;##   .byte $74,$94,$2E,$40   ; -1/7! (-1/5040)
0021B7r 2               ;##   .byte $77,$2E,$4F,$70   ;  1/6! ( 1/720)
0021B7r 2               ;##   .byte $7A,$88,$02,$6E   ; -1/5! (-1/120)
0021B7r 2               ;##   .byte $7C,$2A,$A0,$E6   ;  1/4! ( 1/24)
0021B7r 2               ;##   .byte $7E,$AA,$AA,$50   ; -1/3! (-1/6)
0021B7r 2               ;##   .byte $7F,$7F,$FF,$FF   ;  1/2! ( 1/2)
0021B7r 2               ;##   .byte $81,$80,$00,$00   ; -1/1! (-1/1)
0021B7r 2               ;##   .byte $81,$00,$00,$00   ;  1/0! ( 1/1)
0021B7r 2               
0021B7r 2                                             ; trigonometric constants and series
0021B7r 2               LAB_2C78
0021B7r 2  81 49 0F DB        .byte $81,$49,$0F,$DB   ; 1.570796371 (pi/2) as floating #
0021BBr 2               LAB_2C84
0021BBr 2  04                 .byte $04               ; counter
0021BCr 2  86 1E D7 FB        .byte $86,$1E,$D7,$FB   ; 39.7109
0021C0r 2               ;##   .byte $86,$1E,$D7,$BA   ; 39.7109
0021C0r 2  87 99 26 65        .byte $87,$99,$26,$65   ;-76.575
0021C4r 2               ;##   .byte $87,$99,$26,$64   ;-76.575
0021C4r 2  87 23 34 58        .byte $87,$23,$34,$58   ; 81.6022
0021C8r 2  86 A5 5D E1        .byte $86,$A5,$5D,$E1   ;-41.3417
0021CCr 2               ;##   .byte $86,$A5,$5D,$E0   ;-41.3417
0021CCr 2               LAB_2C7C
0021CCr 2  83 49 0F DB        .byte $83,$49,$0F,$DB   ; 6.28319 (2*pi) as floating #
0021D0r 2               ;##   .byte $83,$49,$0F,$DA   ; 6.28319 (2*pi) as floating #
0021D0r 2               
0021D0r 2               LAB_2CC9
0021D0r 2  08                 .byte $08               ; counter
0021D1r 2  78 3A C5 37        .byte $78,$3A,$C5,$37   ; 0.00285
0021D5r 2  7B 83 A2 5C        .byte $7B,$83,$A2,$5C   ;-0.0160686
0021D9r 2  7C 2E DD 4D        .byte $7C,$2E,$DD,$4D   ; 0.0426915
0021DDr 2  7D 99 B0 1E        .byte $7D,$99,$B0,$1E   ;-0.0750429
0021E1r 2  7D 59 ED 24        .byte $7D,$59,$ED,$24   ; 0.106409
0021E5r 2  7E 91 72 00        .byte $7E,$91,$72,$00   ;-0.142036
0021E9r 2  7E 4C B9 73        .byte $7E,$4C,$B9,$73   ; 0.199926
0021EDr 2  7F AA AA 53        .byte $7F,$AA,$AA,$53   ;-0.333331
0021F1r 2               
0021F1r 2               ;##   .byte $08               ; counter
0021F1r 2               ;##   .byte $78,$3B,$D7,$4A   ; 1/17
0021F1r 2               ;##   .byte $7B,$84,$6E,$02   ;-1/15
0021F1r 2               ;##   .byte $7C,$2F,$C1,$FE   ; 1/13
0021F1r 2               ;##   .byte $7D,$9A,$31,$74   ;-1/11
0021F1r 2               ;##   .byte $7D,$5A,$3D,$84   ; 1/9
0021F1r 2               ;##   .byte $7E,$91,$7F,$C8   ;-1/7
0021F1r 2               ;##   .byte $7E,$4C,$BB,$E4   ; 1/5
0021F1r 2               ;##   .byte $7F,$AA,$AA,$6C   ;-1/3
0021F1r 2               
0021F1r 2               LAB_1D96    = *+1             ; $00,$00 used for undefined variables
0021F1r 2               LAB_259C
0021F1r 2  81 00 00 00        .byte $81,$00,$00,$00   ; 1.000000, used for INC
0021F5r 2               LAB_2AFD
0021F5r 2  81 80 00 00        .byte $81,$80,$00,$00   ; -1.00000, used for DEC. must be on the same page as +1.00
0021F9r 2               
0021F9r 2                                             ; misc constants
0021F9r 2               LAB_1DF7
0021F9r 2  90                 .byte $90               ;-32768 (uses first three bytes from 0.5)
0021FAr 2               LAB_2A96
0021FAr 2  80 00 00 00        .byte $80,$00,$00,$00   ; 0.5
0021FEr 2               LAB_2C80
0021FEr 2  7F 00 00 00        .byte $7F,$00,$00,$00   ; 0.25
002202r 2               LAB_26B5
002202r 2  84 20 00 00        .byte $84,$20,$00,$00   ; 10.0000 divide by 10 constant
002206r 2               
002206r 2               ; This table is used in converting numbers to ASCII.
002206r 2               
002206r 2               LAB_2A9A
002206r 2               LAB_2A9B = LAB_2A9A+1
002206r 2               LAB_2A9C = LAB_2A9B+1
002206r 2  FE 79 60           .byte $FE,$79,$60       ; -100000
002209r 2  00 27 10           .byte $00,$27,$10       ; 10000
00220Cr 2  FF FC 18           .byte $FF,$FC,$18       ; -1000
00220Fr 2  00 00 64           .byte $00,$00,$64       ; 100
002212r 2  FF FF F6           .byte $FF,$FF,$F6       ; -10
002215r 2  00 00 01           .byte $00,$00,$01       ; 1
002218r 2               
002218r 2               LAB_CTBL
002218r 2  rr rr              .word LAB_END-1         ; END
00221Ar 2  rr rr              .word LAB_FOR-1         ; FOR
00221Cr 2  rr rr              .word LAB_NEXT-1        ; NEXT
00221Er 2  rr rr              .word LAB_DATA-1        ; DATA
002220r 2  rr rr              .word LAB_INPUT-1       ; INPUT
002222r 2  rr rr              .word LAB_DIM-1         ; DIM
002224r 2  rr rr              .word LAB_READ-1        ; READ
002226r 2  rr rr              .word LAB_LET-1         ; LET
002228r 2  rr rr              .word LAB_DEC-1         ; DEC             new command
00222Ar 2  rr rr              .word LAB_GOTO-1        ; GOTO
00222Cr 2  rr rr              .word LAB_RUN-1         ; RUN
00222Er 2  rr rr              .word LAB_IF-1          ; IF
002230r 2  rr rr              .word LAB_RESTORE-1     ; RESTORE         modified command
002232r 2  rr rr              .word LAB_GOSUB-1       ; GOSUB
002234r 2  rr rr              .word LAB_RETIRQ-1      ; RETIRQ          new command
002236r 2  rr rr              .word LAB_RETNMI-1      ; RETNMI          new command
002238r 2  rr rr              .word LAB_RETURN-1      ; RETURN
00223Ar 2  rr rr              .word LAB_REM-1         ; REM
00223Cr 2  rr rr              .word LAB_STOP-1        ; STOP
00223Er 2  rr rr              .word LAB_ON-1          ; ON              modified command
002240r 2  rr rr              .word LAB_NULL-1        ; NULL            modified command
002242r 2  rr rr              .word LAB_INC-1         ; INC             new command
002244r 2  rr rr              .word LAB_WAIT-1        ; WAIT
002246r 2  rr rr              .word V_LOAD-1          ; LOAD
002248r 2  rr rr              .word V_SAVE-1          ; SAVE
00224Ar 2  rr rr              .word LAB_DEF-1         ; DEF
00224Cr 2  rr rr              .word LAB_POKE-1        ; POKE
00224Er 2  rr rr              .word LAB_DOKE-1        ; DOKE            new command
002250r 2  rr rr              .word LAB_CALL-1        ; CALL            new command
002252r 2  rr rr              .word LAB_DO-1          ; DO              new command
002254r 2  rr rr              .word LAB_LOOP-1        ; LOOP            new command
002256r 2  rr rr              .word LAB_PRINT-1       ; PRINT
002258r 2  rr rr              .word LAB_CONT-1        ; CONT
00225Ar 2  rr rr              .word LAB_LIST-1        ; LIST
00225Cr 2  rr rr              .word LAB_CLEAR-1       ; CLEAR
00225Er 2  rr rr              .word LAB_NEW-1         ; NEW
002260r 2  rr rr              .word LAB_WDTH-1        ; WIDTH           new command
002262r 2  rr rr              .word LAB_GET-1         ; GET             new command
002264r 2  rr rr              .word LAB_SWAP-1        ; SWAP            new command
002266r 2  rr rr              .word LAB_BITSET-1      ; BITSET          new command
002268r 2  rr rr              .word LAB_BITCLR-1      ; BITCLR          new command
00226Ar 2  rr rr              .word LAB_IRQ-1         ; IRQ             new command
00226Cr 2  rr rr              .word LAB_NMI-1         ; NMI             new command
00226Er 2               
00226Er 2               ; function pre process routine table
00226Er 2               
00226Er 2               LAB_FTPL
00226Er 2               LAB_FTPM    = LAB_FTPL+$01
00226Er 2  rr rr              .word LAB_PPFN-1        ; SGN(n)    process numeric expression in ()
002270r 2  rr rr              .word LAB_PPFN-1        ; INT(n)          "
002272r 2  rr rr              .word LAB_PPFN-1        ; ABS(n)          "
002274r 2  rr rr              .word LAB_EVEZ-1        ; USR(x)    process any expression
002276r 2  rr rr              .word LAB_1BF7-1        ; FRE(x)          "
002278r 2  rr rr              .word LAB_1BF7-1        ; POS(x)          "
00227Ar 2  rr rr              .word LAB_PPFN-1        ; SQR(n)    process numeric expression in ()
00227Cr 2  rr rr              .word LAB_PPFN-1        ; RND(n)          "
00227Er 2  rr rr              .word LAB_PPFN-1        ; LOG(n)          "
002280r 2  rr rr              .word LAB_PPFN-1        ; EXP(n)          "
002282r 2  rr rr              .word LAB_PPFN-1        ; COS(n)          "
002284r 2  rr rr              .word LAB_PPFN-1        ; SIN(n)          "
002286r 2  rr rr              .word LAB_PPFN-1        ; TAN(n)          "
002288r 2  rr rr              .word LAB_PPFN-1        ; ATN(n)          "
00228Ar 2  rr rr              .word LAB_PPFN-1        ; PEEK(n)         "
00228Cr 2  rr rr              .word LAB_PPFN-1        ; DEEK(n)         "
00228Er 2  00 00              .word $0000             ; SADD()    none
002290r 2  rr rr              .word LAB_PPFS-1        ; LEN($)    process string expression in ()
002292r 2  rr rr              .word LAB_PPFN-1        ; STR$(n)   process numeric expression in ()
002294r 2  rr rr              .word LAB_PPFS-1        ; VAL($)    process string expression in ()
002296r 2  rr rr              .word LAB_PPFS-1        ; ASC($)          "
002298r 2  rr rr              .word LAB_PPFS-1        ; UCASE$($)       "
00229Ar 2  rr rr              .word LAB_PPFS-1        ; LCASE$($)       "
00229Cr 2  rr rr              .word LAB_PPFN-1        ; CHR$(n)   process numeric expression in ()
00229Er 2  rr rr              .word LAB_BHSS-1        ; HEX$(n)         "
0022A0r 2  rr rr              .word LAB_BHSS-1        ; BIN$(n)         "
0022A2r 2  00 00              .word $0000             ; BITTST()  none
0022A4r 2  rr rr              .word LAB_MMPP-1        ; MAX()     process numeric expression
0022A6r 2  rr rr              .word LAB_MMPP-1        ; MIN()           "
0022A8r 2  rr rr              .word LAB_PPBI-1        ; PI        advance pointer
0022AAr 2  rr rr              .word LAB_PPBI-1        ; TWOPI           "
0022ACr 2  00 00              .word $0000             ; VARPTR()  none
0022AEr 2  rr rr              .word LAB_LRMS-1        ; LEFT$()   process string expression
0022B0r 2  rr rr              .word LAB_LRMS-1        ; RIGHT$()        "
0022B2r 2  rr rr              .word LAB_LRMS-1        ; MID$()          "
0022B4r 2               
0022B4r 2               ; action addresses for functions
0022B4r 2               
0022B4r 2               LAB_FTBL
0022B4r 2               LAB_FTBM    = LAB_FTBL+$01
0022B4r 2  rr rr              .word LAB_SGN-1         ; SGN()
0022B6r 2  rr rr              .word LAB_INT-1         ; INT()
0022B8r 2  rr rr              .word LAB_ABS-1         ; ABS()
0022BAr 2  rr rr              .word LAB_USR-1         ; USR()
0022BCr 2  rr rr              .word LAB_FRE-1         ; FRE()
0022BEr 2  rr rr              .word LAB_POS-1         ; POS()
0022C0r 2  rr rr              .word LAB_SQR-1         ; SQR()
0022C2r 2  rr rr              .word LAB_RND-1         ; RND()           modified function
0022C4r 2  rr rr              .word LAB_LOG-1         ; LOG()
0022C6r 2  rr rr              .word LAB_EXP-1         ; EXP()
0022C8r 2  rr rr              .word LAB_COS-1         ; COS()
0022CAr 2  rr rr              .word LAB_SIN-1         ; SIN()
0022CCr 2  rr rr              .word LAB_TAN-1         ; TAN()
0022CEr 2  rr rr              .word LAB_ATN-1         ; ATN()
0022D0r 2  rr rr              .word LAB_PEEK-1        ; PEEK()
0022D2r 2  rr rr              .word LAB_DEEK-1        ; DEEK()          new function
0022D4r 2  rr rr              .word LAB_SADD-1        ; SADD()          new function
0022D6r 2  rr rr              .word LAB_LENS-1        ; LEN()
0022D8r 2  rr rr              .word LAB_STRS-1        ; STR$()
0022DAr 2  rr rr              .word LAB_VAL-1         ; VAL()
0022DCr 2  rr rr              .word LAB_ASC-1         ; ASC()
0022DEr 2  rr rr              .word LAB_UCASE-1       ; UCASE$()        new function
0022E0r 2  rr rr              .word LAB_LCASE-1       ; LCASE$()        new function
0022E2r 2  rr rr              .word LAB_CHRS-1        ; CHR$()
0022E4r 2  rr rr              .word LAB_HEXS-1        ; HEX$()          new function
0022E6r 2  rr rr              .word LAB_BINS-1        ; BIN$()          new function
0022E8r 2  rr rr              .word LAB_BTST-1        ; BITTST()        new function
0022EAr 2  rr rr              .word LAB_MAX-1         ; MAX()           new function
0022ECr 2  rr rr              .word LAB_MIN-1         ; MIN()           new function
0022EEr 2  rr rr              .word LAB_PI-1          ; PI              new function
0022F0r 2  rr rr              .word LAB_TWOPI-1       ; TWOPI           new function
0022F2r 2  rr rr              .word LAB_VARPTR-1      ; VARPTR()        new function
0022F4r 2  rr rr              .word LAB_LEFT-1        ; LEFT$()
0022F6r 2  rr rr              .word LAB_RIGHT-1       ; RIGHT$()
0022F8r 2  rr rr              .word LAB_MIDS-1        ; MID$()
0022FAr 2               
0022FAr 2               ; hierarchy and action addresses for operator
0022FAr 2               
0022FAr 2               LAB_OPPT
0022FAr 2  79                 .byte $79               ; +
0022FBr 2  rr rr              .word LAB_ADD-1
0022FDr 2  79                 .byte $79               ; -
0022FEr 2  rr rr              .word LAB_SUBTRACT-1
002300r 2  7B                 .byte $7B               ; *
002301r 2  rr rr              .word LAB_MULTIPLY-1
002303r 2  7B                 .byte $7B               ; /
002304r 2  rr rr              .word LAB_DIVIDE-1
002306r 2  7F                 .byte $7F               ; ^
002307r 2  rr rr              .word LAB_POWER-1
002309r 2  50                 .byte $50               ; AND
00230Ar 2  rr rr              .word LAB_AND-1
00230Cr 2  46                 .byte $46               ; EOR             new operator
00230Dr 2  rr rr              .word LAB_EOR-1
00230Fr 2  46                 .byte $46               ; OR
002310r 2  rr rr              .word LAB_OR-1
002312r 2  56                 .byte $56               ; >>              new operator
002313r 2  rr rr              .word LAB_RSHIFT-1
002315r 2  56                 .byte $56               ; <<              new operator
002316r 2  rr rr              .word LAB_LSHIFT-1
002318r 2  7D                 .byte $7D               ; >
002319r 2  rr rr              .word LAB_GTHAN-1
00231Br 2  5A                 .byte $5A               ; =
00231Cr 2  rr rr              .word LAB_EQUAL-1
00231Er 2  64                 .byte $64               ; <
00231Fr 2  rr rr              .word LAB_LTHAN-1
002321r 2               
002321r 2               ; keywords start with ..
002321r 2               ; this is the first character table and must be in alphabetic order
002321r 2               
002321r 2               TAB_1STC
002321r 2  2A                 .byte "*"
002322r 2  2B                 .byte "+"
002323r 2  2D                 .byte "-"
002324r 2  2F                 .byte "/"
002325r 2  3C                 .byte "<"
002326r 2  3D                 .byte "="
002327r 2  3E                 .byte ">"
002328r 2  3F                 .byte "?"
002329r 2  41                 .byte "A"
00232Ar 2  42                 .byte "B"
00232Br 2  43                 .byte "C"
00232Cr 2  44                 .byte "D"
00232Dr 2  45                 .byte "E"
00232Er 2  46                 .byte "F"
00232Fr 2  47                 .byte "G"
002330r 2  48                 .byte "H"
002331r 2  49                 .byte "I"
002332r 2  4C                 .byte "L"
002333r 2  4D                 .byte "M"
002334r 2  4E                 .byte "N"
002335r 2  4F                 .byte "O"
002336r 2  50                 .byte "P"
002337r 2  52                 .byte "R"
002338r 2  53                 .byte "S"
002339r 2  54                 .byte "T"
00233Ar 2  55                 .byte "U"
00233Br 2  56                 .byte "V"
00233Cr 2  57                 .byte "W"
00233Dr 2  5E                 .byte "^"
00233Er 2  00                 .byte $00               ; table terminator
00233Fr 2               
00233Fr 2               ; pointers to keyword tables
00233Fr 2               
00233Fr 2               TAB_CHRT
00233Fr 2  rr rr              .word TAB_STAR          ; table for "*"
002341r 2  rr rr              .word TAB_PLUS          ; table for "+"
002343r 2  rr rr              .word TAB_MNUS          ; table for "-"
002345r 2  rr rr              .word TAB_SLAS          ; table for "/"
002347r 2  rr rr              .word TAB_LESS          ; table for "<"
002349r 2  rr rr              .word TAB_EQUL          ; table for "="
00234Br 2  rr rr              .word TAB_MORE          ; table for ">"
00234Dr 2  rr rr              .word TAB_QEST          ; table for "?"
00234Fr 2  rr rr              .word TAB_ASCA          ; table for "A"
002351r 2  rr rr              .word TAB_ASCB          ; table for "B"
002353r 2  rr rr              .word TAB_ASCC          ; table for "C"
002355r 2  rr rr              .word TAB_ASCD          ; table for "D"
002357r 2  rr rr              .word TAB_ASCE          ; table for "E"
002359r 2  rr rr              .word TAB_ASCF          ; table for "F"
00235Br 2  rr rr              .word TAB_ASCG          ; table for "G"
00235Dr 2  rr rr              .word TAB_ASCH          ; table for "H"
00235Fr 2  rr rr              .word TAB_ASCI          ; table for "I"
002361r 2  rr rr              .word TAB_ASCL          ; table for "L"
002363r 2  rr rr              .word TAB_ASCM          ; table for "M"
002365r 2  rr rr              .word TAB_ASCN          ; table for "N"
002367r 2  rr rr              .word TAB_ASCO          ; table for "O"
002369r 2  rr rr              .word TAB_ASCP          ; table for "P"
00236Br 2  rr rr              .word TAB_ASCR          ; table for "R"
00236Dr 2  rr rr              .word TAB_ASCS          ; table for "S"
00236Fr 2  rr rr              .word TAB_ASCT          ; table for "T"
002371r 2  rr rr              .word TAB_ASCU          ; table for "U"
002373r 2  rr rr              .word TAB_ASCV          ; table for "V"
002375r 2  rr rr              .word TAB_ASCW          ; table for "W"
002377r 2  rr rr              .word TAB_POWR          ; table for "^"
002379r 2               
002379r 2               ; tables for each start character, note if a longer keyword with the same start
002379r 2               ; letters as a shorter one exists then it must come first, else the list is in
002379r 2               ; alphabetical order as follows ..
002379r 2               
002379r 2               ; [keyword,token
002379r 2               ; [keyword,token]]
002379r 2               ; end marker (#$00)
002379r 2               
002379r 2               TAB_STAR
002379r 2  B8 00              .byte TK_MUL,$00        ; *
00237Br 2               TAB_PLUS
00237Br 2  B6 00              .byte TK_PLUS,$00       ; +
00237Dr 2               TAB_MNUS
00237Dr 2  B7 00              .byte TK_MINUS,$00      ; -
00237Fr 2               TAB_SLAS
00237Fr 2  B9 00              .byte TK_DIV,$00        ; /
002381r 2               TAB_LESS
002381r 2               LBB_LSHIFT
002381r 2  3C BF              .byte "<",TK_LSHIFT     ; <<  note - "<<" must come before "<"
002383r 2  C2                 .byte TK_LT             ; <
002384r 2  00                 .byte $00
002385r 2               TAB_EQUL
002385r 2  C1 00              .byte TK_EQUAL,$00      ; =
002387r 2               TAB_MORE
002387r 2               LBB_RSHIFT
002387r 2  3E BE              .byte ">",TK_RSHIFT     ; >>  note - ">>" must come before ">"
002389r 2  C0                 .byte TK_GT             ; >
00238Ar 2  00                 .byte $00
00238Br 2               TAB_QEST
00238Br 2  9F 00              .byte TK_PRINT,$00      ; ?
00238Dr 2               TAB_ASCA
00238Dr 2               LBB_ABS
00238Dr 2  42 53 28 C5        .byte "BS(",TK_ABS      ; ABS(
002391r 2               LBB_AND
002391r 2  4E 44 BB           .byte "ND",TK_AND       ; AND
002394r 2               LBB_ASC
002394r 2  53 43 28 D7        .byte "SC(",TK_ASC      ; ASC(
002398r 2               LBB_ATN
002398r 2  54 4E 28 D0        .byte "TN(",TK_ATN      ; ATN(
00239Cr 2  00                 .byte $00
00239Dr 2               TAB_ASCB
00239Dr 2               LBB_BINS
00239Dr 2  49 4E 24 28        .byte "IN$(",TK_BINS    ; BIN$(
0023A1r 2  DC           
0023A2r 2               LBB_BITCLR
0023A2r 2  49 54 43 4C        .byte "ITCLR",TK_BITCLR ; BITCLR
0023A6r 2  52 A8        
0023A8r 2               LBB_BITSET
0023A8r 2  49 54 53 45        .byte "ITSET",TK_BITSET ; BITSET
0023ACr 2  54 A7        
0023AEr 2               LBB_BITTST
0023AEr 2  49 54 54 53        .byte "ITTST(",TK_BITTST
0023B2r 2  54 28 DD     
0023B5r 2                                             ; BITTST(
0023B5r 2  00                 .byte $00
0023B6r 2               TAB_ASCC
0023B6r 2               LBB_CALL
0023B6r 2  41 4C 4C 9C        .byte "ALL",TK_CALL     ; CALL
0023BAr 2               LBB_CHRS
0023BAr 2  48 52 24 28        .byte "HR$(",TK_CHRS    ; CHR$(
0023BEr 2  DA           
0023BFr 2               LBB_CLEAR
0023BFr 2  4C 45 41 52        .byte "LEAR",TK_CLEAR   ; CLEAR
0023C3r 2  A2           
0023C4r 2               LBB_CONT
0023C4r 2  4F 4E 54 A0        .byte "ONT",TK_CONT     ; CONT
0023C8r 2               LBB_COS
0023C8r 2  4F 53 28 CD        .byte "OS(",TK_COS      ; COS(
0023CCr 2  00                 .byte $00
0023CDr 2               TAB_ASCD
0023CDr 2               LBB_DATA
0023CDr 2  41 54 41 83        .byte "ATA",TK_DATA     ; DATA
0023D1r 2               LBB_DEC
0023D1r 2  45 43 88           .byte "EC",TK_DEC       ; DEC
0023D4r 2               LBB_DEEK
0023D4r 2  45 45 4B 28        .byte "EEK(",TK_DEEK    ; DEEK(
0023D8r 2  D2           
0023D9r 2               LBB_DEF
0023D9r 2  45 46 99           .byte "EF",TK_DEF       ; DEF
0023DCr 2               LBB_DIM
0023DCr 2  49 4D 85           .byte "IM",TK_DIM       ; DIM
0023DFr 2               LBB_DOKE
0023DFr 2  4F 4B 45 9B        .byte "OKE",TK_DOKE     ; DOKE note - "DOKE" must come before "DO"
0023E3r 2               LBB_DO
0023E3r 2  4F 9D              .byte "O",TK_DO         ; DO
0023E5r 2  00                 .byte $00
0023E6r 2               TAB_ASCE
0023E6r 2               LBB_ELSE
0023E6r 2  4C 53 45 AC        .byte "LSE",TK_ELSE     ; ELSE
0023EAr 2               LBB_END
0023EAr 2  4E 44 80           .byte "ND",TK_END       ; END
0023EDr 2               LBB_EOR
0023EDr 2  4F 52 BC           .byte "OR",TK_EOR       ; EOR
0023F0r 2               LBB_EXP
0023F0r 2  58 50 28 CC        .byte "XP(",TK_EXP      ; EXP(
0023F4r 2  00                 .byte $00
0023F5r 2               TAB_ASCF
0023F5r 2               LBB_FN
0023F5r 2  4E AE              .byte "N",TK_FN         ; FN
0023F7r 2               LBB_FOR
0023F7r 2  4F 52 81           .byte "OR",TK_FOR       ; FOR
0023FAr 2               LBB_FRE
0023FAr 2  52 45 28 C7        .byte "RE(",TK_FRE      ; FRE(
0023FEr 2  00                 .byte $00
0023FFr 2               TAB_ASCG
0023FFr 2               LBB_GET
0023FFr 2  45 54 A5           .byte "ET",TK_GET       ; GET
002402r 2               LBB_GOSUB
002402r 2  4F 53 55 42        .byte "OSUB",TK_GOSUB   ; GOSUB
002406r 2  8D           
002407r 2               LBB_GOTO
002407r 2  4F 54 4F 89        .byte "OTO",TK_GOTO     ; GOTO
00240Br 2  00                 .byte $00
00240Cr 2               TAB_ASCH
00240Cr 2               LBB_HEXS
00240Cr 2  45 58 24 28        .byte "EX$(",TK_HEXS    ; HEX$(
002410r 2  DB           
002411r 2  00                 .byte $00
002412r 2               TAB_ASCI
002412r 2               LBB_IF
002412r 2  46 8B              .byte "F",TK_IF         ; IF
002414r 2               LBB_INC
002414r 2  4E 43 95           .byte "NC",TK_INC       ; INC
002417r 2               LBB_INPUT
002417r 2  4E 50 55 54        .byte "NPUT",TK_INPUT   ; INPUT
00241Br 2  84           
00241Cr 2               LBB_INT
00241Cr 2  4E 54 28 C4        .byte "NT(",TK_INT      ; INT(
002420r 2               LBB_IRQ
002420r 2  52 51 A9           .byte "RQ",TK_IRQ       ; IRQ
002423r 2  00                 .byte $00
002424r 2               TAB_ASCL
002424r 2               LBB_LCASES
002424r 2  43 41 53 45        .byte "CASE$(",TK_LCASES
002428r 2  24 28 D9     
00242Br 2                                             ; LCASE$(
00242Br 2               LBB_LEFTS
00242Br 2  45 46 54 24        .byte "EFT$(",TK_LEFTS  ; LEFT$(
00242Fr 2  28 E3        
002431r 2               LBB_LEN
002431r 2  45 4E 28 D4        .byte "EN(",TK_LEN      ; LEN(
002435r 2               LBB_LET
002435r 2  45 54 87           .byte "ET",TK_LET       ; LET
002438r 2               LBB_LIST
002438r 2  49 53 54 A1        .byte "IST",TK_LIST     ; LIST
00243Cr 2               LBB_LOAD
00243Cr 2  4F 41 44 97        .byte "OAD",TK_LOAD     ; LOAD
002440r 2               LBB_LOG
002440r 2  4F 47 28 CB        .byte "OG(",TK_LOG      ; LOG(
002444r 2               LBB_LOOP
002444r 2  4F 4F 50 9E        .byte "OOP",TK_LOOP     ; LOOP
002448r 2  00                 .byte $00
002449r 2               TAB_ASCM
002449r 2               LBB_MAX
002449r 2  41 58 28 DE        .byte "AX(",TK_MAX      ; MAX(
00244Dr 2               LBB_MIDS
00244Dr 2  49 44 24 28        .byte "ID$(",TK_MIDS    ; MID$(
002451r 2  E5           
002452r 2               LBB_MIN
002452r 2  49 4E 28 DF        .byte "IN(",TK_MIN      ; MIN(
002456r 2  00                 .byte $00
002457r 2               TAB_ASCN
002457r 2               LBB_NEW
002457r 2  45 57 A3           .byte "EW",TK_NEW       ; NEW
00245Ar 2               LBB_NEXT
00245Ar 2  45 58 54 82        .byte "EXT",TK_NEXT     ; NEXT
00245Er 2               LBB_NMI
00245Er 2  4D 49 AA           .byte "MI",TK_NMI       ; NMI
002461r 2               LBB_NOT
002461r 2  4F 54 B1           .byte "OT",TK_NOT       ; NOT
002464r 2               LBB_NULL
002464r 2  55 4C 4C 94        .byte "ULL",TK_NULL     ; NULL
002468r 2  00                 .byte $00
002469r 2               TAB_ASCO
002469r 2               LBB_OFF
002469r 2  46 46 B5           .byte "FF",TK_OFF       ; OFF
00246Cr 2               LBB_ON
00246Cr 2  4E 93              .byte "N",TK_ON         ; ON
00246Er 2               LBB_OR
00246Er 2  52 BD              .byte "R",TK_OR         ; OR
002470r 2  00                 .byte $00
002471r 2               TAB_ASCP
002471r 2               LBB_PEEK
002471r 2  45 45 4B 28        .byte "EEK(",TK_PEEK    ; PEEK(
002475r 2  D1           
002476r 2               LBB_PI
002476r 2  49 E0              .byte "I",TK_PI         ; PI
002478r 2               LBB_POKE
002478r 2  4F 4B 45 9A        .byte "OKE",TK_POKE     ; POKE
00247Cr 2               LBB_POS
00247Cr 2  4F 53 28 C8        .byte "OS(",TK_POS      ; POS(
002480r 2               LBB_PRINT
002480r 2  52 49 4E 54        .byte "RINT",TK_PRINT   ; PRINT
002484r 2  9F           
002485r 2  00                 .byte $00
002486r 2               TAB_ASCR
002486r 2               LBB_READ
002486r 2  45 41 44 86        .byte "EAD",TK_READ     ; READ
00248Ar 2               LBB_REM
00248Ar 2  45 4D 91           .byte "EM",TK_REM       ; REM
00248Dr 2               LBB_RESTORE
00248Dr 2  45 53 54 4F        .byte "ESTORE",TK_RESTORE
002491r 2  52 45 8C     
002494r 2                                             ; RESTORE
002494r 2               LBB_RETIRQ
002494r 2  45 54 49 52        .byte "ETIRQ",TK_RETIRQ ; RETIRQ
002498r 2  51 8E        
00249Ar 2               LBB_RETNMI
00249Ar 2  45 54 4E 4D        .byte "ETNMI",TK_RETNMI ; RETNMI
00249Er 2  49 8F        
0024A0r 2               LBB_RETURN
0024A0r 2  45 54 55 52        .byte "ETURN",TK_RETURN ; RETURN
0024A4r 2  4E 90        
0024A6r 2               LBB_RIGHTS
0024A6r 2  49 47 48 54        .byte "IGHT$(",TK_RIGHTS
0024AAr 2  24 28 E4     
0024ADr 2                                             ; RIGHT$(
0024ADr 2               LBB_RND
0024ADr 2  4E 44 28 CA        .byte "ND(",TK_RND      ; RND(
0024B1r 2               LBB_RUN
0024B1r 2  55 4E 8A           .byte "UN",TK_RUN       ; RUN
0024B4r 2  00                 .byte $00
0024B5r 2               TAB_ASCS
0024B5r 2               LBB_SADD
0024B5r 2  41 44 44 28        .byte "ADD(",TK_SADD    ; SADD(
0024B9r 2  D3           
0024BAr 2               LBB_SAVE
0024BAr 2  41 56 45 98        .byte "AVE",TK_SAVE     ; SAVE
0024BEr 2               LBB_SGN
0024BEr 2  47 4E 28 C3        .byte "GN(",TK_SGN      ; SGN(
0024C2r 2               LBB_SIN
0024C2r 2  49 4E 28 CE        .byte "IN(",TK_SIN      ; SIN(
0024C6r 2               LBB_SPC
0024C6r 2  50 43 28 AF        .byte "PC(",TK_SPC      ; SPC(
0024CAr 2               LBB_SQR
0024CAr 2  51 52 28 C9        .byte "QR(",TK_SQR      ; SQR(
0024CEr 2               LBB_STEP
0024CEr 2  54 45 50 B2        .byte "TEP",TK_STEP     ; STEP
0024D2r 2               LBB_STOP
0024D2r 2  54 4F 50 92        .byte "TOP",TK_STOP     ; STOP
0024D6r 2               LBB_STRS
0024D6r 2  54 52 24 28        .byte "TR$(",TK_STRS    ; STR$(
0024DAr 2  D5           
0024DBr 2               LBB_SWAP
0024DBr 2  57 41 50 A6        .byte "WAP",TK_SWAP     ; SWAP
0024DFr 2  00                 .byte $00
0024E0r 2               TAB_ASCT
0024E0r 2               LBB_TAB
0024E0r 2  41 42 28 AB        .byte "AB(",TK_TAB      ; TAB(
0024E4r 2               LBB_TAN
0024E4r 2  41 4E 28 CF        .byte "AN(",TK_TAN      ; TAN(
0024E8r 2               LBB_THEN
0024E8r 2  48 45 4E B0        .byte "HEN",TK_THEN     ; THEN
0024ECr 2               LBB_TO
0024ECr 2  4F AD              .byte "O",TK_TO         ; TO
0024EEr 2               LBB_TWOPI
0024EEr 2  57 4F 50 49        .byte "WOPI",TK_TWOPI   ; TWOPI
0024F2r 2  E1           
0024F3r 2  00                 .byte $00
0024F4r 2               TAB_ASCU
0024F4r 2               LBB_UCASES
0024F4r 2  43 41 53 45        .byte "CASE$(",TK_UCASES
0024F8r 2  24 28 D8     
0024FBr 2                                             ; UCASE$(
0024FBr 2               LBB_UNTIL
0024FBr 2  4E 54 49 4C        .byte "NTIL",TK_UNTIL   ; UNTIL
0024FFr 2  B3           
002500r 2               LBB_USR
002500r 2  53 52 28 C6        .byte "SR(",TK_USR      ; USR(
002504r 2  00                 .byte $00
002505r 2               TAB_ASCV
002505r 2               LBB_VAL
002505r 2  41 4C 28 D6        .byte "AL(",TK_VAL      ; VAL(
002509r 2               LBB_VPTR
002509r 2  41 52 50 54        .byte "ARPTR(",TK_VPTR  ; VARPTR(
00250Dr 2  52 28 E2     
002510r 2  00                 .byte $00
002511r 2               TAB_ASCW
002511r 2               LBB_WAIT
002511r 2  41 49 54 96        .byte "AIT",TK_WAIT     ; WAIT
002515r 2               LBB_WHILE
002515r 2  48 49 4C 45        .byte "HILE",TK_WHILE   ; WHILE
002519r 2  B4           
00251Ar 2               LBB_WIDTH
00251Ar 2  49 44 54 48        .byte "IDTH",TK_WIDTH   ; WIDTH
00251Er 2  A4           
00251Fr 2  00                 .byte $00
002520r 2               TAB_POWR
002520r 2  BA 00              .byte TK_POWER,$00      ; ^
002522r 2               
002522r 2               ; new decode table for LIST
002522r 2               ; Table is ..
002522r 2               ; byte - keyword length, keyword first character
002522r 2               ; word - pointer to rest of keyword from dictionary
002522r 2               
002522r 2               ; note if length is 1 then the pointer is ignored
002522r 2               
002522r 2               LAB_KEYT
002522r 2  03 45              .byte 3,'E'
002524r 2  rr rr              .word LBB_END           ; END
002526r 2  03 46              .byte 3,'F'
002528r 2  rr rr              .word LBB_FOR           ; FOR
00252Ar 2  04 4E              .byte 4,'N'
00252Cr 2  rr rr              .word LBB_NEXT          ; NEXT
00252Er 2  04 44              .byte 4,'D'
002530r 2  rr rr              .word LBB_DATA          ; DATA
002532r 2  05 49              .byte 5,'I'
002534r 2  rr rr              .word LBB_INPUT         ; INPUT
002536r 2  03 44              .byte 3,'D'
002538r 2  rr rr              .word LBB_DIM           ; DIM
00253Ar 2  04 52              .byte 4,'R'
00253Cr 2  rr rr              .word LBB_READ          ; READ
00253Er 2  03 4C              .byte 3,'L'
002540r 2  rr rr              .word LBB_LET           ; LET
002542r 2  03 44              .byte 3,'D'
002544r 2  rr rr              .word LBB_DEC           ; DEC
002546r 2  04 47              .byte 4,'G'
002548r 2  rr rr              .word LBB_GOTO          ; GOTO
00254Ar 2  03 52              .byte 3,'R'
00254Cr 2  rr rr              .word LBB_RUN           ; RUN
00254Er 2  02 49              .byte 2,'I'
002550r 2  rr rr              .word LBB_IF            ; IF
002552r 2  07 52              .byte 7,'R'
002554r 2  rr rr              .word LBB_RESTORE       ; RESTORE
002556r 2  05 47              .byte 5,'G'
002558r 2  rr rr              .word LBB_GOSUB         ; GOSUB
00255Ar 2  06 52              .byte 6,'R'
00255Cr 2  rr rr              .word LBB_RETIRQ        ; RETIRQ
00255Er 2  06 52              .byte 6,'R'
002560r 2  rr rr              .word LBB_RETNMI        ; RETNMI
002562r 2  06 52              .byte 6,'R'
002564r 2  rr rr              .word LBB_RETURN        ; RETURN
002566r 2  03 52              .byte 3,'R'
002568r 2  rr rr              .word LBB_REM           ; REM
00256Ar 2  04 53              .byte 4,'S'
00256Cr 2  rr rr              .word LBB_STOP          ; STOP
00256Er 2  02 4F              .byte 2,'O'
002570r 2  rr rr              .word LBB_ON            ; ON
002572r 2  04 4E              .byte 4,'N'
002574r 2  rr rr              .word LBB_NULL          ; NULL
002576r 2  03 49              .byte 3,'I'
002578r 2  rr rr              .word LBB_INC           ; INC
00257Ar 2  04 57              .byte 4,'W'
00257Cr 2  rr rr              .word LBB_WAIT          ; WAIT
00257Er 2  04 4C              .byte 4,'L'
002580r 2  rr rr              .word LBB_LOAD          ; LOAD
002582r 2  04 53              .byte 4,'S'
002584r 2  rr rr              .word LBB_SAVE          ; SAVE
002586r 2  03 44              .byte 3,'D'
002588r 2  rr rr              .word LBB_DEF           ; DEF
00258Ar 2  04 50              .byte 4,'P'
00258Cr 2  rr rr              .word LBB_POKE          ; POKE
00258Er 2  04 44              .byte 4,'D'
002590r 2  rr rr              .word LBB_DOKE          ; DOKE
002592r 2  04 43              .byte 4,'C'
002594r 2  rr rr              .word LBB_CALL          ; CALL
002596r 2  02 44              .byte 2,'D'
002598r 2  rr rr              .word LBB_DO            ; DO
00259Ar 2  04 4C              .byte 4,'L'
00259Cr 2  rr rr              .word LBB_LOOP          ; LOOP
00259Er 2  05 50              .byte 5,'P'
0025A0r 2  rr rr              .word LBB_PRINT         ; PRINT
0025A2r 2  04 43              .byte 4,'C'
0025A4r 2  rr rr              .word LBB_CONT          ; CONT
0025A6r 2  04 4C              .byte 4,'L'
0025A8r 2  rr rr              .word LBB_LIST          ; LIST
0025AAr 2  05 43              .byte 5,'C'
0025ACr 2  rr rr              .word LBB_CLEAR         ; CLEAR
0025AEr 2  03 4E              .byte 3,'N'
0025B0r 2  rr rr              .word LBB_NEW           ; NEW
0025B2r 2  05 57              .byte 5,'W'
0025B4r 2  rr rr              .word LBB_WIDTH         ; WIDTH
0025B6r 2  03 47              .byte 3,'G'
0025B8r 2  rr rr              .word LBB_GET           ; GET
0025BAr 2  04 53              .byte 4,'S'
0025BCr 2  rr rr              .word LBB_SWAP          ; SWAP
0025BEr 2  06 42              .byte 6,'B'
0025C0r 2  rr rr              .word LBB_BITSET        ; BITSET
0025C2r 2  06 42              .byte 6,'B'
0025C4r 2  rr rr              .word LBB_BITCLR        ; BITCLR
0025C6r 2  03 49              .byte 3,'I'
0025C8r 2  rr rr              .word LBB_IRQ           ; IRQ
0025CAr 2  03 4E              .byte 3,'N'
0025CCr 2  rr rr              .word LBB_NMI           ; NMI
0025CEr 2               
0025CEr 2               ; secondary commands (can't start a statement)
0025CEr 2               
0025CEr 2  04 54              .byte 4,'T'
0025D0r 2  rr rr              .word LBB_TAB           ; TAB
0025D2r 2  04 45              .byte 4,'E'
0025D4r 2  rr rr              .word LBB_ELSE          ; ELSE
0025D6r 2  02 54              .byte 2,'T'
0025D8r 2  rr rr              .word LBB_TO            ; TO
0025DAr 2  02 46              .byte 2,'F'
0025DCr 2  rr rr              .word LBB_FN            ; FN
0025DEr 2  04 53              .byte 4,'S'
0025E0r 2  rr rr              .word LBB_SPC           ; SPC
0025E2r 2  04 54              .byte 4,'T'
0025E4r 2  rr rr              .word LBB_THEN          ; THEN
0025E6r 2  03 4E              .byte 3,'N'
0025E8r 2  rr rr              .word LBB_NOT           ; NOT
0025EAr 2  04 53              .byte 4,'S'
0025ECr 2  rr rr              .word LBB_STEP          ; STEP
0025EEr 2  05 55              .byte 5,'U'
0025F0r 2  rr rr              .word LBB_UNTIL         ; UNTIL
0025F2r 2  05 57              .byte 5,'W'
0025F4r 2  rr rr              .word LBB_WHILE         ; WHILE
0025F6r 2  03 4F              .byte 3,'O'
0025F8r 2  rr rr              .word LBB_OFF           ; OFF
0025FAr 2               
0025FAr 2               ; opperators
0025FAr 2               
0025FAr 2  01 2B              .byte 1,'+'
0025FCr 2  00 00              .word $0000             ; +
0025FEr 2  01 2D              .byte 1,'-'
002600r 2  00 00              .word $0000             ; -
002602r 2  01 2A              .byte 1,'*'
002604r 2  00 00              .word $0000             ; *
002606r 2  01 2F              .byte 1,'/'
002608r 2  00 00              .word $0000             ; /
00260Ar 2  01 5E              .byte 1,'^'
00260Cr 2  00 00              .word $0000             ; ^
00260Er 2  03 41              .byte 3,'A'
002610r 2  rr rr              .word LBB_AND           ; AND
002612r 2  03 45              .byte 3,'E'
002614r 2  rr rr              .word LBB_EOR           ; EOR
002616r 2  02 4F              .byte 2,'O'
002618r 2  rr rr              .word LBB_OR            ; OR
00261Ar 2  02 3E              .byte 2,'>'
00261Cr 2  rr rr              .word LBB_RSHIFT        ; >>
00261Er 2  02 3C              .byte 2,'<'
002620r 2  rr rr              .word LBB_LSHIFT        ; <<
002622r 2  01 3E              .byte 1,'>'
002624r 2  00 00              .word $0000             ; >
002626r 2  01 3D              .byte 1,'='
002628r 2  00 00              .word $0000             ; =
00262Ar 2  01 3C              .byte 1,'<'
00262Cr 2  00 00              .word $0000             ; <
00262Er 2               
00262Er 2               ; functions
00262Er 2               
00262Er 2  04 53              .byte 4,'S'             ;
002630r 2  rr rr              .word LBB_SGN           ; SGN
002632r 2  04 49              .byte 4,'I'             ;
002634r 2  rr rr              .word LBB_INT           ; INT
002636r 2  04 41              .byte 4,'A'             ;
002638r 2  rr rr              .word LBB_ABS           ; ABS
00263Ar 2  04 55              .byte 4,'U'             ;
00263Cr 2  rr rr              .word LBB_USR           ; USR
00263Er 2  04 46              .byte 4,'F'             ;
002640r 2  rr rr              .word LBB_FRE           ; FRE
002642r 2  04 50              .byte 4,'P'             ;
002644r 2  rr rr              .word LBB_POS           ; POS
002646r 2  04 53              .byte 4,'S'             ;
002648r 2  rr rr              .word LBB_SQR           ; SQR
00264Ar 2  04 52              .byte 4,'R'             ;
00264Cr 2  rr rr              .word LBB_RND           ; RND
00264Er 2  04 4C              .byte 4,'L'             ;
002650r 2  rr rr              .word LBB_LOG           ; LOG
002652r 2  04 45              .byte 4,'E'             ;
002654r 2  rr rr              .word LBB_EXP           ; EXP
002656r 2  04 43              .byte 4,'C'             ;
002658r 2  rr rr              .word LBB_COS           ; COS
00265Ar 2  04 53              .byte 4,'S'             ;
00265Cr 2  rr rr              .word LBB_SIN           ; SIN
00265Er 2  04 54              .byte 4,'T'             ;
002660r 2  rr rr              .word LBB_TAN           ; TAN
002662r 2  04 41              .byte 4,'A'             ;
002664r 2  rr rr              .word LBB_ATN           ; ATN
002666r 2  05 50              .byte 5,'P'             ;
002668r 2  rr rr              .word LBB_PEEK          ; PEEK
00266Ar 2  05 44              .byte 5,'D'             ;
00266Cr 2  rr rr              .word LBB_DEEK          ; DEEK
00266Er 2  05 53              .byte 5,'S'             ;
002670r 2  rr rr              .word LBB_SADD          ; SADD
002672r 2  04 4C              .byte 4,'L'             ;
002674r 2  rr rr              .word LBB_LEN           ; LEN
002676r 2  05 53              .byte 5,'S'             ;
002678r 2  rr rr              .word LBB_STRS          ; STR$
00267Ar 2  04 56              .byte 4,'V'             ;
00267Cr 2  rr rr              .word LBB_VAL           ; VAL
00267Er 2  04 41              .byte 4,'A'             ;
002680r 2  rr rr              .word LBB_ASC           ; ASC
002682r 2  07 55              .byte 7,'U'             ;
002684r 2  rr rr              .word LBB_UCASES        ; UCASE$
002686r 2  07 4C              .byte 7,'L'             ;
002688r 2  rr rr              .word LBB_LCASES        ; LCASE$
00268Ar 2  05 43              .byte 5,'C'             ;
00268Cr 2  rr rr              .word LBB_CHRS          ; CHR$
00268Er 2  05 48              .byte 5,'H'             ;
002690r 2  rr rr              .word LBB_HEXS          ; HEX$
002692r 2  05 42              .byte 5,'B'             ;
002694r 2  rr rr              .word LBB_BINS          ; BIN$
002696r 2  07 42              .byte 7,'B'             ;
002698r 2  rr rr              .word LBB_BITTST        ; BITTST
00269Ar 2  04 4D              .byte 4,'M'             ;
00269Cr 2  rr rr              .word LBB_MAX           ; MAX
00269Er 2  04 4D              .byte 4,'M'             ;
0026A0r 2  rr rr              .word LBB_MIN           ; MIN
0026A2r 2  02 50              .byte 2,'P'             ;
0026A4r 2  rr rr              .word LBB_PI            ; PI
0026A6r 2  05 54              .byte 5,'T'             ;
0026A8r 2  rr rr              .word LBB_TWOPI         ; TWOPI
0026AAr 2  07 56              .byte 7,'V'             ;
0026ACr 2  rr rr              .word LBB_VPTR          ; VARPTR
0026AEr 2  06 4C              .byte 6,'L'             ;
0026B0r 2  rr rr              .word LBB_LEFTS         ; LEFT$
0026B2r 2  07 52              .byte 7,'R'             ;
0026B4r 2  rr rr              .word LBB_RIGHTS        ; RIGHT$
0026B6r 2  05 4D              .byte 5,'M'             ;
0026B8r 2  rr rr              .word LBB_MIDS          ; MID$
0026BAr 2               
0026BAr 2               ; BASIC messages, mostly error messages
0026BAr 2               
0026BAr 2               LAB_BAER
0026BAr 2  rr rr              .word ERR_NF            ;$00 NEXT without FOR
0026BCr 2  rr rr              .word ERR_SN            ;$02 syntax
0026BEr 2  rr rr              .word ERR_RG            ;$04 RETURN without GOSUB
0026C0r 2  rr rr              .word ERR_OD            ;$06 out of data
0026C2r 2  rr rr              .word ERR_FC            ;$08 function call
0026C4r 2  rr rr              .word ERR_OV            ;$0A overflow
0026C6r 2  rr rr              .word ERR_OM            ;$0C out of memory
0026C8r 2  rr rr              .word ERR_US            ;$0E undefined statement
0026CAr 2  rr rr              .word ERR_BS            ;$10 array bounds
0026CCr 2  rr rr              .word ERR_DD            ;$12 double dimension array
0026CEr 2  rr rr              .word ERR_D0            ;$14 divide by 0
0026D0r 2  rr rr              .word ERR_ID            ;$16 illegal direct
0026D2r 2  rr rr              .word ERR_TM            ;$18 type mismatch
0026D4r 2  rr rr              .word ERR_LS            ;$1A long string
0026D6r 2  rr rr              .word ERR_ST            ;$1C string too complex
0026D8r 2  rr rr              .word ERR_CN            ;$1E continue error
0026DAr 2  rr rr              .word ERR_UF            ;$20 undefined function
0026DCr 2  rr rr              .word ERR_LD            ;$22 LOOP without DO
0026DEr 2               
0026DEr 2               ; I may implement these two errors to force definition of variables and
0026DEr 2               ; dimensioning of arrays before use.
0026DEr 2               
0026DEr 2               ;     .word ERR_UV            ;$24 undefined variable
0026DEr 2               
0026DEr 2               ; the above error has been tested and works (see code and comments below LAB_1D8B)
0026DEr 2               
0026DEr 2               ;     .word ERR_UA            ;$26 undimensioned array
0026DEr 2               
0026DEr 2  4E 45 58 54  ERR_NF      .byte "NEXT without FOR",$00
0026E2r 2  20 77 69 74  
0026E6r 2  68 6F 75 74  
0026EFr 2  53 79 6E 74  ERR_SN      .byte "Syntax",$00
0026F3r 2  61 78 00     
0026F6r 2  52 45 54 55  ERR_RG      .byte "RETURN without GOSUB",$00
0026FAr 2  52 4E 20 77  
0026FEr 2  69 74 68 6F  
00270Br 2  4F 75 74 20  ERR_OD      .byte "Out of DATA",$00
00270Fr 2  6F 66 20 44  
002713r 2  41 54 41 00  
002717r 2  46 75 6E 63  ERR_FC      .byte "Function call",$00
00271Br 2  74 69 6F 6E  
00271Fr 2  20 63 61 6C  
002725r 2  4F 76 65 72  ERR_OV      .byte "Overflow",$00
002729r 2  66 6C 6F 77  
00272Dr 2  00           
00272Er 2  4F 75 74 20  ERR_OM      .byte "Out of memory",$00
002732r 2  6F 66 20 6D  
002736r 2  65 6D 6F 72  
00273Cr 2  55 6E 64 65  ERR_US      .byte "Undefined statement",$00
002740r 2  66 69 6E 65  
002744r 2  64 20 73 74  
002750r 2  41 72 72 61  ERR_BS      .byte "Array bounds",$00
002754r 2  79 20 62 6F  
002758r 2  75 6E 64 73  
00275Dr 2  44 6F 75 62  ERR_DD      .byte "Double dimension",$00
002761r 2  6C 65 20 64  
002765r 2  69 6D 65 6E  
00276Er 2  44 69 76 69  ERR_D0      .byte "Divide by zero",$00
002772r 2  64 65 20 62  
002776r 2  79 20 7A 65  
00277Dr 2  49 6C 6C 65  ERR_ID      .byte "Illegal direct",$00
002781r 2  67 61 6C 20  
002785r 2  64 69 72 65  
00278Cr 2  54 79 70 65  ERR_TM      .byte "Type mismatch",$00
002790r 2  20 6D 69 73  
002794r 2  6D 61 74 63  
00279Ar 2  53 74 72 69  ERR_LS      .byte "String too long",$00
00279Er 2  6E 67 20 74  
0027A2r 2  6F 6F 20 6C  
0027AAr 2  53 74 72 69  ERR_ST      .byte "String too complex",$00
0027AEr 2  6E 67 20 74  
0027B2r 2  6F 6F 20 63  
0027BDr 2  43 61 6E 27  ERR_CN      .byte "Can't continue",$00
0027C1r 2  74 20 63 6F  
0027C5r 2  6E 74 69 6E  
0027CCr 2  55 6E 64 65  ERR_UF      .byte "Undefined function",$00
0027D0r 2  66 69 6E 65  
0027D4r 2  64 20 66 75  
0027DFr 2  4C 4F 4F 50  ERR_LD      .byte "LOOP without DO",$00
0027E3r 2  20 77 69 74  
0027E7r 2  68 6F 75 74  
0027EFr 2               
0027EFr 2               ;ERR_UV     .byte "Undefined variable",$00
0027EFr 2               
0027EFr 2               ; the above error has been tested and works (see code and comments below LAB_1D8B)
0027EFr 2               
0027EFr 2               ;ERR_UA     .byte "Undimensioned array",$00
0027EFr 2               
0027EFr 2  0D 0A 42 72  LAB_BMSG    .byte $0D,$0A,"Break",$00
0027F3r 2  65 61 6B 00  
0027F7r 2  20 45 72 72  LAB_EMSG    .byte " Error",$00
0027FBr 2  6F 72 00     
0027FEr 2  20 69 6E 20  LAB_LMSG    .byte " in line ",$00
002802r 2  6C 69 6E 65  
002806r 2  20 00        
002808r 2  0D 0A 52 65  LAB_RMSG    .byte $0D,$0A,"Ready",$0D,$0A,$00
00280Cr 2  61 64 79 0D  
002810r 2  0A 00        
002812r 2               
002812r 2  20 45 78 74  LAB_IMSG    .byte " Extra ignored",$0D,$0A,$00
002816r 2  72 61 20 69  
00281Ar 2  67 6E 6F 72  
002823r 2  20 52 65 64  LAB_REDO    .byte " Redo from start",$0D,$0A,$00
002827r 2  6F 20 66 72  
00282Br 2  6F 6D 20 73  
002836r 2               
002836r 2               AA_end_basic
002836r 2               
002836r 1               
002836r 1               ; put the IRQ and MNI code in RAM so that it can be changed
002836r 1               
002836r 1               IRQ_vec     = VEC_SV+2        ; IRQ code vector
002836r 1               NMI_vec     = IRQ_vec+$0A     ; NMI code vector
002836r 1               
002836r 1               ; now the code. all this does is set up the vectors and interrupt code
002836r 1               ; and wait for the user to select [C]old or [W]arm start. nothing else
002836r 1               ; fits in less than 128 bytes
002836r 1               
002836r 1                     .segment "CODE"         ; pretend this is in a 1/8K ROM
002836r 1               
002836r 1               ; reset vector points here
002836r 1               
002836r 1               RES_vec
002836r 1  D8                 CLD                     ; clear decimal mode
002837r 1  A2 FF              LDX   #$FF              ; empty stack
002839r 1  9A                 TXS                     ; set the stack
00283Ar 1  20 rr rr           JSR ACIAsetup
00283Dr 1               
00283Dr 1               ; set up vectors and interrupt code, copy them to page 2
00283Dr 1               
00283Dr 1  A0 1C              LDY   #END_CODE-LAB_vec ; set index/count
00283Fr 1               LAB_stlp
00283Fr 1  B9 rr rr           LDA   LAB_vec-1,Y       ; get byte from interrupt code
002842r 1  99 04 02           STA   VEC_IN-1,Y        ; save to RAM
002845r 1  88                 DEY                     ; decrement index/count
002846r 1  D0 F7              BNE   LAB_stlp          ; loop if more to do
002848r 1               
002848r 1               ; now do the signon message, Y = $00 here
002848r 1               
002848r 1               LAB_signon
002848r 1  B9 rr rr           LDA   LAB_mess,Y        ; get byte from sign on message
00284Br 1  F0 06              BEQ   LAB_nokey         ; exit loop if done
00284Dr 1               
00284Dr 1  20 rr rr           JSR   V_OUTP            ; output character
002850r 1  C8                 INY                     ; increment index
002851r 1  D0 F5              BNE   LAB_signon        ; loop, branch always
002853r 1               
002853r 1               LAB_nokey
002853r 1  20 rr rr           JSR   V_INPT            ; call scan input device
002856r 1  90 FB              BCC   LAB_nokey         ; loop if no key
002858r 1               
002858r 1  29 DF              AND   #$DF              ; mask xx0x xxxx, ensure upper case
00285Ar 1  C9 57              CMP   #'W'              ; compare with [W]arm start
00285Cr 1  F0 07              BEQ   LAB_dowarm        ; branch if [W]arm start
00285Er 1               
00285Er 1  C9 43              CMP   #'C'              ; compare with [C]old start
002860r 1  D0 D4              BNE   RES_vec           ; loop if not [C]old start
002862r 1               
002862r 1  4C rr rr           JMP   LAB_COLD          ; do EhBASIC cold start
002865r 1               
002865r 1               LAB_dowarm
002865r 1  4C 00 00           JMP   LAB_WARM          ; do EhBASIC warm start
002868r 1               
002868r 1               ; Polled 65c51 I/O routines adapted to EhBASIC. Delay routine from
002868r 1               ; http://forum.6502.org/viewtopic.php?f=4&t=2543&start=30#p29795
002868r 1               ACIA_RX      = $8400
002868r 1               ACIA_TX      = $8400
002868r 1               ACIA_STATUS  = $8401
002868r 1               ACIA_COMMAND = $8402
002868r 1               ACIA_CONTROL = $8403
002868r 1               
002868r 1               ACIAsetup
002868r 1  A9 00              LDA #$00                ; write anything to status register for program reset
00286Ar 1  8D 01 84           STA ACIA_STATUS
00286Dr 1  A9 0B              LDA #$0B                ; %0000 1011 = Receiver odd parity check
00286Fr 1                                             ;              Parity mode disabled
00286Fr 1                                             ;              Receiver normal mode
00286Fr 1                                             ;              RTSB Low, trans int disabled
00286Fr 1                                             ;              IRQB disabled
00286Fr 1                                             ;              Data terminal ready (DTRB low)
00286Fr 1  8D 02 84           STA ACIA_COMMAND        ; set command register
002872r 1  A9 1F              LDA #$1F                ; %0001 1111 = 19200 Baud
002874r 1                                             ;              External receiver
002874r 1                                             ;              8 bit words
002874r 1                                             ;              1 stop bit
002874r 1  8D 03 84           STA ACIA_CONTROL        ; set control register
002877r 1  60                 RTS
002878r 1               
002878r 1               ACIAout
002878r 1  48                 PHA                     ; save A
002879r 1  AD 01 84           LDA ACIA_STATUS         ; Read (and ignore) ACIA status register
00287Cr 1  68                 PLA                     ; restore A
00287Dr 1  8D 00 84           STA ACIA_TX             ; write byte
002880r 1  20 rr rr           JSR ACIAdelay           ; delay because of bug
002883r 1  60                 RTS
002884r 1               
002884r 1               ACIAdelay
002884r 1  5A                 PHY                     ; Save Y Reg
002885r 1  DA                 PHX                     ; Save X Reg
002886r 1               DELAY_LOOP
002886r 1  A0 06              LDY   #6                ; Get delay value (clock rate in MHz 2 clock cycles)
002888r 1               MINIDLY
002888r 1  A2 68              LDX   #$68              ; Seed X reg
00288Ar 1               DELAY_1
00288Ar 1  CA                 DEX                     ; Decrement low index
00288Br 1  D0 FD              BNE   DELAY_1           ; Loop back until done
00288Dr 1  88                 DEY                     ; Decrease by one
00288Er 1  D0 F8              BNE   MINIDLY           ; Loop until done
002890r 1  FA                 PLX                     ; Restore X Reg
002891r 1  7A                 PLY                     ; Restore Y Reg
002892r 1               DELAY_DONE
002892r 1  60                 RTS                     ; Delay done, return
002893r 1               
002893r 1               ACIAin
002893r 1  AD 01 84           LDA ACIA_STATUS         ; get ACIA status
002896r 1  29 08              AND #$08                ; mask rx buffer status flag
002898r 1  F0 05              BEQ LAB_nobyw           ; branch if no byte waiting
00289Ar 1  AD 00 84           LDA ACIA_RX             ; get byte from ACIA data port
00289Dr 1  38                 SEC                     ; flag byte received
00289Er 1  60                 RTS
00289Fr 1               LAB_nobyw
00289Fr 1  18                 CLC                     ; flag no byte received
0028A0r 1               no_load                       ; empty load vector for EhBASIC
0028A0r 1               no_save                       ; empty save vector for EhBASIC
0028A0r 1  60                 RTS
0028A1r 1               
0028A1r 1               ; vector tables
0028A1r 1               
0028A1r 1               LAB_vec
0028A1r 1  rr rr              .word ACIAin            ; byte in from simulated ACIA
0028A3r 1  rr rr              .word ACIAout           ; byte out to simulated ACIA
0028A5r 1  rr rr              .word no_load           ; null load vector for EhBASIC
0028A7r 1  rr rr              .word no_save           ; null save vector for EhBASIC
0028A9r 1               
0028A9r 1               ; EhBASIC IRQ support
0028A9r 1               
0028A9r 1               IRQ_CODE
0028A9r 1  48                 PHA                     ; save A
0028AAr 1  A5 DF              LDA   IrqBase           ; get the IRQ flag byte
0028ACr 1  4A                 LSR                     ; shift the set b7 to b6, and on down ...
0028ADr 1  05 DF              ORA   IrqBase           ; OR the original back in
0028AFr 1  85 DF              STA   IrqBase           ; save the new IRQ flag byte
0028B1r 1  68                 PLA                     ; restore A
0028B2r 1  40                 RTI
0028B3r 1               
0028B3r 1               ; EhBASIC NMI support
0028B3r 1               
0028B3r 1               NMI_CODE
0028B3r 1  48                 PHA                     ; save A
0028B4r 1  A5 DC              LDA   NmiBase           ; get the NMI flag byte
0028B6r 1  4A                 LSR                     ; shift the set b7 to b6, and on down ...
0028B7r 1  05 DC              ORA   NmiBase           ; OR the original back in
0028B9r 1  85 DC              STA   NmiBase           ; save the new NMI flag byte
0028BBr 1  68                 PLA                     ; restore A
0028BCr 1  40                 RTI
0028BDr 1               
0028BDr 1               END_CODE
0028BDr 1               
0028BDr 1               LAB_mess
0028BDr 1  0D 0A 36 35        .byte $0D,$0A,"6502 EhBASIC [C]old/[W]arm ?",$00
0028C1r 1  30 32 20 45  
0028C5r 1  68 42 41 53  
0028DCr 1                                             ; sign on string
0028DCr 1               
0028DCr 1               ; system vectors
0028DCr 1               
0028DCr 1                     .segment "VECTORS"
000000r 1               
000000r 1  17 02              .word NMI_vec           ; NMI vector
000002r 1  rr rr              .word RES_vec           ; RESET vector
000004r 1  0D 02              .word IRQ_vec           ; IRQ vector
000006r 1               
000006r 1                     .end RES_vec            ; set start at reset vector
